<!DOCTYPE html>
<html dark_mode="false">

<head>
    <meta charset="UTF-8">
    <title>Timetracker</title>

    <!-- Roboto font -->
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:400,600">

    <!-- Icons -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
          integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">


    <!-- Dependency for Tables -->
    <script>
        /**
         * (c) jExcel v3.4.1
         *
         * Author: Paul Hodel <paul.hodel@gmail.com>
         * Website: https://bossanova.uk/jexcel/
         * Description: Create amazing web based spreadsheets.
         *
         * This software is distribute under MIT License
         *
         * ROADMAP:
         * Frozen columns
         * Meta information
         */

        'use strict';

        if (!jSuites && typeof (require) === 'function') {
            var jSuites = require('jsuites');
            require('jsuites/dist/jsuites.css');
        }

        var jexcel = (function (el, options) {
            // Create jexcel object
            var obj = {};
            obj.options = {};

            // Loading default configuration
            var defaults = {
                // External data
                url: null,
                // Data
                data: [[]],
                // Copy behavior
                copyCompatibility: false,
                // Rows and columns definitions
                rows: [],
                columns: [],
                // Deprected legacy options
                colHeaders: [],
                colWidths: [],
                colAlignments: [],
                nestedHeaders: null,
                // Column width that is used by default
                defaultColWidth: 50,
                // Spare rows and columns
                minSpareRows: 0,
                minSpareCols: 0,
                // Minimal table dimensions
                minDimensions: [0, 0],
                // Allow Export
                allowExport: true,
                // Allow column sorting
                columnSorting: true,
                // Allow column dragging
                columnDrag: false,
                // Allow column resizing
                columnResize: true,
                // Allow row resizing
                rowResize: false,
                // Allow row dragging
                rowDrag: true,
                // Allow table edition
                editable: true,
                // Allow new rows
                allowInsertRow: true,
                // Allow new rows
                allowManualInsertRow: true,
                // Allow new columns
                allowInsertColumn: true,
                // Allow new rows
                allowManualInsertColumn: true,
                // Allow row delete
                allowDeleteRow: true,
                // Allow column delete
                allowDeleteColumn: true,
                // Allow rename column
                allowRenameColumn: true,
                // Allow comments
                allowComments: false,
                // Global wrap
                wordWrap: false,
                // CSV source
                csv: null,
                // Filename
                csvFileName: 'jexcel',
                // Consider first line as header
                csvHeaders: true,
                // Delimiters
                csvDelimiter: ',',
                // Disable corner selection
                selectionCopy: true,
                // Merged cells
                mergeCells: {},
                // Create toolbar
                toolbar: null,
                // Allow search
                search: false,
                // Create pagination
                pagination: false,
                paginationOptions: null,
                // Full screen
                fullscreen: false,
                // Lazy loading
                lazyLoading: false,
                loadingSpin: false,
                // Table overflow
                tableOverflow: false,
                tableHeight: '300px',
                tableWidth: null,
                // Meta
                meta: null,
                // Style
                style: null,
                // Event handles
                onload: null,
                onchange: null,
                onbeforechange: null,
                onbeforeinsertrow: null,
                oninsertrow: null,
                onbeforeinsertcolumn: null,
                oninsertcolumn: null,
                onbeforedeleterow: null,
                ondeleterow: null,
                onbeforedeletecolumn: null,
                ondeletecolumn: null,
                onmoverow: null,
                onmovecolumn: null,
                onresizerow: null,
                onresizecolumn: null,
                onsort: null,
                onselection: null,
                onpaste: null,
                onmerge: null,
                onfocus: null,
                onblur: null,
                onchangeheader: null,
                oneditionstart: null,
                oneditionend: null,
                onchangestyle: null,
                onchangemeta: null,
                // Customize any cell behavior
                updateTable: null,
                // Texts
                text: {
                    noRecordsFound: 'No records found',
                    showingPage: 'Showing page {0} of {1} entries',
                    show: 'Show ',
                    search: 'Search',
                    entries: ' entries',
                    columnName: 'Column name',
                    insertANewColumnBefore: 'Insert a new column before',
                    insertANewColumnAfter: 'Insert a new column after',
                    deleteSelectedColumns: 'Delete selected columns',
                    renameThisColumn: 'Rename this column',
                    orderAscending: 'Order ascending',
                    orderDescending: 'Order descending',
                    insertANewRowBefore: 'Insert a new row before',
                    insertANewRowAfter: 'Insert a new row after',
                    deleteSelectedRows: 'Delete selected rows',
                    editComments: 'Edit comments',
                    addComments: 'Add comments',
                    comments: 'Comments',
                    clearComments: 'Clear comments',
                    copy: 'Copy...',
                    paste: 'Paste...',
                    saveAs: 'Save as...',
                    about: 'About',
                    areYouSureToDeleteTheSelectedRows: 'Are you sure to delete the selected rows?',
                    areYouSureToDeleteTheSelectedColumns: 'Are you sure to delete the selected columns?',
                    thisActionWillDestroyAnyExistingMergedCellsAreYouSure: 'This action will destroy any existing merged cells. Are you sure?',
                    thisActionWillClearYourSearchResultsAreYouSure: 'This action will clear your search results. Are you sure?',
                    thereIsAConflictWithAnotherMergedCell: 'There is a conflict with another merged cell',
                    invalidMergeProperties: 'Invalid merged properties',
                    cellAlreadyMerged: 'Cell already merged',
                    noCellsSelected: 'No cells selected',
                },
                // About message
                about: "jExcel CE Spreadsheet\nVersion 3.4.1\nAuthor: Paul Hodel <paul.hodel@gmail.com>\nWebsite: https://jexcel.net/v3",
            };

            // Loading initial configuration from user
            for (var property in defaults) {
                if (options && options.hasOwnProperty(property)) {
                    obj.options[property] = (property == 'text') ? Object.assign(defaults[property], options[property]) : options[property];
                } else {
                    obj.options[property] = defaults[property];
                }
            }

            // Global elements
            obj.el = el;
            obj.corner = null;
            obj.contextMenu = null;
            obj.textarea = null;
            obj.ads = null;
            obj.content = null;
            obj.table = null;
            obj.thead = null;
            obj.tbody = null;
            obj.rows = [];
            obj.results = null;
            obj.searchInput = null;
            obj.toolbar = null;
            obj.pagination = null;
            obj.pageNumber = null;
            obj.headerContainer = null;
            obj.colgroupContainer = null;

            // Containers
            obj.headers = [];
            obj.records = [];
            obj.history = [];
            obj.formula = [];
            obj.formulaStack = 0;
            obj.colgroup = [];
            obj.selection = [];
            obj.highlighted = [];
            obj.selectedCell = null;
            obj.selectedContainer = null;
            obj.style = [];
            obj.meta = [];
            obj.data = null;

            // Internal controllers
            obj.cursor = null;
            obj.historyIndex = -1;
            obj.ignoreEvents = false;
            obj.ignoreHistory = false;
            obj.edition = null;
            obj.hashString = null;
            obj.resizing = null;
            obj.dragging = null;

            // Lazy loading
            if (obj.options.lazyLoading == true && (obj.options.tableOverflow == false && obj.options.fullscreen == false)) {
                console.error('JEXCEL: The lazyloading only works when tableOverflow = yes or fullscreen = yes');
                obj.options.lazyLoading = false;
            }

            /**
             * Prepare the jexcel table
             *
             * @Param config
             */
            obj.prepareTable = function () {
                // Loading initial data from remote sources
                var results = [];

                // Number of columns
                var size = obj.options.columns.length;

                if (typeof obj.options.data[0] !== 'undefined' && obj.options.data[0].length > size) {
                    size = obj.options.data[0].length;
                }

                // Minimal dimensions
                if (obj.options.minDimensions[0] > size) {
                    size = obj.options.minDimensions[0];
                }

                // Requests
                var multiple = [];

                // Preparations
                for (var i = 0; i < size; i++) {
                    // Deprected options. You should use only columns
                    if (!obj.options.colHeaders[i]) {
                        obj.options.colHeaders[i] = '';
                    }
                    if (!obj.options.colWidths[i]) {
                        obj.options.colWidths[i] = obj.options.defaultColWidth || '50';
                    }
                    if (!obj.options.colAlignments[i]) {
                        obj.options.colAlignments[i] = 'center';
                    }

                    // Default column description
                    if (!obj.options.columns[i]) {
                        obj.options.columns[i] = { type: 'text' };
                    } else if (!obj.options.columns[i].type) {
                        obj.options.columns[i].type = 'text';
                    }
                    if (!obj.options.columns[i].source) {
                        obj.options.columns[i].source = [];
                    }
                    if (!obj.options.columns[i].options) {
                        obj.options.columns[i].options = [];
                    }
                    if (!obj.options.columns[i].editor) {
                        obj.options.columns[i].editor = null;
                    }
                    if (!obj.options.columns[i].allowEmpty) {
                        obj.options.columns[i].allowEmpty = false;
                    }
                    if (!obj.options.columns[i].title) {
                        obj.options.columns[i].title = obj.options.colHeaders[i] ? obj.options.colHeaders[i] : '';
                    }
                    if (!obj.options.columns[i].width) {
                        obj.options.columns[i].width = obj.options.colWidths[i] ? obj.options.colWidths[i] : '50';
                    }
                    if (!obj.options.columns[i].align) {
                        obj.options.columns[i].align = obj.options.colAlignments[i] ? obj.options.colAlignments[i] : 'center';
                    }

                    // Pre-load initial source for json autocomplete
                    if (obj.options.columns[i].type == 'autocomplete' || obj.options.columns[i].type == 'dropdown') {
                        // if remote content
                        if (obj.options.columns[i].url) {
                            multiple.push(jSuites.ajax({
                                url: obj.options.columns[i].url,
                                index: i,
                                method: 'GET',
                                dataType: 'json',
                                multiple: multiple,
                                success: function (data) {
                                    var source = [];
                                    for (var i = 0; i < data.length; i++) {
                                        obj.options.columns[this.index].source.push(data[i]);
                                    }
                                },
                                complete: function () {
                                    obj.createTable();
                                }
                            }));
                        }
                    } else if (obj.options.columns[i].type == 'calendar') {
                        // Default format for date columns
                        if (!obj.options.columns[i].options.format) {
                            obj.options.columns[i].options.format = 'DD/MM/YYYY';
                        }
                    }
                }

                // On complete
                if (!multiple.length) {
                    obj.createTable();
                }
            }

            obj.createTable = function () {
                // Elements
                obj.table = document.createElement('table');
                obj.thead = document.createElement('thead');
                obj.tbody = document.createElement('tbody');

                // Create headers controllers
                obj.headers = [];
                obj.colgroup = [];

                // Create table container
                obj.content = document.createElement('div');
                obj.content.classList.add('jexcel_content');

                // Create toolbar object
                obj.toolbar = document.createElement('div');
                obj.toolbar.classList.add('jexcel_toolbar');

                // Search
                var searchContainer = document.createElement('div');
                var searchText = document.createTextNode((obj.options.text.search) + ': ');
                obj.searchInput = document.createElement('input');
                obj.searchInput.classList.add('jexcel_search');
                searchContainer.appendChild(searchText);
                searchContainer.appendChild(obj.searchInput);
                obj.searchInput.onfocus = function () {
                    obj.resetSelection();
                }

                // Pagination select option
                var paginationUpdateContainer = document.createElement('div');

                if (obj.options.pagination > 0 && obj.options.paginationOptions && obj.options.paginationOptions.length > 0) {
                    obj.paginationDropdown = document.createElement('select');
                    obj.paginationDropdown.classList.add('jexcel_pagination_dropdown');
                    obj.paginationDropdown.onchange = function () {
                        obj.options.pagination = parseInt(this.value);
                        obj.page(0);
                    }

                    for (var i = 0; i < obj.options.paginationOptions.length; i++) {
                        var temp = document.createElement('option');
                        temp.value = obj.options.paginationOptions[i];
                        temp.innerHTML = obj.options.paginationOptions[i];
                        obj.paginationDropdown.appendChild(temp);
                    }

                    paginationUpdateContainer.appendChild(document.createTextNode(obj.options.text.show));
                    paginationUpdateContainer.appendChild(obj.paginationDropdown);
                    paginationUpdateContainer.appendChild(document.createTextNode(obj.options.text.entries));
                }

                // Filter and pagination container
                obj.filter = document.createElement('div');
                obj.filter.classList.add('jexcel_filter');
                obj.filter.appendChild(paginationUpdateContainer);
                obj.filter.appendChild(searchContainer);

                // Colsgroup
                obj.colgroupContainer = document.createElement('colgroup');
                var tempCol = document.createElement('col');
                tempCol.setAttribute('width', 50);
                obj.colgroupContainer.appendChild(tempCol);

                // Nested
                if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                    // Flexible way to handle nestedheaders
                    if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                        for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                            obj.thead.appendChild(obj.createNestedHeader(obj.options.nestedHeaders[j]));
                        }
                    } else {
                        obj.thead.appendChild(obj.createNestedHeader(obj.options.nestedHeaders));
                    }
                }

                // Row
                obj.headerContainer = document.createElement('tr');
                var tempCol = document.createElement('td');
                tempCol.classList.add('jexcel_selectall');
                obj.headerContainer.appendChild(tempCol);

                for (var i = 0; i < obj.options.columns.length; i++) {
                    // Create header
                    obj.createCellHeader(i);
                    // Append cell to the container
                    obj.headerContainer.appendChild(obj.headers[i]);
                    obj.colgroupContainer.appendChild(obj.colgroup[i]);
                }

                obj.thead.appendChild(obj.headerContainer);

                // Content table
                obj.table = document.createElement('table');
                obj.table.classList.add('jexcel');
                obj.table.setAttribute('cellpadding', '0');
                obj.table.setAttribute('cellspacing', '0');
                obj.table.setAttribute('unselectable', 'yes');
                obj.table.setAttribute('onselectstart', 'return false');
                obj.table.appendChild(obj.colgroupContainer);
                obj.table.appendChild(obj.thead);
                obj.table.appendChild(obj.tbody);

                // Spreadsheet corner
                obj.corner = document.createElement('div');
                obj.corner.className = 'jexcel_corner';
                obj.corner.setAttribute('unselectable', 'on');
                obj.corner.setAttribute('onselectstart', 'return false');

                if (obj.options.selectionCopy == false) {
                    obj.corner.style.display = 'none';
                }

                // Textarea helper
                obj.textarea = document.createElement('textarea');
                obj.textarea.className = 'jexcel_textarea';
                obj.textarea.id = 'jexcel_textarea';

                // Contextmenu container
                obj.contextMenu = document.createElement('div');
                obj.contextMenu.className = 'jexcel_contextmenu';

                // Create element
                jSuites.contextmenu(obj.contextMenu, {
                    onclick: function () {
                        obj.contextMenu.contextmenu.close(false);
                    }
                });

                // Powered by jExcel
                var ads = '<a href="https://bossanova.uk/jexcel/"><img src="//bossanova.uk/jexcel/logo.png">jExcel Spreadsheet</a>';
                obj.ads = document.createElement('div');
                obj.ads.className = 'jexcel_about';
                if (typeof (sessionStorage) !== "undefined") {
                    if (!sessionStorage.getItem('jexcel')) {
                        sessionStorage.setItem('jexcel', true);
                        obj.ads.innerHTML = ads;
                    }
                } else {
                    obj.ads.innerHTML = ads;
                }

                // Create table container TODO: frozen columns
                var container = document.createElement('div');
                container.classList.add('jexcel_table');

                // Pagination
                obj.pagination = document.createElement('div');
                obj.pagination.classList.add('jexcel_pagination');
                var paginationInfo = document.createElement('div');
                var paginationPages = document.createElement('div');
                obj.pagination.appendChild(paginationInfo);
                obj.pagination.appendChild(paginationPages);

                // Append containers to the table
                if (obj.options.search == true) {
                    el.appendChild(obj.filter);
                }

                // Elements
                obj.content.appendChild(obj.table);
                obj.content.appendChild(obj.corner);
                obj.content.appendChild(obj.textarea);

                el.appendChild(obj.toolbar);
                el.appendChild(obj.content);
                el.appendChild(obj.pagination);
                el.appendChild(obj.contextMenu);
                el.appendChild(obj.ads);
                el.classList.add('jexcel_container');

                // Create toolbar
                if (obj.options.toolbar && obj.options.toolbar.length) {
                    obj.createToolbar();
                }

                // Fullscreen
                if (obj.options.fullscreen == true) {
                    el.classList.add('fullscreen');
                    if (obj.options.toolbar) {
                        el.classList.add('with-toolbar');
                    }
                } else {
                    // Overflow
                    if (obj.options.tableOverflow == true) {
                        if (obj.options.tableHeight) {
                            obj.content.style['overflow-y'] = 'auto';
                            obj.content.style.height = obj.options.tableHeight;
                        }
                        if (obj.options.tableWidth) {
                            obj.content.style['overflow-x'] = 'auto';
                            obj.content.style.width = obj.options.tableWidth;
                        }
                    }
                }

                // Actions
                if (obj.options.columnDrag == true) {
                    obj.thead.classList.add('draggable');
                }
                if (obj.options.columnResize == true) {
                    obj.thead.classList.add('resizable');
                }
                if (obj.options.rowDrag == true) {
                    obj.tbody.classList.add('draggable');
                }
                if (obj.options.rowResize == true) {
                    obj.tbody.classList.add('resizable');
                }

                // Load data
                obj.setData();

                // Style
                if (obj.options.style) {
                    obj.setStyle(obj.options.style, null, null, 1, 1);
                }
            }

            /**
             * Set data
             *
             * @param array data In case no data is sent, default is reloaded
             * @return void
             */
            obj.setData = function (data) {
                // Update data
                if (data) {
                    if (typeof (data) == 'string') {
                        data = JSON.parse(data);
                    }

                    obj.options.data = data;
                }

                // Adjust minimal dimensions
                var j = 0;
                var i = 0;
                var size_i = obj.options.columns.length;
                var size_j = obj.options.data.length;
                var min_i = obj.options.minDimensions[0];
                var min_j = obj.options.minDimensions[1];
                var max_i = min_i > size_i ? min_i : size_i;
                var max_j = min_j > size_j ? min_j : size_j;

                for (j = 0; j < max_j; j++) {
                    for (i = 0; i < max_i; i++) {
                        if (obj.options.data[j] == undefined) {
                            obj.options.data[j] = [];
                        }

                        if (obj.options.data[j][i] == undefined) {
                            obj.options.data[j][i] = '';
                        }
                    }
                }

                // Reset containers
                obj.rows = [];
                obj.results = null;
                obj.records = [];
                obj.history = [];

                // Reset internal controllers
                obj.historyIndex = -1;

                // Reset data
                obj.tbody.innerHTML = '';

                // Lazy loading
                if (obj.options.lazyLoading == true) {
                    // Load only 100 records
                    var startNumber = 0
                    var finalNumber = obj.options.data.length < 100 ? obj.options.data.length : 100;

                    if (obj.options.pagination) {
                        obj.options.pagination = false;
                        console.error('JEXCEL: Pagination will be disable due the lazyLoading');
                    }
                } else if (obj.options.pagination) {
                    // Pagination
                    if (!obj.pageNumber) {
                        obj.pageNumber = 0;
                    }
                    var quantityPerPage = obj.options.pagination;
                    startNumber = (obj.options.pagination * obj.pageNumber);
                    finalNumber = (obj.options.pagination * obj.pageNumber) + obj.options.pagination;

                    if (obj.options.data.length < finalNumber) {
                        finalNumber = obj.options.data.length;
                    }
                } else {
                    var startNumber = 0;
                    var finalNumber = obj.options.data.length;
                }

                // Append nodes to the HTML
                for (j = 0; j < obj.options.data.length; j++) {
                    // Create row
                    var tr = obj.createRow(j, obj.options.data[j]);
                    // Append line to the table
                    if (j >= startNumber && j < finalNumber) {
                        obj.tbody.appendChild(tr);
                    }
                }

                if (obj.options.lazyLoading == true) {
                    // Do not create pagination with lazyloading activated
                } else if (obj.options.pagination) {
                    obj.updatePagination();
                }

                // Merge cells
                if (obj.options.mergeCells) {
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        var num = obj.options.mergeCells[keys[i]];
                        obj.setMerge(keys[i], num[0], num[1], 1);
                    }
                }

                // Updata table with custom configurations if applicable
                obj.updateTable();

                // Onload
                if (!obj.ignoreEvents) {
                    if (typeof (obj.options.onload) == 'function') {
                        obj.options.onload(el);
                    }
                }
            }

            /**
             * Get the whole table data
             *
             * @param integer row number
             * @return string value
             */
            obj.getData = function (highlighted) {
                // Control vars
                var dataset = [];
                var px = 0;
                var py = 0;

                // Column and row length
                var x = obj.options.data[0].length
                var y = obj.options.data.length

                // Go through the columns to get the data
                for (var j = 0; j < y; j++) {
                    px = 0;
                    for (var i = 0; i < x; i++) {
                        // Cell selected or fullset
                        if (!highlighted || obj.records[j][i].classList.contains('highlight')) {
                            // Get value
                            if (!dataset[py]) {
                                dataset[py] = [];
                            }
                            dataset[py][px] = obj.options.data[j][i];
                            px++;
                        }
                    }
                    if (px > 0) {
                        py++;
                    }
                }

                return dataset;
            }

            /**
             * Get a row data by rowNumber
             */
            obj.getRowData = function (rowNumber) {
                return obj.options.data[rowNumber];
            }

            /**
             * Set a row data by rowNumber
             */
            obj.setRowData = function (rowNumber, data) {
                for (var i = 0; i < obj.headers.length; i++) {
                    // Update cell
                    var columnName = jexcel.getColumnNameFromId([i, rowNumber]);
                    // Set value
                    obj.setValue(columnName, data[i]);
                }
            }

            /**
             * Get a column data by columnNumber
             */
            obj.getColumnData = function (columnNumber) {
                var dataset = [];
                // Go through the rows to get the data
                for (var j = 0; j < obj.options.data.length; j++) {
                    dataset.push(obj.options.data[j][columnNumber]);
                }
                return dataset;
            }

            /**
             * Create row
             */
            obj.createRow = function (j, data) {
                // Create container
                if (!obj.records[j]) {
                    obj.records[j] = [];
                }
                // New line of data to be append in the table
                obj.rows[j] = document.createElement('tr');
                obj.rows[j].setAttribute('data-y', j);
                // Definitions
                if (obj.options.rows[j]) {
                    if (obj.options.rows[j].height) {
                        obj.rows[j].style.height = obj.options.rows[j].height;
                    }
                }
                // Row number label
                var td = document.createElement('td');
                td.innerHTML = parseInt(j + 1);
                td.setAttribute('data-y', j);
                td.className = 'jexcel_row';
                obj.rows[j].appendChild(td);

                // Data columns
                for (i = 0; i < obj.options.columns.length; i++) {
                    // New column of data to be append in the line
                    obj.records[j][i] = obj.createCell(i, j, data[i]);
                    // Add column to the row
                    obj.rows[j].appendChild(obj.records[j][i]);
                }

                // Add row to the table body
                return obj.rows[j];
            }

            /**
             * Create cell
             */
            obj.createCell = function (i, j, value) {
                // Create cell and properties
                var td = document.createElement('td');
                td.setAttribute('data-x', i);
                td.setAttribute('data-y', j);
                // Hidden column
                if (obj.options.columns[i].type == 'hidden') {
                    td.style.display = 'none';
                    td.innerHTML = value;
                } else if (obj.options.columns[i].type == 'checkbox' || obj.options.columns[i].type == 'radio') {
                    // Create input
                    var element = document.createElement('input');
                    element.type = obj.options.columns[i].type;
                    element.name = 'c' + i;
                    element.checked = (value == 1 || value == true || value == 'true') ? true : false;
                    element.onclick = function () {
                        obj.setValue(td, this.checked);
                    }

                    if (obj.options.columns[i].readOnly == true) {
                        element.setAttribute('disabled', 'disabled');
                    }

                    // Append to the table
                    td.appendChild(element);
                    // Make sure the values are correct
                    obj.options.data[j][i] = element.checked;
                } else if (obj.options.columns[i].type == 'calendar') {
                    // Try formatted date
                    var formatted = jSuites.calendar.extractDateFromString(value, obj.options.columns[i].options.format);
                    // Create calendar cell
                    td.innerHTML = jSuites.calendar.getDateString(formatted ? formatted : value, obj.options.columns[i].options.format);
                } else if (obj.options.columns[i].type == 'dropdown' || obj.options.columns[i].type == 'autocomplete') {
                    // Create dropdown cell
                    td.classList.add('dropdown');
                    td.innerHTML = obj.getDropDownValue(i, value);
                } else if (obj.options.columns[i].type == 'color') {
                    if (obj.options.columns[i].render == 'square') {
                        var color = document.createElement('div');
                        color.className = 'color';
                        color.style.backgroundColor = value;
                        td.appendChild(color);
                    } else {
                        td.style.color = value;
                        td.innerHTML = value;
                    }
                } else if (obj.options.columns[i].type == 'image') {
                    if (value && value.substr(0, 10) == 'data:image') {
                        var img = document.createElement('img');
                        img.src = value;
                        td.appendChild(img);
                    }
                } else {
                    if (('' + value).substr(0, 1) == '=') {
                        value = obj.executeFormula(value, i, j)
                    }
                    if (obj.options.columns[i].mask) {
                        var decimal = obj.options.columns[i].decimal || '.';
                        value = '' + jSuites.mask.run(value, obj.options.columns[i].mask, decimal);
                    }

                    td.innerHTML = value;
                }

                // Readonly
                if (obj.options.columns[i].readOnly == true) {
                    td.className = 'readonly';
                }

                // Text align
                var colAlign = obj.options.columns[i].align ? obj.options.columns[i].align : 'center';
                td.style.textAlign = colAlign;

                // Wrap option
                if (obj.options.wordWrap == true || obj.options.columns[i].wordWrap == true || td.innerHTML.length > 200) {
                    td.style.whiteSpace = 'pre-wrap';
                }

                // Overflow
                if (i > 0) {
                    if (value || td.innerHTML) {
                        obj.records[j][i - 1].style.overflow = 'hidden';
                    } else {
                        if (i == obj.options.columns.length - 1) {
                            td.style.overflow = 'hidden';
                        }
                    }
                }

                return td;
            }

            obj.createCellHeader = function (colNumber) {
                // Create col global control
                var colWidth = obj.options.columns[colNumber].width ? obj.options.columns[colNumber].width : obj.options.defaultColWidth;
                var colAlign = obj.options.columns[colNumber].align ? obj.options.columns[colNumber].align : 'center';

                // Create header cell
                obj.headers[colNumber] = document.createElement('td');
                obj.headers[colNumber].innerHTML = obj.options.columns[colNumber].title ? obj.options.columns[colNumber].title : jexcel.getColumnName(colNumber);
                obj.headers[colNumber].setAttribute('data-x', colNumber);
                obj.headers[colNumber].style.textAlign = colAlign;
                if (obj.options.columns[colNumber].title) {
                    obj.headers[colNumber].setAttribute('title', obj.options.columns[colNumber].title);
                }

                // Width control
                obj.colgroup[colNumber] = document.createElement('col');
                obj.colgroup[colNumber].setAttribute('width', colWidth);

                // Hidden column
                if (obj.options.columns[colNumber].type == 'hidden') {
                    obj.headers[colNumber].style.display = 'none';
                    obj.colgroup[colNumber].style.display = 'none';
                }
            }

            obj.createNestedHeader = function (nestedInformation) {
                var tr = document.createElement('tr');
                tr.classList.add('jexcel_nested');
                var td = document.createElement('td');
                tr.appendChild(td);

                var headerIndex = 0;
                for (var i = 0; i < nestedInformation.length; i++) {
                    // Default values
                    if (!nestedInformation[i].colspan) {
                        nestedInformation[i].colspan = 1;
                    }
                    if (!nestedInformation[i].align) {
                        nestedInformation[i].align = 'center';
                    }
                    if (!nestedInformation[i].title) {
                        nestedInformation[i].title = '';
                    }

                    // Classes container
                    var column = [];
                    // Header classes for this cell
                    for (var x = 0; x < nestedInformation[i].colspan; x++) {
                        column.push(headerIndex);
                        headerIndex++;
                    }

                    // Created the nested cell
                    var td = document.createElement('td');
                    td.setAttribute('data-column', column.join(','));
                    td.setAttribute('colspan', nestedInformation[i].colspan);
                    td.setAttribute('align', nestedInformation[i].align);
                    td.innerHTML = nestedInformation[i].title;
                    tr.appendChild(td);
                }

                return tr;
            }

            /**
             * Create toolbar
             */
            obj.createToolbar = function (toolbar) {
                if (toolbar) {
                    obj.options.toolbar = toolbar;
                } else {
                    var toolbar = obj.options.toolbar;
                }

                for (var i = 0; i < toolbar.length; i++) {
                    if (toolbar[i].type == 'i') {
                        var toolbarItem = document.createElement('i');
                        toolbarItem.classList.add('jexcel_toolbar_item');
                        toolbarItem.classList.add('material-icons');
                        toolbarItem.setAttribute('data-k', toolbar[i].k);
                        toolbarItem.setAttribute('data-v', toolbar[i].v);
                        // Tooltip
                        if (toolbar[i].tooltip) {
                            toolbarItem.setAttribute('title', toolbar[i].tooltip);
                        }
                        // Handle click
                        if (toolbar[i].onclick && typeof (toolbar[i].onclick)) {
                            toolbarItem.onclick = toolbar[i].onclick;
                        } else {
                            toolbarItem.onclick = function () {
                                var k = this.getAttribute('data-k');
                                var v = this.getAttribute('data-v');
                                obj.setStyle(obj.highlighted, k, v);
                            }
                        }
                        // Append element
                        toolbarItem.innerHTML = toolbar[i].content;
                        obj.toolbar.appendChild(toolbarItem);
                    } else if (toolbar[i].type == 'select') {
                        var toolbarItem = document.createElement('select');
                        toolbarItem.classList.add('jexcel_toolbar_item');
                        toolbarItem.setAttribute('data-k', toolbar[i].k);
                        // Tooltip
                        if (toolbar[i].tooltip) {
                            toolbarItem.setAttribute('title', toolbar[i].tooltip);
                        }
                        // Handle onchange
                        if (toolbar[i].onchange && typeof (toolbar[i].onchange)) {
                            toolbarItem.onchange = toolbar[i].onchange;
                        } else {
                            toolbarItem.onchange = function () {
                                var k = this.getAttribute('data-k');
                                obj.setStyle(obj.highlighted, k, this.value);
                            }
                        }
                        // Add options to the dropdown
                        for (var j = 0; j < toolbar[i].v.length; j++) {
                            var toolbarDropdownOption = document.createElement('option');
                            toolbarDropdownOption.value = toolbar[i].v[j];
                            toolbarDropdownOption.innerHTML = toolbar[i].v[j];
                            toolbarItem.appendChild(toolbarDropdownOption);
                        }
                        obj.toolbar.appendChild(toolbarItem);
                    } else if (toolbar[i].type == 'color') {
                        var toolbarItem = document.createElement('i');
                        toolbarItem.classList.add('jexcel_toolbar_item');
                        toolbarItem.classList.add('material-icons');
                        toolbarItem.setAttribute('data-k', toolbar[i].k);
                        toolbarItem.setAttribute('data-v', '');
                        // Tooltip
                        if (toolbar[i].tooltip) {
                            toolbarItem.setAttribute('title', toolbar[i].tooltip);
                        }
                        obj.toolbar.appendChild(toolbarItem);
                        toolbarItem.onclick = function () {
                            this.color.open();
                        }
                        toolbarItem.innerHTML = toolbar[i].content;
                        jSuites.color(toolbarItem, {
                            onchange: function (o, v) {
                                var k = o.getAttribute('data-k');
                                obj.setStyle(obj.highlighted, k, v);
                            }
                        });
                    }
                }
            }

            /**
             * Merge cells
             * @param cellName
             * @param colspan
             * @param rowspan
             * @param ignoreHistoryAndEvents
             */
            obj.setMerge = function (cellName, colspan, rowspan, ignoreHistoryAndEvents) {
                var test = false;

                if (!cellName) {
                    if (!obj.highlighted.length) {
                        alert(obj.options.text.noCellsSelected);
                        return null;
                    } else {
                        var x1 = parseInt(obj.highlighted[0].getAttribute('data-x'));
                        var y1 = parseInt(obj.highlighted[0].getAttribute('data-y'));
                        var x2 = parseInt(obj.highlighted[obj.highlighted.length - 1].getAttribute('data-x'));
                        var y2 = parseInt(obj.highlighted[obj.highlighted.length - 1].getAttribute('data-y'));
                        var cellName = jexcel.getColumnNameFromId([x1, y1]);
                        var colspan = (x2 - x1) + 1;
                        var rowspan = (y2 - y1) + 1;
                    }
                }

                var cell = jexcel.getIdFromColumnName(cellName, true);

                if (obj.options.mergeCells[cellName]) {
                    if (obj.records[cell[1]][cell[0]].getAttribute('data-merged')) {
                        test = obj.options.text.cellAlreadyMerged;
                    }
                } else if ((!colspan || colspan < 2) && (!rowspan || rowspan < 2)) {
                    test = obj.options.text.invalidMergeProperties;
                } else {
                    var cells = [];
                    for (var j = cell[1]; j < cell[1] + rowspan; j++) {
                        for (var i = cell[0]; i < cell[0] + colspan; i++) {
                            var columnName = jexcel.getColumnNameFromId([i, j]);
                            if (obj.records[j][i].getAttribute('data-merged')) {
                                test = obj.options.text.thereIsAConflictWithAnotherMergedCell;
                            }
                        }
                    }
                }

                if (test) {
                    alert(test);
                } else {
                    // Add property
                    if (colspan > 1) {
                        obj.records[cell[1]][cell[0]].setAttribute('colspan', colspan);
                    } else {
                        colspan = 1;
                    }
                    if (rowspan > 1) {
                        obj.records[cell[1]][cell[0]].setAttribute('rowspan', rowspan);
                    } else {
                        rowspan = 1;
                    }
                    // Keep links to the existing nodes
                    obj.options.mergeCells[cellName] = [colspan, rowspan, []];
                    // Mark cell as merged
                    obj.records[cell[1]][cell[0]].setAttribute('data-merged', 'true');
                    // Overflow
                    obj.records[cell[1]][cell[0]].style.overflow = 'hidden';
                    // History data
                    var data = [];
                    // Adjust the nodes
                    for (var y = cell[1]; y < cell[1] + rowspan; y++) {
                        for (var x = cell[0]; x < cell[0] + colspan; x++) {
                            if (!(cell[0] == x && cell[1] == y)) {
                                data.push(obj.options.data[y][x]);
                                obj.updateCell(x, y, '', true);
                                obj.options.mergeCells[cellName][2].push(obj.records[y][x]);
                                obj.records[y][x].style.display = 'none';
                                obj.records[y][x] = obj.records[cell[1]][cell[0]];
                            }
                        }
                    }
                    // In the initialization is not necessary keep the history
                    obj.updateSelection(obj.records[cell[1]][cell[0]]);

                    if (!ignoreHistoryAndEvents) {
                        obj.setHistory({
                            action: 'setMerge',
                            column: cellName,
                            colspan: colspan,
                            rowspan: rowspan,
                            data: data,
                        });

                        if (typeof (obj.options.onmerge) == 'function') {
                            obj.options.onmerge(el, cellName, colspan, rowspan);
                        }
                    }
                }
            }

            /**
             * Merge cells
             * @param cellName
             * @param colspan
             * @param rowspan
             * @param ignoreHistoryAndEvents
             */
            obj.getMerge = function (cellName) {
                var data = {};
                if (cellName) {
                    if (obj.options.mergeCells[cellName]) {
                        data = [obj.options.mergeCells[cellName][0], obj.options.mergeCells[cellName][1]];
                    } else {
                        data = null;
                    }
                } else {
                    if (obj.options.mergeCells) {
                        var mergedCells = obj.options.mergeCells;
                        var keys = Object.keys(obj.options.mergeCells);
                        for (var i = 0; i < keys.length; i++) {
                            data[keys[i]] = [obj.options.mergeCells[keys[i]][0], obj.options.mergeCells[keys[i]][1]];
                        }
                    }
                }

                return data;
            }

            /**
             * Remove merge by cellname
             * @param cellName
             */
            obj.removeMerge = function (cellName, data, keepOptions) {
                if (obj.options.mergeCells[cellName]) {
                    var cell = jexcel.getIdFromColumnName(cellName, true);
                    obj.records[cell[1]][cell[0]].removeAttribute('colspan');
                    obj.records[cell[1]][cell[0]].removeAttribute('rowspan');
                    obj.records[cell[1]][cell[0]].removeAttribute('data-merged');
                    var info = obj.options.mergeCells[cellName];

                    var index = 0;
                    for (var j = 0; j < info[1]; j++) {
                        for (var i = 0; i < info[0]; i++) {
                            if (j > 0 || i > 0) {
                                obj.records[cell[1] + j][cell[0] + i] = info[2][index];
                                obj.records[cell[1] + j][cell[0] + i].style.display = '';
                                // Recover data
                                if (data && data[index]) {
                                    obj.updateCell(cell[0] + i, cell[1] + j, data[index]);
                                }
                                index++;
                            }
                        }
                    }

                    // Update selection
                    obj.updateSelection(obj.records[cell[1]][cell[0]], obj.records[cell[1] + j - 1][cell[0] + i - 1]);

                    if (!keepOptions) {
                        delete (obj.options.mergeCells[cellName]);
                    }
                }
            }

            /**
             * Remove all merged cells
             */
            obj.destroyMerged = function (keepOptions) {
                // Remove any merged cells
                if (obj.options.mergeCells) {
                    var mergedCells = obj.options.mergeCells;
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        obj.removeMerge(keys[i], null, keepOptions);
                    }
                }
            }

            /**
             * Is column merged
             */
            obj.isColMerged = function (x, insertBefore) {
                var cols = [];
                // Remove any merged cells
                if (obj.options.mergeCells) {
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        var info = jexcel.getIdFromColumnName(keys[i], true);
                        var colspan = obj.options.mergeCells[keys[i]][0];
                        var x1 = info[0];
                        var x2 = info[0] + (colspan > 1 ? colspan - 1 : 0);

                        if (insertBefore == null) {
                            if ((x1 <= x && x2 >= x)) {
                                cols.push(keys[i]);
                            }
                        } else {
                            if (insertBefore) {
                                if ((x1 < x && x2 >= x)) {
                                    cols.push(keys[i]);
                                }
                            } else {
                                if ((x1 <= x && x2 > x)) {
                                    cols.push(keys[i]);
                                }
                            }
                        }
                    }
                }

                return cols;
            }

            /**
             * Is rows merged
             */
            obj.isRowMerged = function (y, insertBefore) {
                var rows = [];
                // Remove any merged cells
                if (obj.options.mergeCells) {
                    var keys = Object.keys(obj.options.mergeCells);
                    for (var i = 0; i < keys.length; i++) {
                        var info = jexcel.getIdFromColumnName(keys[i], true);
                        var rowspan = obj.options.mergeCells[keys[i]][1];
                        var y1 = info[1];
                        var y2 = info[1] + (rowspan > 1 ? rowspan - 1 : 0);

                        if (insertBefore == null) {
                            if ((y1 <= y && y2 >= y)) {
                                rows.push(keys[i]);
                            }
                        } else {
                            if (insertBefore) {
                                if ((y1 < y && y2 >= y)) {
                                    rows.push(keys[i]);
                                }
                            } else {
                                if ((y1 <= y && y2 > y)) {
                                    rows.push(keys[i]);
                                }
                            }
                        }
                    }
                }

                return rows;
            }

            /**
             * Open the editor
             *
             * @param object cell
             * @return void
             */
            obj.openEditor = function (cell, empty, e) {
                // Get cell position
                var y = cell.getAttribute('data-y');
                var x = cell.getAttribute('data-x');

                // On edition start
                if (!obj.ignoreEvents) {
                    if (typeof (obj.options.oneditionstart) == 'function') {
                        obj.options.oneditionstart(el, cell, x, y);
                    }
                }

                // Overflow
                if (x > 0) {
                    obj.records[y][x - 1].style.overflow = 'hidden';
                }

                // Create editor
                var createEditor = function (type) {
                    // Cell information
                    let info = cell.getBoundingClientRect();

                    // Create dropdown
                    var editor = document.createElement(type);
                    editor.style.width = (info.width) + 'px';
                    editor.style.height = (info.height - 2) + 'px';
                    editor.style.minHeight = (info.height - 2) + 'px';

                    // Edit cell
                    cell.classList.add('editor');
                    cell.innerHTML = '';
                    cell.appendChild(editor);

                    return editor;
                }

                // Readonly
                if (cell.classList.contains('readonly') == true) {
                    // Do nothing
                } else {
                    // Holder
                    obj.edition = [obj.records[y][x], obj.records[y][x].innerHTML, x, y];

                    // If there is a custom editor for it
                    if (obj.options.columns[x].editor) {
                        // Custom editors
                        obj.options.columns[x].editor.openEditor(cell, el);
                    } else {
                        // Native functions
                        if (obj.options.columns[x].type == 'hidden') {
                            // Do nothing
                        } else if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio') {
                            // Get value
                            var value = cell.children[0].checked ? false : true;
                            // Toogle value
                            obj.setValue(cell, value);
                            // Do not keep edition open
                            obj.edition = null;
                        } else if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            // Get current value
                            var value = obj.options.data[y][x];

                            // Create dropdown
                            if (typeof (obj.options.columns[x].filter) == 'function') {
                                var source = obj.options.columns[x].filter(el, cell, x, y, obj.options.columns[x].source);
                            } else {
                                var source = obj.options.columns[x].source;
                            }

                            // Create editor
                            var editor = createEditor('div');
                            var options = {
                                data: source,
                                multiple: obj.options.columns[x].multiple ? true : false,
                                autocomplete: obj.options.columns[x].autocomplete || obj.options.columns[x].type == 'autocomplete' ? true : false,
                                opened: true,
                                value: obj.options.columns[x].multiple ? value.split(';') : value,
                                width: '100%',
                                height: editor.style.minHeight,
                                position: (obj.options.tableOverflow == true || obj.options.fullscreen == true) ? true : false,
                                onclose: function () {
                                    obj.closeEditor(cell, true);
                                }
                            };
                            if (obj.options.columns[x].options && obj.options.columns[x].options.type) {
                                options.type = obj.options.columns[x].options.type;
                            }
                            jSuites.dropdown(editor, options);
                        } else if (obj.options.columns[x].type == 'calendar' || obj.options.columns[x].type == 'color') {
                            // Value
                            var value = obj.options.data[y][x];
                            // Create editor
                            var editor = createEditor('input');
                            editor.value = value;

                            if (obj.options.tableOverflow == true || obj.options.fullscreen == true) {
                                obj.options.columns[x].options.position = true;
                            }
                            obj.options.columns[x].options.value = obj.options.data[y][x];
                            obj.options.columns[x].options.onclose = function (el, value) {
                                obj.closeEditor(cell, true);
                            }
                            // Current value
                            if (obj.options.columns[x].type == 'color') {
                                jSuites.color(editor, obj.options.columns[x].options);
                            } else {
                                var calendar = jSuites.calendar(editor, obj.options.columns[x].options);
                                calendar.setValue(value);
                            }
                            // Focus on editor
                            editor.focus();
                        } else if (obj.options.columns[x].type == 'image') {
                            // Value
                            var img = cell.children[0];
                            // Create editor
                            var editor = createEditor('div');
                            editor.style.position = 'relative';
                            var div = document.createElement('div');
                            div.classList.add('jclose');
                            if (img && img.src) {
                                div.appendChild(img);
                            }
                            editor.appendChild(div);
                            jSuites.image(div);
                            const rect = cell.getBoundingClientRect();
                            const rectContent = div.getBoundingClientRect();
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                div.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                            } else {
                                div.style.top = (rect.top) + 'px';
                            }
                        } else {
                            // Value
                            var value = empty == true ? '' : obj.options.data[y][x];

                            // Basic editor
                            if (obj.options.wordWrap == true || obj.options.columns[x].wordWrap == true || value.length > 200) {
                                var editor = createEditor('textarea');
                            } else {
                                var editor = createEditor('input');
                                // Mask
                                if (obj.options.columns[x].mask) {
                                    editor.setAttribute('data-mask', obj.options.columns[x].mask);
                                }
                            }

                            editor.value = value;
                            editor.onblur = function () {
                                obj.closeEditor(cell, true);
                            };
                            editor.focus();
                        }
                    }
                }
            }

            /**
             * Close the editor and save the information
             *
             * @param object cell
             * @param boolean save
             * @return void
             */
            obj.closeEditor = function (cell, save) {
                var x = parseInt(cell.getAttribute('data-x'));
                var y = parseInt(cell.getAttribute('data-y'));

                // Get cell properties
                if (save == true) {
                    // If custom editor
                    if (obj.options.columns[x].editor) {
                        // Custom editor
                        var value = obj.options.columns[x].editor.closeEditor(cell, save);
                    } else {
                        // Native functions
                        if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio' || obj.options.columns[x].type == 'hidden') {
                            // Do nothing
                        } else if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            var value = cell.children[0].dropdown.close(true);
                        } else if (obj.options.columns[x].type == 'calendar') {
                            var value = cell.children[0].calendar.close(true);
                        } else if (obj.options.columns[x].type == 'color') {
                            var value = cell.children[1].color.close(true);
                        } else if (obj.options.columns[x].type == 'image') {
                            var img = cell.children[0].children[0].children[0];
                            var value = img && img.tagName == 'IMG' ? img.src : '';
                        } else if (obj.options.columns[x].type == 'numeric') {
                            var value = cell.children[0].value;
                            if (value.substr(0, 1) != '=') {
                                if (value == '') {
                                    value = obj.options.columns[x].allowEmpty ? '' : 0;
                                }
                            }
                            cell.children[0].onblur = null;
                        } else {
                            var value = cell.children[0].value;
                            cell.children[0].onblur = null;
                        }
                    }

                    // Update values
                    var ignoreEvents = obj.ignoreEvents ? true : false;
                    var ignoreHistory = obj.ignoreHistory ? true : false;

                    // Ignore changes if the value is the same
                    if (obj.options.data[y][x] == value) {
                        // Disabled events and history
                        obj.ignoreEvents = true;
                        obj.ignoreHistory = true;
                    }

                    // Save value does not affect the table
                    if (obj.edition[1] == value) {
                        cell.innerHTML = obj.edition[1];
                    } else {
                        obj.setValue(cell, value);
                    }

                    // Restore events and history flag
                    obj.ignoreEvents = ignoreEvents;
                    obj.ignoreHistory = ignoreHistory;
                } else {
                    if (obj.options.columns[x].editor) {
                        // Custom editor
                        obj.options.columns[x].editor.closeEditor(cell, save);
                    } else {
                        if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            cell.children[0].dropdown.close(false);
                        } else if (obj.options.columns[x].type == 'calendar') {
                            cell.children[0].calendar.close(false);
                        } else if (obj.options.columns[x].type == 'color') {
                            cell.children[1].color.close(false);
                        } else {
                            cell.children[0].onblur = null;
                        }
                    }

                    // Restore value
                    cell.innerHTML = obj.edition[1];
                }

                // Remove editor class
                cell.classList.remove('editor');

                // Finish edition
                obj.edition = null;

                // On edition end
                if (!obj.ignoreEvents) {
                    if (typeof (obj.options.oneditionend) == 'function') {
                        obj.options.oneditionend(el, cell, x, y, value);
                    }
                }
            },

                /**
                 * Get the value from a cell
                 *
                 * @param object cell
                 * @return string value
                 */
                obj.getValue = function (cell, processedValue) {
                    if (typeof (cell) == 'object') {
                        var x = cell.getAttribute('data-x');
                        var y = cell.getAttribute('data-y');
                    } else {
                        cell = jexcel.getIdFromColumnName(cell, true);
                        var x = cell[0];
                        var y = cell[1];
                    }

                    var value = null;

                    if (x != null && y != null) {
                        if (processedValue || obj.options.copyCompatibility == true) {
                            if (obj.records[y] && obj.records[y][x]) {
                                value = obj.records[y][x].innerHTML;
                            }
                        } else {
                            if (obj.options.data[y] && obj.options.data[y][x]) {
                                value = obj.options.data[y][x];
                            }
                        }
                    }

                    return value;
                }

            /**
             * Get the value from a coords
             *
             * @param int x
             * @param int y
             * @return string value
             */
            obj.getValueFromCoords = function (x, y, processedValue) {
                var value = null;

                if (x != null && y != null) {
                    if (processedValue || obj.options.copyCompatibility == true) {
                        if (obj.records[y] && obj.records[y][x]) {
                            value = obj.records[y][x].innerHTML;
                        }
                    } else {
                        if (obj.options.data[y] && obj.options.data[y][x]) {
                            value = obj.options.data[y][x];
                        }
                    }
                }

                return value;
            }

            /**
             * Set a cell value
             *
             * @param mixed cell destination cell
             * @param string value value
             * @return void
             */
            obj.setValue = function (cell, value, force) {
                var records = [];

                if (typeof (cell) == 'string') {
                    var columnId = jexcel.getIdFromColumnName(cell, true);
                    var x = columnId[0];
                    var y = columnId[1];

                    // Update cell
                    records.push(obj.updateCell(x, y, value, force));
                } else {
                    var x = null;
                    var y = null;
                    if (cell.getAttribute) {
                        var x = cell.getAttribute('data-x');
                        var y = cell.getAttribute('data-y');
                    }

                    // Update cell
                    if (x && y) {
                        records.push(obj.updateCell(x, y, value, force));
                    } else {
                        var keys = Object.keys(cell);
                        if (keys.length > 0) {
                            for (var i = 0; i < keys.length; i++) {
                                var x = cell[i].getAttribute('data-x');
                                var y = cell[i].getAttribute('data-y');

                                // Update cell
                                if (x && y) {
                                    records.push(obj.updateCell(x, y, value, force));
                                }
                            }
                        }
                    }
                }

                // Update all formulas in the chain
                obj.updateFormulaChain(x, y, records);

                // Update history
                obj.setHistory({
                    action: 'setValue',
                    records: records,
                    selection: obj.selectedCell,
                });

                // Update table with custom configurations if applicable
                obj.updateTable();
            }

            /**
             * Set a cell value based on coordinates
             *
             * @param int x destination cell
             * @param int y destination cell
             * @param string value
             * @return void
             */
            obj.setValueFromCoords = function (x, y, value, force) {
                var records = [];
                records.push(obj.updateCell(x, y, value, force));

                // Update all formulas in the chain
                obj.updateFormulaChain(x, y, records);

                // Update history
                obj.setHistory({
                    action: 'setValue',
                    records: records,
                    selection: obj.selectedCell,
                });

                // Update table with custom configurations if applicable
                obj.updateTable();
            }

            /**
             * Toogle
             */
            obj.setCheckRadioValue = function () {
                var records = [];
                var keys = Object.keys(obj.highlighted);
                for (var i = 0; i < keys.length; i++) {
                    var x = obj.highlighted[i].getAttribute('data-x');
                    var y = obj.highlighted[i].getAttribute('data-y');

                    if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio') {
                        // Update cell
                        records.push(obj.updateCell(x, y, !obj.options.data[y][x]));
                    }
                }

                if (records.length) {
                    // Update history
                    obj.setHistory({
                        action: 'setValue',
                        records: records,
                        selection: obj.selectedCell,
                    });
                }
            }

            /**
             * Update cell content
             *
             * @param object cell
             * @return void
             */
            obj.updateCell = function (x, y, value, force) {
                // Changing value depending on the column type
                if (obj.records[y][x].classList.contains('readonly') == true && !force) {
                    // Do nothing
                } else {
                    // On change
                    if (!obj.ignoreEvents) {
                        if (typeof (obj.options.onbeforechange) == 'function') {
                            // Overwrite a value
                            var val = obj.options.onbeforechange(el, obj.records[y][x], x, y, value);

                            // If you return something this will overwrite the value
                            if (val != 'undefined') {
                                value = val;
                            }
                        }
                    }

                    // History format
                    var record = {
                        col: x,
                        row: y,
                        newValue: value,
                        oldValue: obj.options.data[y][x],
                    }

                    if (obj.options.columns[x].editor) {
                        // Update data and cell
                        obj.options.data[y][x] = value;
                        obj.options.columns[x].editor.setValue(obj.records[y][x], value, force);
                    } else {
                        // Native functions
                        if (obj.options.columns[x].type == 'checkbox' || obj.options.columns[x].type == 'radio') {
                            // Unchecked all options
                            if (obj.options.columns[x].type == 'radio') {
                                for (var j = 0; j < obj.options.data.length; j++) {
                                    obj.options.data[j][x] = false;
                                }
                            }

                            // Update data and cell
                            obj.records[y][x].children[0].checked = (value == 1 || value == true || value == 'true') ? true : false;
                            obj.options.data[y][x] = obj.records[y][x].children[0].checked;
                        } else if (obj.options.columns[x].type == 'dropdown' || obj.options.columns[x].type == 'autocomplete') {
                            // Update data and cell
                            obj.options.data[y][x] = value;
                            obj.records[y][x].innerHTML = obj.getDropDownValue(x, value);
                        } else if (obj.options.columns[x].type == 'calendar') {
                            // Update calendar
                            var formatted = jSuites.calendar.extractDateFromString(value, obj.options.columns[x].options.format);
                            // Update data and cell
                            obj.options.data[y][x] = value;
                            obj.records[y][x].innerHTML = jSuites.calendar.getDateString(formatted ? formatted : value, obj.options.columns[x].options.format);
                        } else if (obj.options.columns[x].type == 'color') {
                            // Update color
                            obj.options.data[y][x] = value;
                            // Render
                            if (obj.options.columns[x].render == 'square') {
                                var color = document.createElement('div');
                                color.className = 'color';
                                color.style.backgroundColor = value;
                                obj.records[y][x].innerHTML = '';
                                obj.records[y][x].appendChild(color);
                            } else {
                                obj.records[y][x].style.color = value;
                                obj.records[y][x].innerHTML = value;
                            }
                        } else if (obj.options.columns[x].type == 'image') {
                            value = '' + value;
                            obj.options.data[y][x] = value;
                            obj.records[y][x].innerHTML = '';
                            if (value && value.substr(0, 10) == 'data:image') {
                                var img = document.createElement('img');
                                img.src = value;
                                obj.records[y][x].appendChild(img);
                            }
                        } else {
                            // Update data and cell
                            if (obj.options.columns[x].autoCasting != false) {
                                obj.options.data[y][x] = (value && Number(value) == value) ? Number(value) : value;
                            } else {
                                obj.options.data[y][x] = value;
                            }
                            // Label
                            if (('' + value).substr(0, 1) == '=') {
                                value = obj.executeFormula(value, x, y);
                            }
                            if (obj.options.columns[x].mask) {
                                var decimal = obj.options.columns[x].decimal || '.';
                                value = '' + jSuites.mask.run(value, obj.options.columns[x].mask, decimal);
                            }
                            obj.records[y][x].innerHTML = value;

                            // Handle big text inside a cell
                            if (obj.records[y][x].innerHTML.length > 200) {
                                obj.records[y][x].style.whiteSpace = 'pre-wrap';
                            } else {
                                if (obj.options.wordWrap == false && obj.options.columns[x].wordWrap == false) {
                                    obj.records[y][x].style.whiteSpace = '';
                                }
                            }
                        }
                    }

                    // Overflow
                    if (x > 0) {
                        if (obj.options.data[y][x] || (obj.options.columns[x].type != 'text' && obj.options.columns[x].type != 'number')) {
                            obj.records[y][x - 1].style.overflow = 'hidden';
                        } else {
                            obj.records[y][x - 1].style.overflow = '';
                        }
                    }

                    // On change
                    if (!obj.ignoreEvents) {
                        if (typeof (obj.options.onchange) == 'function') {
                            obj.options.onchange(el, obj.records[y][x], x, y, value);
                        }
                    }
                }

                return record;
            }

            /**
             * Helper function to copy data using the corner icon
             */
            obj.copyData = function (o, d) {
                // Get data from all selected cells
                var data = obj.getData(true);

                // Selected cells
                var t0 = obj.selectedContainer[1];
                var t1 = obj.selectedContainer[3];

                // Cells
                var x1 = parseInt(o.getAttribute('data-x'));
                var y1 = parseInt(o.getAttribute('data-y'));
                var x2 = parseInt(d.getAttribute('data-x'));
                var y2 = parseInt(d.getAttribute('data-y'));

                // Records
                var records = [];
                var recordsChain = [];
                var lineNumber = 1;
                var breakControl = false;

                // Copy data procedure
                var posx = 0;
                var posy = 0;

                for (var j = y1; j <= y2; j++) {
                    if (obj.rows[j].style.display == 'none') {
                        continue;
                    }

                    // Controls
                    if (data[posy] == undefined) {
                        posy = 0;
                    }
                    posx = 0;

                    // Data columns
                    for (var i = x1; i <= x2; i++) {
                        // Update non-readonly
                        if (obj.records[j][i] && !obj.records[j][i].classList.contains('readonly') && obj.records[j][i].style.display != 'none' && breakControl == false) {
                            // Stop if contains value
                            if (!obj.selection.length) {
                                if (obj.options.data[j][i]) {
                                    breakControl = true;
                                    continue;
                                }
                            }

                            // Column
                            if (data[posy] == undefined) {
                                posx = 0;
                            } else if (data[posy][posx] == undefined) {
                                posx = 0;
                            } else {
                                var value = data[posy][posx];
                            }

                            if (value && t0 == t1) {
                                if (obj.options.columns[i].type == 'text' || obj.options.columns[i].type == 'number') {
                                    if (('' + value).substr(0, 1) == '=') {
                                        var tokens = value.match(/([A-Z]+[0-9]+)/g);

                                        if (tokens) {
                                            var affectedTokens = [];
                                            for (var index = 0; index < tokens.length; index++) {
                                                var position = jexcel.getIdFromColumnName(tokens[index], 1);
                                                position[1] += lineNumber;
                                                var token = jexcel.getColumnNameFromId([position[0], position[1]]);

                                                if (token != tokens[index]) {
                                                    affectedTokens[tokens[index]] = token;
                                                }
                                            }
                                            // Update formula
                                            if (affectedTokens) {
                                                value = obj.updateFormula(value, affectedTokens)
                                            }
                                        }
                                    } else {
                                        if (value == Number(value)) {
                                            value = Number(value) + lineNumber;
                                        }
                                    }
                                } else if (obj.options.columns[i].type == 'calendar') {
                                    var date = new Date(value);
                                    date.setDate(date.getDate() + lineNumber);
                                    value = date.getFullYear() + '-' + parseInt(date.getMonth() + 1) + '-' + date.getDate() + ' ' + date.getHours() + ':' + date.getMinutes() + ':00';
                                }
                            }

                            records.push(obj.updateCell(i, j, value));

                            // Update formulas chain
                            if (('' + value).substr(0, 1) == '=') {
                                recordsChain[i + ',' + j] = true;
                            }
                        }
                        posx++;
                    }
                    posy++;
                    lineNumber++;
                }

                // Update all formulas in the chain
                var keys = Object.keys(recordsChain);
                for (var i = 0; i < keys.length; i++) {
                    var k = keys[i].split(',');
                    obj.updateFormulaChain(k[0], k[1], records);
                }

                // Update history
                obj.setHistory({
                    action: 'setValue',
                    records: records,
                    selection: obj.selectedCell,
                });

                // Update table with custom configuration if applicable
                obj.updateTable();
            }

            /**
             * Refresh current selection
             */
            obj.refreshSelection = function () {
                if (obj.selectedCell) {
                    obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                }
            }

            /**
             * Move coords to A1 in case ovelaps with an excluded cell
             */
            obj.conditionalSelectionUpdate = function (type, o, d) {
                if (type == 1) {
                    if (obj.selectedCell && ((o >= obj.selectedCell[1] && o <= obj.selectedCell[3]) || (d >= obj.selectedCell[1] && d <= obj.selectedCell[3]))) {
                        obj.resetSelection();
                        return;
                    }
                } else {
                    if (obj.selectedCell && ((o >= obj.selectedCell[0] && o <= obj.selectedCell[2]) || (d >= obj.selectedCell[0] && d <= obj.selectedCell[2]))) {
                        obj.resetSelection();
                        return;
                    }
                }
            }

            /**
             * Clear table selection
             */
            obj.resetSelection = function (blur) {
                // Remove style
                if (!obj.highlighted.length) {
                    var previousStatus = 0;
                } else {
                    var previousStatus = 1;

                    for (var i = 0; i < obj.highlighted.length; i++) {
                        obj.highlighted[i].classList.remove('highlight');
                        obj.highlighted[i].classList.remove('highlight-left');
                        obj.highlighted[i].classList.remove('highlight-right');
                        obj.highlighted[i].classList.remove('highlight-top');
                        obj.highlighted[i].classList.remove('highlight-bottom');
                        obj.highlighted[i].classList.remove('highlight-selected');

                        var px = parseInt(obj.highlighted[i].getAttribute('data-x'));
                        var py = parseInt(obj.highlighted[i].getAttribute('data-y'));

                        // Check for merged cells
                        if (obj.highlighted[i].getAttribute('data-merged')) {
                            var colspan = parseInt(obj.highlighted[i].getAttribute('colspan'));
                            var rowspan = parseInt(obj.highlighted[i].getAttribute('rowspan'));
                            var ux = colspan > 0 ? px + (colspan - 1) : px;
                            var uy = rowspan > 0 ? py + (rowspan - 1) : py;
                        } else {
                            var ux = px;
                            var uy = py;
                        }

                        // Remove selected from headers
                        for (var j = px; j <= ux; j++) {
                            if (obj.headers[j]) {
                                obj.headers[j].classList.remove('selected');
                            }
                        }

                        // Remove selected from rows
                        for (var j = py; j <= uy; j++) {
                            if (obj.rows[j]) {
                                obj.rows[j].classList.remove('selected');
                            }
                        }
                    }
                }

                // Reset highlighed cells
                obj.highlighted = [];

                // Reset
                obj.selectedCell = null;

                // Hide corner
                obj.corner.style.top = '-2000px';
                obj.corner.style.left = '-2000px';

                if (obj.ignoreEvents != true && blur == true) {
                    if (obj.options.onblur) {
                        if (typeof (obj.options.onblur) == 'function') {
                            if (previousStatus == 1) {
                                obj.options.onblur(el);
                            }
                        }
                    }
                }

                return previousStatus;
            }

            /**
             * Update selection based on two cells
             */
            obj.updateSelection = function (el1, el2, origin) {
                var x1 = el1.getAttribute('data-x');
                var y1 = el1.getAttribute('data-y');
                if (el2) {
                    var x2 = el2.getAttribute('data-x');
                    var y2 = el2.getAttribute('data-y');
                } else {
                    var x2 = x1;
                    var y2 = y1;
                }

                obj.updateSelectionFromCoords(x1, y1, x2, y2, origin);
            }

            /**
             * Update selection from coords
             */
            obj.updateSelectionFromCoords = function (x1, y1, x2, y2, origin) {
                // Reset Selection
                var updated = null;
                var previousState = obj.resetSelection();

                // Same element
                if (x2 == null) {
                    x2 = x1;
                }
                if (y2 == null) {
                    y2 = y1;
                }

                // Selection must be within the existing data
                if (x1 >= obj.headers.length) {
                    x1 = obj.headers.length - 1;
                }
                if (y1 >= obj.rows.length) {
                    y1 = obj.rows.length - 1;
                }
                if (x2 >= obj.headers.length) {
                    x2 = obj.headers.length - 1;
                }
                if (y2 >= obj.rows.length) {
                    y2 = obj.rows.length - 1;
                }

                // Keep selected cell
                obj.selectedCell = [x1, y1, x2, y2];

                // Select cells
                if (x1 != null) {
                    // Add selected cell
                    obj.records[y1][x1].classList.add('highlight-selected')

                    // Origin & Destination
                    if (parseInt(x1) < parseInt(x2)) {
                        var px = parseInt(x1);
                        var ux = parseInt(x2);
                    } else {
                        var px = parseInt(x2);
                        var ux = parseInt(x1);
                    }

                    if (parseInt(y1) < parseInt(y2)) {
                        var py = parseInt(y1);
                        var uy = parseInt(y2);
                    } else {
                        var py = parseInt(y2);
                        var uy = parseInt(y1);
                    }

                    // Verify merged columns
                    for (var i = px; i <= ux; i++) {
                        for (var j = py; j <= uy; j++) {
                            if (obj.records[j][i].getAttribute('data-merged')) {
                                var x = parseInt(obj.records[j][i].getAttribute('data-x'));
                                var y = parseInt(obj.records[j][i].getAttribute('data-y'));
                                var colspan = parseInt(obj.records[j][i].getAttribute('colspan'));
                                var rowspan = parseInt(obj.records[j][i].getAttribute('rowspan'));

                                if (colspan > 1) {
                                    if (x < px) {
                                        px = x;
                                    }
                                    if (x + colspan > ux) {
                                        ux = x + colspan - 1;
                                    }
                                }

                                if (rowspan) {
                                    if (y < py) {
                                        py = y;

                                    }
                                    if (y + rowspan > uy) {
                                        uy = y + rowspan - 1;
                                    }
                                }
                            }
                        }
                    }

                    // Limits
                    var borderLeft = null;
                    var borderRight = null;
                    var borderTop = null;
                    var borderBottom = null;

                    // Vertical limits
                    for (var j = py; j <= uy; j++) {
                        if (obj.rows[j].style.display != 'none') {
                            if (borderTop == null) {
                                borderTop = j;
                            }
                            borderBottom = j;
                        }
                    }

                    // Redefining styles
                    for (var i = px; i <= ux; i++) {
                        for (var j = py; j <= uy; j++) {
                            if (obj.rows[j].style.display != 'none' && obj.records[j][i].style.display != 'none') {
                                obj.records[j][i].classList.add('highlight');
                                obj.highlighted.push(obj.records[j][i]);
                            }
                        }

                        // Horizontal limits
                        if (obj.options.columns[i].type != 'hidden') {
                            if (borderLeft == null) {
                                borderLeft = i;
                            }
                            borderRight = i;
                        }
                    }

                    // Create borders
                    if (!borderLeft) {
                        borderLeft = 0;
                    }
                    if (!borderRight) {
                        borderRight = 0;
                    }
                    for (var i = borderLeft; i <= borderRight; i++) {
                        if (obj.options.columns[i].type != 'hidden') {
                            // Top border
                            obj.records[borderTop][i].classList.add('highlight-top');
                            // Bottom border
                            obj.records[borderBottom][i].classList.add('highlight-bottom');
                            // Add selected from headers
                            obj.headers[i].classList.add('selected');
                        }
                    }

                    for (var j = borderTop; j <= borderBottom; j++) {
                        if (obj.rows[j].style.display != 'none') {
                            // Left border
                            obj.records[j][borderLeft].classList.add('highlight-left');
                            // Right border
                            obj.records[j][borderRight].classList.add('highlight-right');
                            // Add selected from rows
                            obj.rows[j].classList.add('selected');
                        }
                    }

                    obj.selectedContainer = [borderLeft, borderTop, borderRight, borderBottom];
                }

                // Handle events
                if (obj.ignoreEvents != true) {
                    if (obj.options.onfocus) {
                        if (typeof (obj.options.onfocus) == 'function') {
                            if (previousState == 0) {
                                obj.options.onfocus(el);
                            }
                        }
                    }

                    if (typeof (obj.options.onselection) == 'function') {
                        obj.options.onselection(el, borderLeft, borderTop, borderRight, borderBottom, origin);
                    }
                }

                // Find corner cell
                obj.updateCornerPosition();
            }

            /**
             * Remove copy selection
             *
             * @return void
             */
            obj.removeCopySelection = function () {
                // Remove current selection
                for (var i = 0; i < obj.selection.length; i++) {
                    obj.selection[i].classList.remove('selection');
                    obj.selection[i].classList.remove('selection-left');
                    obj.selection[i].classList.remove('selection-right');
                    obj.selection[i].classList.remove('selection-top');
                    obj.selection[i].classList.remove('selection-bottom');
                }

                obj.selection = [];
            }

            /**
             * Update copy selection
             *
             * @param int x, y
             * @return void
             */
            obj.updateCopySelection = function (x3, y3) {
                // Remove selection
                obj.removeCopySelection();

                // Get elements first and last
                var x1 = obj.selectedContainer[0];
                var y1 = obj.selectedContainer[1];
                var x2 = obj.selectedContainer[2];
                var y2 = obj.selectedContainer[3];

                if (x3 && y3) {
                    if (x3 - x2 > 0) {
                        var px = parseInt(x2) + 1;
                        var ux = parseInt(x3);
                    } else {
                        var px = parseInt(x3);
                        var ux = parseInt(x1) - 1;
                    }

                    if (y3 - y2 > 0) {
                        var py = parseInt(y2) + 1;
                        var uy = parseInt(y3);
                    } else {
                        var py = parseInt(y3);
                        var uy = parseInt(y1) - 1;
                    }

                    if (ux - px < uy - py) {
                        var px = parseInt(x1);
                        var ux = parseInt(x2);
                    } else {
                        var py = parseInt(y1);
                        var uy = parseInt(y2);
                    }

                    for (var j = py; j <= uy; j++) {
                        for (var i = px; i <= ux; i++) {
                            if (obj.records[j][i] && obj.rows[j].style.display != 'none' && obj.records[j][i].style.display != 'none') {
                                obj.records[j][i].classList.add('selection');
                                obj.records[py][i].classList.add('selection-top');
                                obj.records[uy][i].classList.add('selection-bottom');
                                obj.records[j][px].classList.add('selection-left');
                                obj.records[j][ux].classList.add('selection-right');

                                // Persist selected elements
                                obj.selection.push(obj.records[j][i]);
                            }
                        }
                    }
                }
            }

            /**
             * Update corner position
             *
             * @return void
             */
            obj.updateCornerPosition = function () {
                // If any selected cells
                if (!obj.highlighted.length) {
                    obj.corner.style.top = '-2000px';
                    obj.corner.style.left = '-2000px';
                } else {
                    // Get last cell
                    var last = obj.highlighted[obj.highlighted.length - 1];
                    var x1 = obj.content.getBoundingClientRect().left;
                    var y1 = obj.content.getBoundingClientRect().top;

                    var x2 = last.getBoundingClientRect().left;
                    var y2 = last.getBoundingClientRect().top;
                    var w2 = last.getBoundingClientRect().width;
                    var h2 = last.getBoundingClientRect().height;

                    var x = (x2 - x1) + obj.content.scrollLeft + w2 - 4;
                    var y = (y2 - y1) + obj.content.scrollTop + h2 - 4;

                    // Place the corner in the correct place
                    obj.corner.style.top = y + 'px';
                    obj.corner.style.left = x + 'px';
                }
            }

            /**
             *  Update scroll position based on the selection
             */
            obj.updateScroll = function (direction) {
                // jExcel Container information
                var x1 = obj.content.getBoundingClientRect().left;
                var y1 = obj.content.getBoundingClientRect().top;
                var w1 = obj.content.getBoundingClientRect().width;
                var h1 = obj.content.getBoundingClientRect().height;

                // Direction Left or Up
                var reference = obj.records[obj.selectedCell[3]][obj.selectedCell[2]];

                var x2 = reference.getBoundingClientRect().left;
                var y2 = reference.getBoundingClientRect().top;
                var w2 = reference.getBoundingClientRect().width;
                var h2 = reference.getBoundingClientRect().height;

                // Direction
                if (direction == 0 || direction == 1) {
                    var x = (x2 - x1) + obj.content.scrollLeft;
                    var y = (y2 - y1) + obj.content.scrollTop - 2;
                } else {
                    var x = (x2 - x1) + obj.content.scrollLeft + w2;
                    var y = (y2 - y1) + obj.content.scrollTop + h2;
                }

                // Top position check
                if (y > (obj.content.scrollTop + 30) && y < (obj.content.scrollTop + h1)) {
                    // In the viewport
                } else {
                    // Out of viewport
                    if (y < obj.content.scrollTop + 30) {
                        obj.content.scrollTop = y - h2;
                    } else {
                        obj.content.scrollTop = y - (h1 - 2);
                    }
                }

                // Left position check - TODO: change that to the bottom border of the element
                if (x > (obj.content.scrollLeft) && x < (obj.content.scrollLeft + w1)) {
                    // In the viewport
                } else {
                    // Out of viewport
                    if (x < obj.content.scrollLeft + 30) {
                        obj.content.scrollLeft = x;
                        if (obj.content.scrollLeft < 50) {
                            obj.content.scrollLeft = 0;
                        }
                    } else {
                        obj.content.scrollLeft = x - (w1 - 20);
                    }
                }
            }

            /**
             * Get the column width
             *
             * @param int column   column number (first column is: 0)
             * @return int current width
             */
            obj.getWidth = function (column) {
                if (!column) {
                    // Get all headers
                    var data = [];
                    for (var i = 0; i < obj.headers.length; i++) {
                        data.push(obj.options.columns[i].width);
                    }
                } else {
                    // In case the column is an object
                    if (typeof (column) == 'object') {
                        column = $(column).getAttribute('data-x');
                    }

                    data = obj.colgroup[column].getAttribute('width')
                }

                return data;
            }

            /**
             * Set the column width
             *
             * @param int column number (first column is: 0)
             * @param int new column width
             * @param int old column width
             */
            obj.setWidth = function (column, width, oldWidth) {
                if (width > 0) {
                    // In case the column is an object
                    if (typeof (column) == 'object') {
                        column = $(column).getAttribute('data-x');
                    }

                    // Oldwidth
                    if (!oldWidth) {
                        obj.colgroup[column].getAttribute('width');
                    }

                    // Set width
                    obj.colgroup[column].setAttribute('width', width);
                    obj.options.columns[column].width = width;

                    // Keeping history of changes
                    obj.setHistory({
                        action: 'setWidth',
                        column: column,
                        oldValue: oldWidth,
                        newValue: width,
                    });

                    // On resize column
                    if (obj.ignoreEvents != true) {
                        if (typeof (obj.options.onresizecolumn) == 'function') {
                            obj.options.onresizecolumn(el, column, width, oldWidth);
                        }
                    }

                    // Update corner position
                    obj.updateCornerPosition();
                }
            }

            /**
             * Set the row height
             *
             * @param row - row number (first row is: 0)
             * @param height - new row height
             * @param oldHeight - old row height
             */
            obj.setHeight = function (row, height, oldHeight) {
                if (height > 0) {
                    // In case the column is an object
                    if (typeof (row) == 'object') {
                        column = $(row).getAttribute('data-y');
                    }

                    // Oldwidth
                    if (!oldHeight) {
                        obj.rows[row].getAttribute('height');
                    }

                    // Set width
                    obj.rows[row].setAttribute('height', height);

                    // Keep options updated
                    if (!obj.options.rows[row]) {
                        obj.options.rows[row] = {};
                    }
                    obj.options.rows[row].height = height;

                    // Keeping history of changes
                    obj.setHistory({
                        action: 'setHeight',
                        row: row,
                        oldValue: oldHeight,
                        newValue: height,
                    });

                    // On resize column
                    if (obj.ignoreEvents != true) {
                        if (typeof (obj.options.onresizerow) == 'function') {
                            obj.options.onresizerow(el, row, height, oldHeight);
                        }
                    }

                    // Update corner position
                    obj.updateCornerPosition();
                }
            }

            /**
             * Get the row height
             *
             * @param row - row number (first column is: 0)
             * @return height - current row height
             */
            obj.getHeight = function (row) {
                if (!row) {
                } else {
                    // In case the column is an object
                    if (typeof (row) == 'object') {
                        row = $(row).getAttribute('data-y');
                    }

                    data = obj.rows[row].getAttribute('height')
                }

                return data;
            }

            /**
             * Get the column title
             *
             * @param column - column number (first column is: 0)
             * @param title - new column title
             */
            obj.getHeader = function (column) {
                return obj.headers[column].innerText;
            }

            /**
             * Set the column title
             *
             * @param column - column number (first column is: 0)
             * @param title - new column title
             */
            obj.setHeader = function (column, newValue) {
                if (obj.headers[column]) {
                    var oldValue = obj.headers[column].innerText;

                    if (!newValue) {
                        newValue = prompt(obj.options.text.columnName, oldValue)
                    }

                    if (newValue) {
                        obj.headers[column].innerHTML = newValue;
                    }

                    obj.setHistory({
                        action: 'setHeader',
                        column: column,
                        oldValue: oldValue,
                        newValue: newValue
                    });

                    // On change
                    if (!obj.ignoreEvents) {
                        if (typeof (obj.options.onchangeheader) == 'function') {
                            obj.options.onchangeheader(el, column, oldValue, newValue);
                        }
                    }

                }
            }

            /**
             * Get the headers
             *
             * @param asArray
             * @return mixed
             */
            obj.getHeaders = function (asArray) {
                var title = [];

                for (var i = 0; i < obj.headers.length; i++) {
                    title.push(obj.getHeader(i));
                }

                return asArray ? title : title.join(',');
            }

            /**
             * Get meta information from cell(s)
             *
             * @return integer
             */
            obj.getMeta = function (cell, key) {
                if (!cell) {
                    return obj.options.meta;
                } else {
                    return key ? obj.options.meta[cell][key] : obj.options.meta[cell];
                }
            }

            /**
             * Set meta information to cell(s)
             *
             * @return integer
             */
            obj.setMeta = function (o, k, v) {
                if (!obj.options.meta) {
                    obj.options.meta = {}
                }

                if (k && v) {
                    // Set data value
                    if (!obj.options.meta[o]) {
                        obj.options.meta[o] = {};
                    }
                    obj.options.meta[o][k] = v;
                } else {
                    // Apply that for all cells
                    var keys = Object.keys(o);
                    for (var i = 0; i < keys.length; i++) {
                        if (!obj.options.meta[keys[i]]) {
                            obj.options.meta[keys[i]] = {};
                        }

                        var prop = Object.keys(o[keys[i]]);
                        for (var j = 0; j < prop.length; j++) {
                            obj.options.meta[keys[i]][prop[j]] = o[keys[i]][prop[j]];
                        }
                    }
                }

                if (obj.ignoreEvents != true) {
                    if (typeof (obj.options.onchangemeta) == 'function') {
                        obj.options.onchangemeta(el, o, k, v);
                    }
                }
            }

            /**
             * Get style information from cell(s)
             *
             * @return integer
             */
            obj.getStyle = function (cell, key) {
                // Cell
                if (!cell) {
                    // Control vars
                    var data = {};

                    // Column and row length
                    var x = obj.options.data[0].length;
                    var y = obj.options.data.length;

                    // Go through the columns to get the data
                    for (var j = 0; j < y; j++) {
                        for (var i = 0; i < x; i++) {
                            // Value
                            var v = key ? obj.records[j][i].style[key] : obj.records[j][i].getAttribute('style');

                            // Any meta data for this column?
                            if (v) {
                                // Column name
                                var k = jexcel.getColumnNameFromId([i, j]);
                                // Value
                                data[k] = v;
                            }
                        }
                    }

                    return data;
                } else {
                    cell = jexcel.getIdFromColumnName(cell, true);

                    return key ? obj.records[cell[1]][cell[0]].style[key] : obj.records[cell[1]][cell[0]].getAttribute('style');
                }
            },

                obj.resetStyle = function (o, ignoreHistoryAndEvents) {
                    var keys = Object.keys(o);
                    for (var i = 0; i < keys.length; i++) {
                        // Position
                        var cell = jexcel.getIdFromColumnName(keys[i], true);
                        if (obj.records[cell[1]] && obj.records[cell[1]][cell[0]]) {
                            obj.records[cell[1]][cell[0]].setAttribute('style', '');
                        }
                    }
                    obj.setStyle(o, null, null, null, ignoreHistoryAndEvents);
                }

            /**
             * Set meta information to cell(s)
             *
             * @return integer
             */
            obj.setStyle = function (o, k, v, force, ignoreHistoryAndEvents) {
                var newValue = {};
                var oldValue = {};

                // Apply style
                var applyStyle = function (cellId, key, value) {
                    // Position
                    var cell = jexcel.getIdFromColumnName(cellId, true);

                    if (obj.records[cell[1]] && obj.records[cell[1]][cell[0]]) {
                        // Current value
                        var currentValue = obj.records[cell[1]][cell[0]].style[key];

                        // Change layout
                        if (currentValue == value && !force) {
                            value = '';
                            obj.records[cell[1]][cell[0]].style[key] = '';
                        } else {
                            obj.records[cell[1]][cell[0]].style[key] = value;
                        }

                        // History
                        if (!oldValue[cellId]) {
                            oldValue[cellId] = [];
                        }
                        if (!newValue[cellId]) {
                            newValue[cellId] = [];
                        }

                        oldValue[cellId].push([key + ':' + currentValue]);
                        newValue[cellId].push([key + ':' + value]);
                    }
                }

                if (k && v) {
                    // Get object from string
                    if (typeof (o) == 'string') {
                        applyStyle(o, k, v);
                    } else {
                        // Avoid duplications
                        var oneApplication = [];
                        // Apply that for all cells
                        for (var i = 0; i < o.length; i++) {
                            var x = o[i].getAttribute('data-x');
                            var y = o[i].getAttribute('data-y');
                            var cellName = jexcel.getColumnNameFromId([x, y]);
                            // This happens when is a merged cell
                            if (!oneApplication[cellName]) {
                                applyStyle(cellName, k, v);
                                oneApplication[cellName] = true;
                            }
                        }
                    }
                } else {
                    var keys = Object.keys(o);
                    for (var i = 0; i < keys.length; i++) {
                        var style = o[keys[i]];
                        if (typeof (style) == 'string') {
                            style = style.split(';');
                        }
                        for (var j = 0; j < style.length; j++) {
                            if (typeof (style[j]) == 'string') {
                                style[j] = style[j].split(':');
                            }
                            // Apply value
                            if (style[j][0].trim()) {
                                applyStyle(keys[i], style[j][0].trim(), style[j][1]);
                            }
                        }
                    }
                }

                var keys = Object.keys(oldValue);
                for (var i = 0; i < keys.length; i++) {
                    oldValue[keys[i]] = oldValue[keys[i]].join(';');
                }
                var keys = Object.keys(newValue);
                for (var i = 0; i < keys.length; i++) {
                    newValue[keys[i]] = newValue[keys[i]].join(';');
                }

                if (!ignoreHistoryAndEvents) {
                    // Keeping history of changes
                    obj.setHistory({
                        action: 'setStyle',
                        oldValue: oldValue,
                        newValue: newValue,
                    });
                }

                if (obj.ignoreEvents != true) {
                    if (typeof (obj.options.onchangestyle) == 'function') {
                        obj.options.onchangestyle(el, o, k, v);
                    }
                }
            }

            /**
             * Get cell comments
             */
            obj.getComments = function (cell, withAuthor) {
                if (typeof (cell) == 'string') {
                    var cell = jexcel.getIdFromColumnName(cell, true);
                }

                if (withAuthor) {
                    return [obj.records[cell[1]][cell[0]].getAttribute('title'), obj.records[cell[1]][cell[0]].getAttribute('author')];
                } else {
                    return obj.records[cell[1]][cell[0]].getAttribute('title') || '';
                }
            }

            /**
             * Set cell comments
             */
            obj.setComments = function (cellId, comments, author) {
                if (typeof (cellId) == 'string') {
                    var cell = jexcel.getIdFromColumnName(cellId, true);
                } else {
                    var cell = cellId;
                }

                // Keep old value
                var title = obj.records[cell[1]][cell[0]].getAttribute('title');
                var author = obj.records[cell[1]][cell[0]].getAttribute('data-author');
                var oldValue = [title, author];

                // Set new values
                obj.records[cell[1]][cell[0]].setAttribute('title', comments ? comments : '');
                obj.records[cell[1]][cell[0]].setAttribute('data-author', author ? author : '');

                // Remove class if there is no comment
                if (comments) {
                    obj.records[cell[1]][cell[0]].classList.add('jexcel_comments');
                } else {
                    obj.records[cell[1]][cell[0]].classList.remove('jexcel_comments');
                }

                // Save history
                obj.setHistory({
                    action: 'setComments',
                    column: cellId,
                    newValue: [comments, author],
                    oldValue: oldValue,
                });
            }

            /**
             * Get table config information
             */
            obj.getConfig = function () {
                var options = obj.options;
                options.style = obj.getStyle();
                options.mergeCells = obj.getMerge();

                return options;
            }

            /**
             * Sort data and reload table
             */
            obj.orderBy = function (column, order) {
                if (column >= 0) {
                    // Merged cells
                    if (Object.keys(obj.options.mergeCells).length > 0) {
                        if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                            return false;
                        } else {
                            // Remove merged cells
                            obj.destroyMerged();
                        }
                    }

                    // Direction
                    if (order == null) {
                        order = obj.headers[column].classList.contains('arrow-down') ? 1 : 0;
                    } else {
                        order = order ? 1 : 0;
                    }

                    // Filter
                    Array.prototype.orderBy = function (p, o) {
                        return this.slice(0).sort(function (a, b) {
                            var valueA = Number(a[p]) == a[p] ? Number(a[p]) : a[p].toLowerCase();
                            var valueB = Number(b[p]) == b[p] ? Number(b[p]) : b[p].toLowerCase();

                            if (!o) {
                                return (valueA > valueB) ? 1 : (valueA < valueB) ? -1 : 0;
                            } else {
                                return (valueA > valueB) ? -1 : (valueA < valueB) ? 1 : 0;
                            }
                        });
                    }

                    // Test order
                    var temp = [];
                    if (obj.options.columns[column].type == 'calendar' ||
                        obj.options.columns[column].type == 'checkbox' ||
                        obj.options.columns[column].type == 'radio') {
                        for (var j = 0; j < obj.options.data.length; j++) {
                            temp[j] = [j, obj.options.data[j][column]];
                        }
                    } else {
                        for (var j = 0; j < obj.options.data.length; j++) {
                            temp[j] = [j, obj.records[j][column].innerHTML];
                        }
                    }
                    temp = temp.orderBy(1, order);

                    // Save history
                    var newValue = [];
                    for (var j = 0; j < temp.length; j++) {
                        newValue[j] = temp[j][0];
                    }

                    // Save history
                    obj.setHistory({
                        action: 'orderBy',
                        rows: newValue,
                        column: column,
                        order: order,
                    });

                    // Update order
                    obj.updateOrderArrow(column, order);
                    obj.updateOrder(newValue);

                    // On sort event
                    if (obj.ignoreEvents != true) {
                        if (typeof (obj.options.onsort) == 'function') {
                            obj.options.onsort(el, column, order);
                        }
                    }

                    return true;
                }
            }

            /**
             * Update order arrow
             */
            obj.updateOrderArrow = function (column, order) {
                // Remove order
                for (var i = 0; i < obj.headers.length; i++) {
                    obj.headers[i].classList.remove('arrow-up');
                    obj.headers[i].classList.remove('arrow-down');
                }

                // No order specified then toggle order
                if (order) {
                    obj.headers[column].classList.add('arrow-up');
                } else {
                    obj.headers[column].classList.add('arrow-down');
                }
            }

            /**
             * Update rows position
             */
            obj.updateOrder = function (rows) {
                // History
                var data = []
                for (var j = 0; j < rows.length; j++) {
                    data[j] = obj.options.data[rows[j]];
                }
                obj.options.data = data;

                var data = []
                for (var j = 0; j < rows.length; j++) {
                    data[j] = obj.records[rows[j]];
                }
                obj.records = data;

                var data = []
                for (var j = 0; j < rows.length; j++) {
                    data[j] = obj.rows[rows[j]];
                }
                obj.rows = data;

                // Update references
                obj.updateTableReferences();

                // Redo search
                if (obj.searchInput.value) {
                    obj.search(obj.searchInput.value);
                } else {
                    // Create page
                    obj.results = null;
                    obj.pageNumber = 0;

                    if (obj.options.pagination > 0) {
                        obj.page(0);
                    } else if (obj.options.lazyLoading == true) {
                        obj.loadPage(0);
                    } else {
                        for (var j = 0; j < obj.rows.length; j++) {
                            obj.tbody.appendChild(obj.rows[j]);
                        }
                    }
                }
            }

            /**
             * Move row
             *
             * @return void
             */
            obj.moveRow = function (o, d, ignoreDom) {
                if (Object.keys(obj.options.mergeCells).length > 0) {
                    if (obj.isRowMerged(d).length) {
                        if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                            return false;
                        } else {
                            obj.destroyMerged();
                        }
                    }
                }

                if (obj.options.search == true) {
                    if (obj.results && obj.results.length != obj.rows.length) {
                        if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                            obj.resetSearch();
                        } else {
                            return false;
                        }
                    }

                    obj.results = null;
                }

                if (!ignoreDom) {
                    if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[d]) >= 0) {
                        if (o > d) {
                            obj.tbody.insertBefore(obj.rows[o], obj.rows[d]);
                        } else {
                            obj.tbody.insertBefore(obj.rows[o], obj.rows[d].nextSibling);
                        }
                    } else {
                        obj.tbody.removeChild(obj.rows[o]);
                    }
                }

                // Place references in the correct position
                obj.rows.splice(d, 0, obj.rows.splice(o, 1)[0]);
                obj.records.splice(d, 0, obj.records.splice(o, 1)[0]);
                obj.options.data.splice(d, 0, obj.options.data.splice(o, 1)[0]);

                // Respect pagination
                if (obj.options.pagination > 0 && obj.tbody.children.length != obj.options.pagination) {
                    obj.page(obj.pageNumber);
                }

                // Keeping history of changes
                obj.setHistory({
                    action: 'moveRow',
                    oldValue: o,
                    newValue: d,
                });

                // Update table references
                obj.updateTableReferences();

                // Events
                if (obj.ignoreEvents != true) {
                    if (typeof (obj.options.onmoverow) == 'function') {
                        obj.options.onmoverow(el, o, d);
                    }
                }
            }

            /**
             * Insert a new row
             *
             * @param mixed - number of blank lines to be insert or a single array with the data of the new row
             * @param rowNumber
             * @param insertBefore
             * @return void
             */
            obj.insertRow = function (mixed, rowNumber, insertBefore) {
                // Configuration
                if (obj.options.allowInsertRow == true) {
                    // Records
                    var records = [];

                    // Data to be insert
                    var data = [];

                    // The insert could be lead by number of rows or the array of data
                    if (mixed > 0) {
                        var numOfRows = mixed;
                    } else {
                        var numOfRows = 1;

                        if (mixed) {
                            data = mixed;
                        }
                    }

                    // Direction
                    var insertBefore = insertBefore ? true : false;

                    // Current column number
                    var lastRow = obj.options.data.length - 1;

                    if (rowNumber == undefined || rowNumber >= parseInt(lastRow) || rowNumber < 0) {
                        rowNumber = lastRow;
                    }

                    // Onbeforeinsertrow
                    if (typeof (obj.options.onbeforeinsertrow) == 'function') {
                        if (!obj.options.onbeforeinsertrow(el, rowNumber, numOfRows, insertBefore)) {
                            console.log('onbeforeinsertrow returned false');

                            return false;
                        }
                    }

                    // Merged cells
                    if (Object.keys(obj.options.mergeCells).length > 0) {
                        if (obj.isRowMerged(rowNumber, insertBefore).length) {
                            if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                return false;
                            } else {
                                obj.destroyMerged();
                            }
                        }
                    }

                    // Clear any search
                    if (obj.options.search == true) {
                        if (obj.results && obj.results.length != obj.rows.length) {
                            if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                                obj.resetSearch();
                            } else {
                                return false;
                            }
                        }

                        obj.results = null;
                    }

                    // Insertbefore
                    var rowIndex = (!insertBefore) ? rowNumber + 1 : rowNumber;

                    // Keep the current data
                    var currentRecords = obj.records.splice(rowIndex);
                    var currentData = obj.options.data.splice(rowIndex);
                    var currentRows = obj.rows.splice(rowIndex);

                    // Adding lines
                    var rowRecords = [];
                    var rowData = [];
                    var rowNode = [];

                    for (var row = rowIndex; row < (numOfRows + rowIndex); row++) {
                        // Push data to the data container
                        obj.options.data[row] = [];
                        for (var col = 0; col < obj.options.columns.length; col++) {
                            obj.options.data[row][col] = data[col] ? data[col] : '';
                        }
                        // Create row
                        var tr = obj.createRow(row, obj.options.data[row]);
                        // Append node
                        if (!currentRows[0] || Array.prototype.indexOf.call(obj.tbody.children, currentRows[0]) >= 0) {
                            obj.tbody.insertBefore(tr, currentRows[0]);
                        }
                        // Record History
                        rowRecords.push(obj.records[row]);
                        rowData.push(obj.options.data[row]);
                        rowNode.push(tr);
                    }

                    // Copy the data back to the main data
                    Array.prototype.push.apply(obj.records, currentRecords);
                    Array.prototype.push.apply(obj.options.data, currentData);
                    Array.prototype.push.apply(obj.rows, currentRows);

                    // Respect pagination
                    if (obj.options.pagination > 0) {
                        obj.page(obj.pageNumber);
                    }

                    // Keep history
                    obj.setHistory({
                        action: 'insertRow',
                        rowNumber: rowNumber,
                        numOfRows: numOfRows,
                        insertBefore: insertBefore,
                        rowRecords: rowRecords,
                        rowData: rowData,
                        rowNode: rowNode,
                    });

                    // Remove table references
                    obj.updateTableReferences();

                    // Events
                    if (obj.ignoreEvents != true) {
                        if (typeof (obj.options.oninsertrow) == 'function') {
                            obj.options.oninsertrow(el, rowNumber, numOfRows, rowRecords, insertBefore);
                        }
                    }
                }
            }

            /**
             * Delete a row by number
             *
             * @param integer rowNumber - row number to be excluded
             * @param integer numOfRows - number of lines
             * @return void
             */
            obj.deleteRow = function (rowNumber, numOfRows) {
                // Global Configuration
                if (obj.options.allowDeleteRow == true) {
                    if (obj.options.data.length > 1) {
                        // Delete row definitions
                        if (rowNumber == undefined) {
                            var number = obj.getSelectedRows();

                            if (!number[0]) {
                                rowNumber = obj.options.data.length - 1;
                                numOfRows = 1;
                            } else {
                                rowNumber = parseInt(number[0].getAttribute('data-y'));
                                numOfRows = number.length;
                            }
                        }

                        // Last column
                        var lastRow = obj.options.data.length - 1;

                        if (rowNumber == undefined || rowNumber > lastRow || rowNumber < 0) {
                            rowNumber = lastRow;
                        }

                        if (!numOfRows) {
                            numOfRows = 1;
                        }

                        // Do not delete more than the number of recoreds
                        if (rowNumber + numOfRows >= obj.options.data.length) {
                            numOfRows = obj.options.data.length - rowNumber;
                        }

                        // Onbeforedeleterow
                        if (typeof (obj.options.onbeforedeleterow) == 'function') {
                            if (!obj.options.onbeforedeleterow(el, rowNumber, numOfRows)) {
                                console.log('onbeforedeleterow returned false');
                                return false;
                            }
                        }

                        if (parseInt(rowNumber) > -1) {
                            // Merged cells
                            var mergeExists = false;
                            if (Object.keys(obj.options.mergeCells).length > 0) {
                                for (var row = rowNumber; row < rowNumber + numOfRows; row++) {
                                    if (obj.isRowMerged(row, false).length) {
                                        mergeExists = true;
                                    }
                                }
                            }
                            if (mergeExists) {
                                if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                    return false;
                                } else {
                                    obj.destroyMerged();
                                }
                            }

                            // Clear any search
                            if (obj.options.search == true) {
                                if (obj.results && obj.results.length != obj.rows.length) {
                                    if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                                        obj.resetSearch();
                                    } else {
                                        return false;
                                    }
                                }

                                obj.results = null;
                            }

                            // Remove node
                            for (var row = rowNumber; row < rowNumber + numOfRows; row++) {
                                if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[row]) >= 0) {
                                    obj.rows[row].className = '';
                                    obj.rows[row].remove();
                                }
                            }

                            // Remove data
                            var rowRecords = obj.records.splice(rowNumber, numOfRows);
                            var rowData = obj.options.data.splice(rowNumber, numOfRows);
                            var rowNode = obj.rows.splice(rowNumber, numOfRows);

                            // Respect pagination
                            if (obj.options.pagination > 0 && obj.tbody.children.length != obj.options.pagination) {
                                obj.page(obj.pageNumber);
                            }

                            // Remove selection
                            obj.conditionalSelectionUpdate(1, rowNumber, (rowNumber + numOfRows) - 1);

                            // Keep history
                            obj.setHistory({
                                action: 'deleteRow',
                                rowNumber: rowNumber,
                                numOfRows: numOfRows,
                                insertBefore: 1,
                                rowRecords: rowRecords,
                                rowData: rowData,
                                rowNode: rowNode
                            });

                            // Remove table references
                            obj.updateTableReferences();

                            // Events
                            if (obj.ignoreEvents != true) {
                                if (typeof (obj.options.ondeleterow) == 'function') {
                                    obj.options.ondeleterow(el, rowNumber, numOfRows, rowRecords);
                                }
                            }
                        }
                    } else {
                        console.error('JEXCEL. It is not possible to delete the last row');
                    }
                }
            }


            /**
             * Move column
             *
             * @return void
             */
            obj.moveColumn = function (o, d) {
                if (Object.keys(obj.options.mergeCells).length > 0) {
                    if (obj.isColMerged(d).length) {
                        if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                            return false;
                        } else {
                            obj.destroyMerged();
                        }
                    }
                }

                var o = parseInt(o);
                var d = parseInt(d);

                if (o > d) {
                    obj.headerContainer.insertBefore(obj.headers[o], obj.headers[d]);
                    obj.colgroupContainer.insertBefore(obj.colgroup[o], obj.colgroup[d]);

                    for (var j = 0; j < obj.rows.length; j++) {
                        obj.rows[j].insertBefore(obj.records[j][o], obj.records[j][d]);
                    }
                } else {
                    obj.headerContainer.insertBefore(obj.headers[o], obj.headers[d].nextSibling);
                    obj.colgroupContainer.insertBefore(obj.colgroup[o], obj.colgroup[d].nextSibling);

                    for (var j = 0; j < obj.rows.length; j++) {
                        obj.rows[j].insertBefore(obj.records[j][o], obj.records[j][d].nextSibling);
                    }
                }

                obj.options.columns.splice(d, 0, obj.options.columns.splice(o, 1)[0]);
                obj.headers.splice(d, 0, obj.headers.splice(o, 1)[0]);
                obj.colgroup.splice(d, 0, obj.colgroup.splice(o, 1)[0]);

                for (var j = 0; j < obj.rows.length; j++) {
                    obj.options.data[j].splice(d, 0, obj.options.data[j].splice(o, 1)[0]);
                    obj.records[j].splice(d, 0, obj.records[j].splice(o, 1)[0]);
                }

                // Keeping history of changes
                obj.setHistory({
                    action: 'moveColumn',
                    oldValue: o,
                    newValue: d,
                });

                // Update table references
                obj.updateTableReferences();

                // Events
                if (obj.ignoreEvents != true) {
                    if (typeof (obj.options.onmovecolumn) == 'function') {
                        obj.options.onmovecolumn(el, o, d);
                    }
                }
            }


            /**
             * Insert a new column
             *
             * @param mixed - num of columns to be added or data to be added in one single column
             * @param int columnNumber - number of columns to be created
             * @param bool insertBefore
             * @param object properties - column properties
             * @return void
             */
            obj.insertColumn = function (mixed, columnNumber, insertBefore, properties) {
                // Configuration
                if (obj.options.allowInsertColumn == true) {
                    // Records
                    var records = [];

                    // Data to be insert
                    var data = [];

                    // The insert could be lead by number of rows or the array of data
                    if (mixed > 0) {
                        var numOfColumns = mixed;
                    } else {
                        var numOfColumns = 1;

                        if (mixed) {
                            data = mixed;
                        }
                    }

                    // Direction
                    var insertBefore = insertBefore ? true : false;

                    // Current column number
                    var lastColumn = obj.options.columns.length - 1;

                    // Confirm position
                    if (columnNumber == undefined || columnNumber >= parseInt(lastColumn) || columnNumber < 0) {
                        columnNumber = lastColumn;
                    }

                    // Onbeforeinsertcolumn
                    if (typeof (obj.options.onbeforeinsertcolumn) == 'function') {
                        if (!obj.options.onbeforeinsertcolumn(el, columnNumber, numOfColumns, insertBefore)) {
                            console.log('onbeforeinsertcolumn returned false');

                            return false;
                        }
                    }

                    // Merged cells
                    if (Object.keys(obj.options.mergeCells).length > 0) {
                        if (obj.isColMerged(columnNumber, insertBefore).length) {
                            if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                return false;
                            } else {
                                obj.destroyMerged();
                            }
                        }
                    }

                    // Create default properties
                    if (!properties) {
                        properties = [];
                    }
                    if (!properties.columns) {
                        properties.columns = [];
                    }
                    for (var i = 0; i < numOfColumns; i++) {
                        if (!properties.columns[i]) {
                            properties.columns[i] = { type: 'text', source: [], options: [], width: obj.options.defaultColWidth, align: 'center' };
                        }
                    }

                    // Insert before
                    var columnIndex = (!insertBefore) ? columnNumber + 1 : columnNumber;
                    obj.options.columns = jexcel.injectArray(obj.options.columns, columnIndex, properties.columns);

                    // Open space in the containers
                    var currentHeaders = obj.headers.splice(columnIndex);
                    var currentColgroup = obj.colgroup.splice(columnIndex);

                    // History
                    var historyHeaders = [];
                    var historyColgroup = [];
                    var historyRecords = [];
                    var historyData = [];

                    // Add new headers
                    for (var col = columnIndex; col < (numOfColumns + columnIndex); col++) {
                        obj.createCellHeader(col);
                        obj.headerContainer.insertBefore(obj.headers[col], obj.headerContainer.children[col + 1]);
                        obj.colgroupContainer.insertBefore(obj.colgroup[col], obj.colgroupContainer.children[col + 1]);

                        historyHeaders.push(obj.headers[col]);
                        historyColgroup.push(obj.colgroup[col]);
                    }

                    // Adding visual columns
                    for (var row = 0; row < obj.options.data.length; row++) {
                        // Keep the current data
                        var currentData = obj.options.data[row].splice(columnIndex);
                        var currentRecord = obj.records[row].splice(columnIndex);

                        // History
                        historyData[row] = [];
                        historyRecords[row] = [];

                        for (var col = columnIndex; col < (numOfColumns + columnIndex); col++) {
                            // New value
                            var value = data[row] ? data[row] : '';
                            obj.options.data[row][col] = value;
                            // New cell
                            var td = obj.createCell(col, row, obj.options.data[row][col]);
                            obj.records[row][col] = td;
                            // Add cell to the row
                            if (obj.rows[row]) {
                                obj.rows[row].insertBefore(td, obj.rows[row].children[col + 1]);
                            }

                            // Record History
                            historyData[row].push(value);
                            historyRecords[row].push(td);
                        }

                        // Copy the data back to the main data
                        Array.prototype.push.apply(obj.options.data[row], currentData);
                        Array.prototype.push.apply(obj.records[row], currentRecord);
                    }

                    Array.prototype.push.apply(obj.headers, currentHeaders);
                    Array.prototype.push.apply(obj.colgroup, currentColgroup);

                    // Adjust nested headers
                    if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                        // Flexible way to handle nestedheaders
                        if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                            for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                                var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan) + numOfColumns;
                                obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan = colspan;
                                obj.thead.children[j].children[obj.thead.children[j].children.length - 1].setAttribute('colspan', colspan);
                            }
                        } else {
                            var colspan = parseInt(obj.options.nestedHeaders[0].colspan) + numOfColumns;
                            obj.options.nestedHeaders[0].colspan = colspan;
                            obj.thead.children[0].children[obj.thead.children[0].children.length - 1].setAttribute('colspan', colspan);
                        }
                    }

                    // Keep history
                    obj.setHistory({
                        action: 'insertColumn',
                        columnNumber: columnNumber,
                        numOfColumns: numOfColumns,
                        insertBefore: insertBefore,
                        columns: properties.columns,
                        headers: historyHeaders,
                        colgroup: historyColgroup,
                        records: historyRecords,
                        data: historyData,
                    });

                    // Remove table references
                    obj.updateTableReferences();

                    // Events
                    if (obj.ignoreEvents != true) {
                        if (typeof (obj.options.oninsertcolumn) == 'function') {
                            obj.options.oninsertcolumn(el, columnNumber, numOfColumns);
                        }
                    }
                }
            }

            /**
             * Delete a column by number
             *
             * @param integer columnNumber - reference column to be excluded
             * @param integer numOfColumns - number of columns to be excluded from the reference column
             * @return void
             */
            obj.deleteColumn = function (columnNumber, numOfColumns) {
                // Global Configuration
                if (obj.options.allowDeleteColumn == true) {
                    if (obj.headers.length > 1) {
                        // Delete column definitions
                        if (columnNumber == undefined) {
                            var number = obj.getSelectedColumns(true);

                            if (!number.length) {
                                // Remove last column
                                columnNumber = obj.headers.length - 1;
                                numOfColumns = 1;
                            } else {
                                // Remove selected
                                columnNumber = parseInt(number[0]);
                                numOfColumns = parseInt(number.length);
                            }
                        }

                        // Lasat column
                        var lastColumn = obj.options.data[0].length - 1;

                        if (columnNumber == undefined || columnNumber > lastColumn || columnNumber < 0) {
                            columnNumber = lastColumn;
                        }

                        // Minimum of columns to be delete is 1
                        if (!numOfColumns) {
                            numOfColumns = 1;
                        }



                        // Can't delete more than the limit of the table
                        if (numOfColumns > obj.options.data[0].length - columnNumber) {
                            numOfColumns = obj.options.data[0].length - columnNumber;
                        }

                        // onbeforedeletecolumn
                        if (typeof (obj.options.onbeforedeletecolumn) == 'function') {
                            if (!obj.options.onbeforedeletecolumn(el, columnNumber, numOfColumns)) {
                                console.log('onbeforedeletecolumn returned false');
                                return false;
                            }
                        }

                        // Can't remove the last column
                        if (parseInt(columnNumber) > -1) {
                            // Merged cells
                            var mergeExists = false;
                            if (Object.keys(obj.options.mergeCells).length > 0) {
                                for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                                    if (obj.isColMerged(col, false).length) {
                                        mergeExists = true;
                                    }
                                }
                            }
                            if (mergeExists) {
                                if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                                    return false;
                                } else {
                                    obj.destroyMerged();
                                }
                            }

                            // Delete the column properties
                            var columns = obj.options.columns.splice(columnNumber, numOfColumns);

                            for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                                obj.colgroup[col].className = '';
                                obj.headers[col].className = '';
                                obj.colgroup[col].remove();
                                obj.headers[col].remove();
                            }

                            var historyHeaders = obj.headers.splice(columnNumber, numOfColumns);
                            var historyColgroup = obj.colgroup.splice(columnNumber, numOfColumns);
                            var historyRecords = [];
                            var historyData = [];

                            for (var row = 0; row < obj.options.data.length; row++) {
                                for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                                    obj.records[row][col].className = '';
                                    obj.records[row][col].remove();
                                }
                            }

                            // Delete headers
                            for (var row = 0; row < obj.options.data.length; row++) {
                                // History
                                historyData[row] = obj.options.data[row].splice(columnNumber, numOfColumns);
                                historyRecords[row] = obj.records[row].splice(columnNumber, numOfColumns);
                            }

                            // Remove selection
                            obj.conditionalSelectionUpdate(0, columnNumber, (columnNumber + numOfColumns) - 1);

                            // Adjust nested headers
                            if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                                // Flexible way to handle nestedheaders
                                if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                                    for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                                        var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan) - numOfColumns;
                                        obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan = colspan;
                                        obj.thead.children[j].children[obj.thead.children[j].children.length - 1].setAttribute('colspan', colspan);
                                    }
                                } else {
                                    var colspan = parseInt(obj.options.nestedHeaders[0].colspan) - numOfColumns;
                                    obj.options.nestedHeaders[0].colspan = colspan;
                                    obj.thead.children[0].children[obj.thead.children[0].children.length - 1].setAttribute('colspan', colspan);
                                }
                            }

                            // Keeping history of changes
                            obj.setHistory({
                                action: 'deleteColumn',
                                columnNumber: columnNumber,
                                numOfColumns: numOfColumns,
                                insertBefore: 1,
                                columns: columns,
                                headers: historyHeaders,
                                colgroup: historyColgroup,
                                records: historyRecords,
                                data: historyData,
                            });

                            // Update table references
                            obj.updateTableReferences();

                            // Delete
                            if (obj.ignoreEvents != true) {
                                if (typeof (obj.options.ondeletecolumn) == 'function') {
                                    obj.options.ondeletecolumn(el, columnNumber, numOfColumns, historyRecords);
                                }
                            }
                        }
                    } else {
                        console.error('JEXCEL. It is not possible to delete the last column');
                    }
                }
            }

            /**
             * Get seleted rows numbers
             *
             * @return array
             */
            obj.getSelectedRows = function (asIds) {
                var rows = [];
                // Get all selected rows
                for (var j = 0; j < obj.rows.length; j++) {
                    if (obj.rows[j].classList.contains('selected')) {
                        if (asIds) {
                            rows.push(j);
                        } else {
                            rows.push(obj.rows[j]);
                        }
                    }
                }

                return rows;
            },

                /**
                 * Get seleted column numbers
                 *
                 * @return array
                 */
                obj.getSelectedColumns = function () {
                    var cols = [];
                    // Get all selected cols
                    for (var i = 0; i < obj.headers.length; i++) {
                        if (obj.headers[i].classList.contains('selected')) {
                            cols.push(i);
                        }
                    }

                    return cols;
                }

            /**
             * Get highlighted
             *
             * @return array
             */
            obj.getHighlighted = function () {
                return obj.highlighted;
            }

            /**
             * Update cell references
             *
             * @return void
             */
            obj.updateTableReferences = function () {
                // Update headers
                for (var i = 0; i < obj.headers.length; i++) {
                    var x = obj.headers[i].getAttribute('data-x');

                    if (x != i) {
                        // Update coords
                        obj.headers[i].setAttribute('data-x', i);
                        // Title
                        if (!obj.headers[i].getAttribute('title')) {
                            obj.headers[i].innerHTML = jexcel.getColumnName(i);
                        }
                    }
                }

                // Update all rows
                for (var j = 0; j < obj.rows.length; j++) {
                    var y = obj.rows[j].getAttribute('data-y');

                    if (y != j) {
                        // Update coords
                        obj.rows[j].setAttribute('data-y', j);
                        obj.rows[j].children[0].setAttribute('data-y', j);
                        // Row number
                        obj.rows[j].children[0].innerHTML = j + 1;
                    }
                }

                // Regular cells affected by this change
                var affectedTokens = [];
                var mergeCellUpdates = [];

                // Update cell
                var updatePosition = function (x, y, i, j) {
                    if (x != i) {
                        obj.records[j][i].setAttribute('data-x', i);
                    }
                    if (y != j) {
                        obj.records[j][i].setAttribute('data-y', j);
                    }

                    // Other updates
                    if (x != i || y != j) {
                        var columnIdFrom = jexcel.getColumnNameFromId([x, y]);
                        var columnIdTo = jexcel.getColumnNameFromId([i, j]);
                        affectedTokens[columnIdFrom] = columnIdTo;
                    }
                }

                for (var j = 0; j < obj.records.length; j++) {
                    for (var i = 0; i < obj.records[0].length; i++) {
                        // Current values
                        var x = obj.records[j][i].getAttribute('data-x');
                        var y = obj.records[j][i].getAttribute('data-y');

                        // Update column
                        if (obj.records[j][i].getAttribute('data-merged')) {
                            var columnIdFrom = jexcel.getColumnNameFromId([x, y]);
                            var columnIdTo = jexcel.getColumnNameFromId([i, j]);
                            if (mergeCellUpdates[columnIdFrom] == null) {
                                if (columnIdFrom == columnIdTo) {
                                    mergeCellUpdates[columnIdFrom] = false;
                                } else {
                                    var totalX = parseInt(i - x);
                                    var totalY = parseInt(j - y);
                                    mergeCellUpdates[columnIdFrom] = [columnIdTo, totalX, totalY];
                                }
                            }
                        } else {
                            updatePosition(x, y, i, j);
                        }
                    }
                }

                // Update merged if applicable
                var keys = Object.keys(mergeCellUpdates);
                if (keys.length) {
                    for (var i = 0; i < keys.length; i++) {
                        if (mergeCellUpdates[keys[i]]) {
                            var info = jexcel.getIdFromColumnName(keys[i], true)
                            var x = info[0];
                            var y = info[1];
                            updatePosition(x, y, x + mergeCellUpdates[keys[i]][1], y + mergeCellUpdates[keys[i]][2]);

                            var columnIdFrom = keys[i];
                            var columnIdTo = mergeCellUpdates[keys[i]][0];
                            for (var j = 0; j < obj.options.mergeCells[columnIdFrom][2].length; j++) {
                                var x = parseInt(obj.options.mergeCells[columnIdFrom][2][j].getAttribute('data-x'));
                                var y = parseInt(obj.options.mergeCells[columnIdFrom][2][j].getAttribute('data-y'));
                                obj.options.mergeCells[columnIdFrom][2][j].setAttribute('data-x', x + mergeCellUpdates[keys[i]][1]);
                                obj.options.mergeCells[columnIdFrom][2][j].setAttribute('data-y', y + mergeCellUpdates[keys[i]][2]);
                            }

                            obj.options.mergeCells[columnIdTo] = obj.options.mergeCells[columnIdFrom];
                            delete (obj.options.mergeCells[columnIdFrom]);
                        }
                    }
                }

                // Update formulas
                obj.updateFormulas(affectedTokens);

                // Refresh selection
                obj.refreshSelection();

                // Update table with custom configuration if applicable
                obj.updateTable();
            }


            /**
             * Custom settings for the cells
             */
            obj.updateTable = function () {
                // Check for spare
                if (obj.options.minSpareRows > 0) {
                    var numBlankRows = 0;
                    for (var j = obj.rows.length - 1; j >= 0; j--) {
                        var test = false;
                        for (var i = 0; i < obj.headers.length; i++) {
                            if (obj.options.data[j][i]) {
                                test = true;
                            }
                        }
                        if (test) {
                            break;
                        } else {
                            numBlankRows++;
                        }
                    }

                    if (obj.options.minSpareRows - numBlankRows > 0) {
                        obj.insertRow(obj.options.minSpareRows - numBlankRows)
                    }
                }

                if (obj.options.minSpareCols > 0) {
                    var numBlankCols = 0;
                    for (var i = obj.headers.length - 1; i >= 0; i--) {
                        var test = false;
                        for (var j = 0; j < obj.rows.length; j++) {
                            if (obj.options.data[j][i]) {
                                test = true;
                            }
                        }
                        if (test) {
                            break;
                        } else {
                            numBlankCols++;
                        }
                    }

                    if (obj.options.minSpareCols - numBlankCols > 0) {
                        obj.insertColumn(obj.options.minSpareCols - numBlankCols)
                    }
                }

                // Customizations by the developer
                if (typeof (obj.options.updateTable) == 'function') {
                    for (var j = 0; j < obj.rows.length; j++) {
                        for (var i = 0; i < obj.headers.length; i++) {
                            obj.options.updateTable(el, obj.records[j][i], i, j, obj.options.data[j][i], obj.records[j][i].innerText, jexcel.getColumnNameFromId([i, j]));
                        }
                    }
                }

                // Update corner position
                setTimeout(function () {
                    obj.updateCornerPosition();
                }, 0);
            }

            /**
             * Show index column
             */
            obj.showIndex = function () {
                obj.colgroupContainer.children[0].width = 40;
            }

            /**
             * Hide index column
             */
            obj.hideIndex = function () {
                obj.colgroupContainer.children[0].width = 0;
            }

            /**
             * Update all related cells in the chain
             */
            obj.updateFormulaChain = function (x, y, records) {
                var cellId = jexcel.getColumnNameFromId([x, y]);
                if (obj.formula[cellId] && obj.formula[cellId].length > 0) {
                    for (var i = 0; i < obj.formula[cellId].length; i++) {
                        var cell = jexcel.getIdFromColumnName(obj.formula[cellId][i], true);
                        // Update cell
                        var value = '' + obj.options.data[cell[1]][cell[0]];
                        if (value.substr(0, 1) == '=') {
                            records.push(obj.updateCell(cell[0], cell[1], value, true));
                        } else {
                            // No longer a formula, remove from the chain
                            Object.keys(obj.formula)[i] = null;
                        }
                        obj.updateFormulaChain(cell[0], cell[1], records);
                    }
                }
            }

            /**
             * Update formulas
             */
            obj.updateFormulas = function (referencesToUpdate) {
                // Update formulas
                for (var j = 0; j < obj.options.data.length; j++) {
                    for (var i = 0; i < obj.options.data[0].length; i++) {
                        var value = '' + obj.options.data[j][i];
                        // Is formula
                        if (value.substr(0, 1) == '=') {
                            // Replace tokens
                            var newFormula = obj.updateFormula(value, referencesToUpdate);
                            if (newFormula != value) {
                                obj.options.data[j][i] = newFormula;
                            }
                        }
                    }
                }

                // Update formula chain
                var formula = [];
                var keys = Object.keys(obj.formula);
                for (var j = 0; j < keys.length; j++) {
                    // Current key and values
                    var key = keys[j];
                    var value = obj.formula[key];
                    // Update key
                    if (referencesToUpdate[key]) {
                        key = referencesToUpdate[key];
                    }
                    // Update values
                    formula[key] = [];
                    for (var i = 0; i < value.length; i++) {
                        var letter = value[i];
                        if (referencesToUpdate[letter]) {
                            letter = referencesToUpdate[letter];
                        }
                        formula[key].push(letter);
                    }
                }
                obj.formula = formula;
            }

            /**
             * Update formula
             */
            obj.updateFormula = function (formula, referencesToUpdate) {
                var testLetter = /[A-Z]/;
                var testNumber = /[0-9]/;

                var newFormula = '';
                var letter = null;
                var number = null;
                var token = '';

                for (var index = 0; index < formula.length; index++) {
                    if (testLetter.exec(formula[index])) {
                        letter = 1;
                        number = 0;
                        token += formula[index];
                    } else if (testNumber.exec(formula[index])) {
                        number = letter ? 1 : 0;
                        token += formula[index];
                    } else {
                        if (letter && number) {
                            token = referencesToUpdate[token] ? referencesToUpdate[token] : token;
                        }
                        newFormula += token;
                        newFormula += formula[index];
                        letter = 0;
                        number = 0;
                        token = '';
                    }
                }

                if (token) {
                    if (letter && number) {
                        token = referencesToUpdate[token] ? referencesToUpdate[token] : token;
                    }
                    newFormula += token;
                }

                return newFormula;
            }

            /**
             * Parse formulas
             */
            obj.executeFormula = function (expression, x, y) {
                // Code protection
                obj.formulaStack++;
                if (obj.formulaStack > 5) {
                    console.error('Too many executions...');
                    return 0;
                }
                // Parent column identification
                var parentId = jexcel.getColumnNameFromId([x, y]);
                // Convert range tokens
                var tokensUpdate = function (tokens) {
                    for (var index = 0; index < tokens.length; index++) {
                        var f = [];
                        var token = tokens[index].split(':');
                        var e1 = jexcel.getIdFromColumnName(token[0], true);
                        var e2 = jexcel.getIdFromColumnName(token[1], true);

                        if (e1[0] <= e2[0]) {
                            var x1 = e1[0];
                            var x2 = e2[0];
                        } else {
                            var x1 = e2[0];
                            var x2 = e1[0];
                        }

                        if (e1[1] <= e2[1]) {
                            var y1 = e1[1];
                            var y2 = e2[1];
                        } else {
                            var y1 = e2[1];
                            var y2 = e1[1];
                        }

                        for (var j = y1; j <= y2; j++) {
                            for (var i = x1; i <= x2; i++) {
                                f.push(jexcel.getColumnNameFromId([i, j]));
                            }
                        }

                        expression = expression.replace(tokens[index], f.join(','));
                    }
                }

                var tokens = expression.match(/([A-Z]+[0-9]+)\:([A-Z]+[0-9]+)/g);
                if (tokens && tokens.length) {
                    tokensUpdate(tokens);
                }

                // Get tokens
                var tokens = expression.match(/([A-Z]+[0-9]+)/g);

                if (tokens) {
                    var evalstring = "";
                    for (var i = 0; i < tokens.length; i++) {
                        // Keep chain
                        if (!obj.formula[tokens[i]]) {
                            obj.formula[tokens[i]] = [];
                        }
                        // Is already in the register
                        if (obj.formula[tokens[i]].indexOf(parentId) < 0) {
                            obj.formula[tokens[i]].push(parentId);
                        }

                        // Do not calculate again
                        if (eval('typeof(' + tokens[i] + ') == "undefined"')) {
                            // Declaretion
                            evalstring += "var " + tokens[i] + " = null;";
                            // Coords
                            var position = jexcel.getIdFromColumnName(tokens[i], 1);
                            // Get value
                            if (obj.records[position[1]] && obj.records[position[1]][position[0]]) {
                                var value = obj.records[position[1]][position[0]].innerHTML;
                            } else if (obj.options.data[position[1]] && obj.options.data[position[1]][position[0]]) {
                                var value = obj.options.data[position[1]][position[0]];
                            } else {
                                var value = '';
                            }
                            // Get column data
                            if (('' + value).substr(0, 1) == '=') {
                                value = obj.executeFormula(value, position[0], position[1]);
                            }
                            // Type!
                            if (('' + value).trim() == '' || value != Number(value)) {
                                // Trying any formatted number
                                var number = ('' + value);
                                var decimal = obj.options.columns[position[0]].decimal || '.';
                                number = number.split(decimal);
                                number[0] = number[0].match(/[+-]?[0-9]/g);
                                if (number[0]) {
                                    number[0] = number[0].join('');
                                }
                                if (number[1]) {
                                    number[1] = number[1].match(/[0-9]*/g).join('');
                                }
                                // Got a valid number
                                if (number[0] && Number(number[0]) >= 0) {
                                    if (!number[1]) {
                                        evalstring += "var " + tokens[i] + " = " + number[0] + ".00;";
                                    } else {
                                        evalstring += "var " + tokens[i] + " = " + number[0] + '.' + number[1] + ";";
                                    }
                                } else {
                                    // Render as string
                                    evalstring += "var " + tokens[i] + " = '" + value + "';";
                                }
                            } else {
                                // Number
                                evalstring += "var " + tokens[i] + " = " + value + ";";
                            }
                        }
                    }
                }

                obj.formulaStack = 0;

                // Convert formula to javascript
                try {
                    var res = eval(evalstring + expression.substr(1));
                } catch (e) {
                    var res = '#ERROR';
                }

                return res;
            }

            /**
             * Get row number
             */
            obj.row = function (cell) {
            }

            /**
             * Get col number
             */
            obj.col = function (cell) {
            }

            obj.up = function (shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[3] > 0) {
                        obj.up.visible(1, ctrlKey ? 0 : 1)
                    }
                } else {
                    if (obj.selectedCell[1] > 0) {
                        obj.up.visible(0, ctrlKey ? 0 : 1)
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }

                // Update selection
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);

                // Change page
                if (obj.options.lazyLoading == true) {
                    if (obj.selectedCell[1] == 0 || obj.selectedCell[3] == 0) {
                        obj.loadPage(0);
                        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                    } else {
                        if (obj.loadValidation()) {
                            obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                        } else {
                            var item = parseInt(obj.tbody.firstChild.getAttribute('data-y'));
                            if (obj.selectedCell[1] - item < 30) {
                                obj.loadUp();
                                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                            }
                        }
                    }
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }

                obj.updateScroll(1);
            }

            obj.up.visible = function (group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }

                if (direction == 0) {
                    for (var j = 0; j < y; j++) {
                        if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                            y = j;
                            break;
                        }
                    }
                } else {
                    y = obj.up.get(x, y);
                }

                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            }

            obj.up.get = function (x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
                for (var j = (y - 1); j >= 0; j--) {
                    if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                        if (obj.records[j][x].getAttribute('data-merged')) {
                            if (obj.records[j][x] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        y = j;
                        break;
                    }
                }

                return y;
            }

            obj.down = function (shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[3] < obj.records.length - 1) {
                        obj.down.visible(1, ctrlKey ? 0 : 1)
                    }
                } else {
                    if (obj.selectedCell[1] < obj.records.length - 1) {
                        obj.down.visible(0, ctrlKey ? 0 : 1)
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }

                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);

                // Change page
                if (obj.options.lazyLoading == true) {
                    if ((obj.selectedCell[1] == obj.records.length - 1 || obj.selectedCell[3] == obj.records.length - 1)) {
                        obj.loadPage(-1);
                        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                    } else {
                        if (obj.loadValidation()) {
                            obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                        } else {
                            var item = parseInt(obj.tbody.lastChild.getAttribute('data-y'));
                            if (item - obj.selectedCell[3] < 30) {
                                obj.loadDown();
                                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                            }
                        }
                    }
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }

                obj.updateScroll(3);
            }

            obj.down.visible = function (group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }

                if (direction == 0) {
                    for (var j = obj.rows.length - 1; j > y; j--) {
                        if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                            y = j;
                            break;
                        }
                    }
                } else {
                    y = obj.down.get(x, y);
                }

                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            }

            obj.down.get = function (x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
                for (var j = (y + 1); j < obj.rows.length; j++) {
                    if (obj.records[j][x].style.display != 'none' && obj.rows[j].style.display != 'none') {
                        if (obj.records[j][x].getAttribute('data-merged')) {
                            if (obj.records[j][x] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        y = j;
                        break;
                    }
                }

                return y;
            }

            obj.right = function (shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[2] < obj.headers.length - 1) {
                        obj.right.visible(1, ctrlKey ? 0 : 1)
                    }
                } else {
                    if (obj.selectedCell[0] < obj.headers.length - 1) {
                        obj.right.visible(0, ctrlKey ? 0 : 1)
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }

                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(2);
            }

            obj.right.visible = function (group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }

                if (direction == 0) {
                    for (var i = obj.headers.length - 1; i > x; i--) {
                        if (obj.records[y][i].style.display != 'none') {
                            x = i;
                            break;
                        }
                    }
                } else {
                    x = obj.right.get(x, y);
                }

                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            }

            obj.right.get = function (x, y) {
                var x = parseInt(x);
                var y = parseInt(y);

                for (var i = (x + 1); i < obj.headers.length; i++) {
                    if (obj.records[y][i].style.display != 'none') {
                        if (obj.records[y][i].getAttribute('data-merged')) {
                            if (obj.records[y][i] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        x = i;
                        break;
                    }
                }

                return x;
            }

            obj.left = function (shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (obj.selectedCell[2] > 0) {
                        obj.left.visible(1, ctrlKey ? 0 : 1)
                    }
                } else {
                    if (obj.selectedCell[0] > 0) {
                        obj.left.visible(0, ctrlKey ? 0 : 1)
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }

                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(0);
            }

            obj.left.visible = function (group, direction) {
                if (group == 0) {
                    var x = parseInt(obj.selectedCell[0]);
                    var y = parseInt(obj.selectedCell[1]);
                } else {
                    var x = parseInt(obj.selectedCell[2]);
                    var y = parseInt(obj.selectedCell[3]);
                }

                if (direction == 0) {
                    for (var i = 0; i < x; i++) {
                        if (obj.records[y][i].style.display != 'none') {
                            x = i;
                            break;
                        }
                    }
                } else {
                    x = obj.left.get(x, y);
                }

                if (group == 0) {
                    obj.selectedCell[0] = x;
                    obj.selectedCell[1] = y;
                } else {
                    obj.selectedCell[2] = x;
                    obj.selectedCell[3] = y;
                }
            }

            obj.left.get = function (x, y) {
                var x = parseInt(x);
                var y = parseInt(y);
                for (var i = (x - 1); i >= 0; i--) {
                    if (obj.records[y][i].style.display != 'none') {
                        if (obj.records[y][i].getAttribute('data-merged')) {
                            if (obj.records[y][i] == obj.records[y][x]) {
                                continue;
                            }
                        }
                        x = i;
                        break;
                    }
                }

                return x;
            }

            obj.first = function (shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (ctrlKey) {
                        obj.selectedCell[3] = 0;
                    } else {
                        obj.left.visible(1, 0);
                    }
                } else {
                    if (ctrlKey) {
                        obj.selectedCell[1] = 0;
                    } else {
                        obj.left.visible(0, 0);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }

                // Change page
                if (obj.options.lazyLoading == true && (obj.selectedCell[1] == 0 || obj.selectedCell[3] == 0)) {
                    obj.loadPage(0);
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }

                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(1);
            }

            obj.last = function (shiftKey, ctrlKey) {
                if (shiftKey) {
                    if (ctrlKey) {
                        obj.selectedCell[3] = obj.records.length - 1;
                    } else {
                        obj.right.visible(1, 0);
                    }
                } else {
                    if (ctrlKey) {
                        obj.selectedCell[1] = obj.records.length - 1;
                    } else {
                        obj.right.visible(0, 0);
                    }
                    obj.selectedCell[2] = obj.selectedCell[0];
                    obj.selectedCell[3] = obj.selectedCell[1];
                }

                // Change page
                if (obj.options.lazyLoading == true && (obj.selectedCell[1] == obj.records.length - 1 || obj.selectedCell[3] == obj.records.length - 1)) {
                    obj.loadPage(-1);
                } else if (obj.options.pagination > 0) {
                    var pageNumber = obj.whichPage(obj.selectedCell[3]);
                    if (pageNumber != obj.pageNumber) {
                        obj.page(pageNumber);
                    }
                }

                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
                obj.updateScroll(3);
            }

            obj.selectAll = function () {
                if (!obj.selectedCell) {
                    obj.selectedCell = [];
                }

                obj.selectedCell[0] = 0;
                obj.selectedCell[1] = 0;
                obj.selectedCell[2] = obj.headers.length - 1;
                obj.selectedCell[3] = obj.records.length - 1;

                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
            }

            /**
             * Go to a page in a lazyLoading
             */
            obj.loadPage = function (pageNumber) {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }

                // Per page
                var quantityPerPage = 100;

                // pageNumber
                if (pageNumber == null || pageNumber == -1) {
                    // Last page
                    pageNumber = Math.ceil(results.length / quantityPerPage);
                }

                var startRow = (pageNumber * quantityPerPage);
                var finalRow = (pageNumber * quantityPerPage) + quantityPerPage;
                if (finalRow > results.length) {
                    finalRow = results.length;
                }
                startRow = finalRow - 100;
                if (startRow < 0) {
                    startRow = 0;
                }

                // Appeding items
                for (var j = startRow; j < finalRow; j++) {
                    if (obj.options.search == true && obj.results) {
                        obj.tbody.appendChild(obj.rows[results[j]]);
                    } else {
                        obj.tbody.appendChild(obj.rows[j]);
                    }

                    if (obj.tbody.children.length > quantityPerPage) {
                        obj.tbody.removeChild(obj.tbody.firstChild);
                    }
                }
            }

            obj.loadUp = function () {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }
                var test = 0;
                if (results.length > 100) {
                    // Get the first element in the page
                    var item = parseInt(obj.tbody.firstChild.getAttribute('data-y'));
                    if (obj.options.search == true && obj.results) {
                        item = results.indexOf(item);
                    }
                    if (item > 0) {
                        for (var j = 0; j < 30; j++) {
                            item = item - 1;
                            if (item > -1) {
                                if (obj.options.search == true && obj.results) {
                                    obj.tbody.insertBefore(obj.rows[results[item]], obj.tbody.firstChild);
                                } else {
                                    obj.tbody.insertBefore(obj.rows[item], obj.tbody.firstChild);
                                }
                                if (obj.tbody.children.length > 100) {
                                    obj.tbody.removeChild(obj.tbody.lastChild);
                                    test = 1;
                                }
                            }
                        }
                    }
                }
                return test;
            }

            obj.loadDown = function () {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }
                var test = 0;
                if (results.length > 100) {
                    // Get the last element in the page
                    var item = parseInt(obj.tbody.lastChild.getAttribute('data-y'));
                    if (obj.options.search == true && obj.results) {
                        item = results.indexOf(item);
                    }
                    if (item < obj.rows.length - 1) {
                        for (var j = 0; j <= 30; j++) {
                            if (item < results.length) {
                                if (obj.options.search == true && obj.results) {
                                    obj.tbody.appendChild(obj.rows[results[item]]);
                                } else {
                                    obj.tbody.appendChild(obj.rows[item]);
                                }
                                if (obj.tbody.children.length > 100) {
                                    obj.tbody.removeChild(obj.tbody.firstChild);
                                    test = 1;
                                }
                            }
                            item = item + 1;
                        }
                    }
                }

                return test;
            }

            obj.loadValidation = function () {
                if (obj.selectedCell) {
                    var currentPage = parseInt(obj.tbody.firstChild.getAttribute('data-y')) / 100;
                    var selectedPage = parseInt(obj.selectedCell[3] / 100);
                    var totalPages = parseInt(obj.rows.length / 100);

                    if (currentPage != selectedPage && selectedPage <= totalPages) {
                        if (!Array.prototype.indexOf.call(obj.tbody.children, obj.rows[obj.selectedCell[3]])) {
                            obj.loadPage(selectedPage);
                            return true;
                        }
                    }
                }

                return false;
            }

            /**
             * Reset search
             */
            obj.resetSearch = function () {
                obj.searchInput.value = '';
                obj.search('');
                obj.results = null;
            }

            /**
             * Search
             */
            obj.search = function (query) {
                // Query
                if (query) {
                    var query = query.toLowerCase();
                }

                // Reset selection
                obj.resetSelection();

                // Total of results
                obj.pageNumber = 0;
                obj.results = [];

                if (query) {
                    // Search filter
                    var search = function (item, query, index) {
                        for (var i = 0; i < item.length; i++) {
                            if (('' + item[i]).toLowerCase().search(query) >= 0 ||
                                ('' + obj.records[index][i].innerHTML).toLowerCase().search(query) >= 0) {
                                return true;
                            }
                        }
                        return false;
                    }

                    // Result
                    var addToResult = function (k) {
                        if (obj.results.indexOf(k) == -1) {
                            obj.results.push(k);
                        }
                    }

                    // Filter
                    var data = obj.options.data.filter(function (v, k) {
                        if (search(v, query, k)) {
                            // Merged rows found
                            var rows = obj.isRowMerged(k);
                            if (rows.length) {
                                for (var i = 0; i < rows.length; i++) {
                                    var row = jexcel.getIdFromColumnName(rows[i], true);
                                    for (var j = 0; j < obj.options.mergeCells[rows[i]][1]; j++) {
                                        addToResult(row[1] + j);
                                    }
                                }
                            } else {
                                // Normal row found
                                addToResult(k);
                            }
                            return true;
                        } else {
                            return false;
                        }
                    });
                } else {
                    obj.results = null;
                }

                var total = 0;
                var index = 0;

                // Page 1
                if (obj.options.lazyLoading == true) {
                    total = 100;
                } else if (obj.options.pagination > 0) {
                    total = obj.options.pagination;
                } else {
                    if (obj.results) {
                        total = obj.results.length;
                    } else {
                        total = obj.rows.length;
                    }
                }

                // Hide all records from the table
                obj.tbody.innerHTML = '';
                for (var j = 0; j < obj.rows.length; j++) {
                    if (!obj.results || obj.results.indexOf(j) > -1) {
                        if (index < total) {
                            obj.tbody.appendChild(obj.rows[j]);
                            index++;
                        }
                        obj.rows[j].style.display = '';
                    } else {
                        obj.rows[j].style.display = 'none';
                    }
                }

                if (obj.options.pagination > 0) {
                    obj.updatePagination();
                }

                return total;
            }

            /**
             * Which page the cell is
             */
            obj.whichPage = function (cell) {
                // Search
                if (obj.options.search == true && obj.results) {
                    cell = obj.results.indexOf(cell);
                }

                return (Math.ceil((parseInt(cell) + 1) / parseInt(obj.options.pagination))) - 1;
            }

            /**
             * Go to page
             */
            obj.page = function (pageNumber) {
                // Search
                if (obj.options.search == true && obj.results) {
                    var results = obj.results;
                } else {
                    var results = obj.rows;
                }

                // Per page
                var quantityPerPage = parseInt(obj.options.pagination);

                // pageNumber
                if (pageNumber == null || pageNumber == -1) {
                    // Last page
                    pageNumber = Math.ceil(results.length / quantityPerPage);
                }

                // Page number
                obj.pageNumber = pageNumber;

                var startRow = (pageNumber * quantityPerPage);
                var finalRow = (pageNumber * quantityPerPage) + quantityPerPage;
                if (finalRow > results.length) {
                    finalRow = results.length;
                }
                if (startRow < 0) {
                    startRow = 0;
                }

                // Reset container
                obj.tbody.innerHTML = '';

                // Appeding items
                for (var j = startRow; j < finalRow; j++) {
                    if (obj.options.search == true && obj.results) {
                        obj.tbody.appendChild(obj.rows[results[j]]);
                    } else {
                        obj.tbody.appendChild(obj.rows[j]);
                    }
                }

                if (obj.options.pagination > 0) {
                    obj.updatePagination();
                }

                // Update corner position
                obj.updateCornerPosition();
            }

            /**
             * Update the pagination
             */
            obj.updatePagination = function () {
                // Reset container
                obj.pagination.children[0].innerHTML = '';
                obj.pagination.children[1].innerHTML = '';

                // Start pagination
                if (obj.options.pagination) {
                    // Searchable
                    if (obj.options.search == true && obj.results) {
                        var results = obj.results.length;
                    } else {
                        var results = obj.rows.length;
                    }

                    if (!results) {
                        // No records found
                        obj.pagination.children[0].innerHTML = obj.options.text.noRecordsFound;
                    } else {
                        // Pagination container
                        var quantyOfPages = Math.ceil(results / obj.options.pagination);

                        if (obj.pageNumber < 6) {
                            var startNumber = 1;
                            var finalNumber = quantyOfPages < 10 ? quantyOfPages : 10;
                        } else if (quantyOfPages - obj.pageNumber < 5) {
                            var startNumber = quantyOfPages - 9;
                            var finalNumber = quantyOfPages;
                        } else {
                            var startNumber = obj.pageNumber - 4;
                            var finalNumber = obj.pageNumber + 5;
                        }

                        // First
                        if (startNumber > 1) {
                            var paginationItem = document.createElement('div');
                            paginationItem.className = 'jexcel_page';
                            paginationItem.innerHTML = '<';
                            paginationItem.title = 1;
                            obj.pagination.children[1].appendChild(paginationItem);
                        }

                        // Get page links
                        for (var i = startNumber; i <= finalNumber; i++) {
                            var paginationItem = document.createElement('div');
                            paginationItem.className = 'jexcel_page';
                            paginationItem.innerHTML = i;
                            obj.pagination.children[1].appendChild(paginationItem);

                            if (obj.pageNumber == (i - 1)) {
                                paginationItem.classList.add('jexcel_page_selected');
                            }
                        }

                        // Last
                        if (finalNumber < quantyOfPages) {
                            var paginationItem = document.createElement('div');
                            paginationItem.className = 'jexcel_page';
                            paginationItem.innerHTML = '>';
                            paginationItem.title = quantyOfPages;
                            obj.pagination.children[1].appendChild(paginationItem);
                        }

                        // Text
                        var format = function (format) {
                            var args = Array.prototype.slice.call(arguments, 1);
                            return format.replace(/{(\d+)}/g, function (match, number) {
                                return typeof args[number] != 'undefined'
                                    ? args[number]
                                    : match
                                    ;
                            });
                        };

                        obj.pagination.children[0].innerHTML = format(obj.options.text.showingPage, obj.pageNumber + 1, quantyOfPages)
                    }
                }
            }

            /**
             * Download CSV table
             *
             * @return null
             */
            obj.download = function (includeHeaders) {
                if (obj.options.allowExport == false) {
                    console.error('Export not allowed');
                } else {
                    // Data
                    var data = '';
                    if (includeHeaders == true) {
                        data += obj.getHeaders();
                        data += "\r\n";
                    }
                    // Get data
                    data += obj.copy(false, ',', true);
                    // Download element
                    var pom = document.createElement('a');
                    var blob = new Blob([data], { type: 'text/csv;charset=utf-8;' });
                    var url = URL.createObjectURL(blob);
                    pom.href = url;
                    pom.setAttribute('download', obj.options.csvFileName + '.csv');
                    document.body.appendChild(pom);
                    pom.click();
                    pom.remove();
                }
            }

            /**
             * Initializes a new history record for undo/redo
             *
             * @return null
             */
            obj.setHistory = function (changes) {
                if (obj.ignoreHistory != true) {
                    // Increment and get the current history index
                    var index = ++obj.historyIndex;

                    // Slice the array to discard undone changes
                    obj.history = (obj.history = obj.history.slice(0, index + 1));

                    // Keep history
                    obj.history[index] = changes;
                }
            }

            /**
             * Copy method
             *
             * @param bool highlighted - Get only highlighted cells
             * @param delimiter - \t default to keep compatibility with excel
             * @return string value
             */
            obj.copy = function (highlighted, delimiter, returnData) {
                if (!delimiter) {
                    delimiter = "\t";
                }

                // Controls
                var col = [];
                var colLabel = [];
                var row = [];
                var rowLabel = [];
                var x = obj.options.data[0].length
                var y = obj.options.data.length
                var tmp = '';

                // Reset container
                obj.style = [];

                // Go through the columns to get the data
                for (var j = 0; j < y; j++) {
                    col = [];
                    colLabel = [];

                    for (var i = 0; i < x; i++) {
                        // If cell is highlighted
                        if (!highlighted || obj.records[j][i].classList.contains('highlight')) {
                            // Values
                            var value = obj.options.data[j][i];
                            if (value.match && (value.match(/,/g) || value.match(/\n/) || value.match(/\"/))) {
                                value = value.replace(new RegExp('"', 'g'), '""');
                                value = '"' + value + '"';
                            }
                            col.push(value);

                            // Labels
                            var label = obj.records[j][i].innerHTML;
                            if (label.match && (label.match(/,/g) || label.match(/\n/) || label.match(/\"/))) {
                                // Scape double quotes
                                label = label.replace(new RegExp('"', 'g'), '""');
                                label = '"' + label + '"';
                            }
                            colLabel.push(label);

                            // Get style
                            tmp = obj.records[j][i].getAttribute('style');
                            obj.style.push(tmp ? tmp : '');
                        }
                    }

                    if (col.length) {
                        row.push(col.join(delimiter));
                    }
                    if (colLabel.length) {
                        rowLabel.push(colLabel.join(delimiter));
                    }
                }

                // Final string
                var str = row.join("\n");
                var strLabel = rowLabel.join("\n");

                // Create a hidden textarea to copy the values
                if (!returnData) {
                    if (obj.options.copyCompatibility == true) {
                        obj.textarea.value = strLabel;
                    } else {
                        obj.textarea.value = str;
                    }
                    obj.textarea.select();
                    jexcel.copyControls.enabled = false;
                    document.execCommand("copy");
                    jexcel.copyControls.enabled = true;
                }

                // Keep data
                obj.data = str;
                // Keep non visible information
                obj.hashString = obj.hash(obj.textarea.value);

                // Highlight
                /*for (var i = 0; i < obj.highlighted.length; i++) {
                    obj.highlighted[i].classList.add('copying');

                    if (obj.highlighted[i].classList.contains('highlight-top')) {
                        obj.highlighted[i].classList.add('copying-top');
                    }
                    if (obj.highlighted[i].classList.contains('highlight-right')) {
                        obj.highlighted[i].classList.add('copying-right');
                    }
                    if (obj.highlighted[i].classList.contains('highlight-bottom')) {
                        obj.highlighted[i].classList.add('copying-bottom');
                    }
                    if (obj.highlighted[i].classList.contains('highlight-left')) {
                        obj.highlighted[i].classList.add('copying-left');
                    }
                }*/

                return str;
            }

            /**
             * jExcel paste method
             *
             * @param integer row number
             * @return string value
             */
            obj.paste = function (x, y, data) {
                // Paste filter
                if (typeof (obj.options.onbeforepaste) == 'function') {
                    var data = obj.options.onbeforepaste(data);
                }

                // Controls
                var hash = obj.hash(data);
                var style = (hash == obj.hashString) ? obj.style : null;

                // Depending on the behavior
                if (obj.options.copyCompatibility == true && hash == obj.hashString) {
                    var data = obj.data;
                }

                // Split new line
                var data = obj.parseCSV(data, "\t");

                if (x != null && y != null && data) {
                    // Records
                    var i = 0;
                    var j = 0;
                    var records = [];
                    var newStyle = {};
                    var oldStyle = {};
                    var styleIndex = 0;

                    // Index
                    var colIndex = parseInt(x);
                    var rowIndex = parseInt(y);
                    var row = null;

                    // Go through the columns to get the data
                    while (row = data[j]) {
                        i = 0;
                        var colIndex = parseInt(x);

                        while (row[i] != null) {
                            // Update and keep history
                            var record = obj.updateCell(colIndex, rowIndex, row[i]);
                            // Keep history
                            records.push(record);
                            // Style
                            if (style) {
                                var columnName = jexcel.getColumnNameFromId([colIndex, rowIndex]);
                                newStyle[columnName] = style[styleIndex];
                                oldStyle[columnName] = obj.getStyle(columnName);
                                obj.records[rowIndex][colIndex].style = style[styleIndex];
                                styleIndex++
                            }
                            i++;
                            if (row[i] != null) {
                                if (colIndex >= obj.headers.length - 1) {
                                    obj.insertColumn();
                                }
                                colIndex = obj.right.get(colIndex, rowIndex);
                            }
                        }

                        j++;
                        if (data[j]) {
                            if (rowIndex >= obj.rows.length - 1) {
                                obj.insertRow();
                            }
                            var rowIndex = obj.down.get(x, rowIndex);
                        }
                    }

                    // Select the new cells
                    obj.updateSelectionFromCoords(x, y, colIndex, rowIndex);

                    // Update history
                    obj.setHistory({
                        action: 'setValue',
                        records: records,
                        selection: obj.selectedCell,
                        newStyle: newStyle,
                        oldStyle: oldStyle,
                    });

                    // Paste event
                    if (typeof (obj.options.onpaste) == 'function') {
                        obj.options.onpaste(el, records);
                    }

                    // Update table
                    obj.updateTable();
                }
            }

            /**
             * Process row
             */
            obj.historyProcessRow = function (type, historyRecord) {
                var rowIndex = (!historyRecord.insertBefore) ? historyRecord.rowNumber + 1 : historyRecord.rowNumber;

                if (obj.options.search == true) {
                    if (obj.results && obj.results.length != obj.rows.length) {
                        obj.resetSearch();
                    }
                }

                // Remove row
                if (type == 1) {
                    var numOfRows = historyRecord.numOfRows;
                    // Remove nodes
                    for (var j = rowIndex; j < (numOfRows + rowIndex); j++) {
                        obj.rows[j].remove();
                    }
                    // Remove references
                    obj.records.splice(rowIndex, numOfRows);
                    obj.options.data.splice(rowIndex, numOfRows);
                    obj.rows.splice(rowIndex, numOfRows);

                    obj.conditionalSelectionUpdate(1, rowIndex, (numOfRows + rowIndex) - 1);
                } else {
                    // Insert data
                    obj.records = jexcel.injectArray(obj.records, rowIndex, historyRecord.rowRecords);
                    obj.options.data = jexcel.injectArray(obj.options.data, rowIndex, historyRecord.rowData);
                    obj.rows = jexcel.injectArray(obj.rows, rowIndex, historyRecord.rowNode);
                    // Insert nodes
                    var index = 0
                    for (var j = rowIndex; j < (historyRecord.numOfRows + rowIndex); j++) {
                        obj.tbody.insertBefore(historyRecord.rowNode[index], obj.tbody.children[j]);
                        index++;
                    }
                }

                // Respect pagination
                if (obj.options.pagination > 0) {
                    obj.page(obj.pageNumber);
                }

                obj.updateTableReferences();
            }

            /**
             * Process column
             */
            obj.historyProcessColumn = function (type, historyRecord) {
                var columnIndex = (!historyRecord.insertBefore) ? historyRecord.columnNumber + 1 : historyRecord.columnNumber;

                // Remove column
                if (type == 1) {
                    var numOfColumns = historyRecord.numOfColumns;

                    obj.options.columns.splice(columnIndex, numOfColumns);
                    for (var i = columnIndex; i < (numOfColumns + columnIndex); i++) {
                        obj.headers[i].remove();
                        obj.colgroup[i].remove();
                    }
                    obj.headers.splice(columnIndex, numOfColumns);
                    obj.colgroup.splice(columnIndex, numOfColumns);
                    for (var j = 0; j < historyRecord.data.length; j++) {
                        for (var i = columnIndex; i < (numOfColumns + columnIndex); i++) {
                            obj.records[j][i].remove();
                        }
                        obj.records[j].splice(columnIndex, numOfColumns);
                        obj.options.data[j].splice(columnIndex, numOfColumns);
                    }

                    obj.conditionalSelectionUpdate(0, columnIndex, (numOfColumns + columnIndex) - 1);
                } else {
                    // Insert data
                    obj.options.columns = jexcel.injectArray(obj.options.columns, columnIndex, historyRecord.columns);
                    obj.headers = jexcel.injectArray(obj.headers, columnIndex, historyRecord.headers);
                    obj.colgroup = jexcel.injectArray(obj.colgroup, columnIndex, historyRecord.colgroup);

                    var index = 0
                    for (var i = columnIndex; i < (historyRecord.numOfColumns + columnIndex); i++) {
                        obj.headerContainer.insertBefore(historyRecord.headers[index], obj.headerContainer.children[i + 1]);
                        obj.colgroupContainer.insertBefore(historyRecord.colgroup[index], obj.colgroupContainer.children[i + 1]);
                        index++;
                    }

                    for (var j = 0; j < historyRecord.data.length; j++) {
                        obj.options.data[j] = jexcel.injectArray(obj.options.data[j], columnIndex, historyRecord.data[j]);
                        obj.records[j] = jexcel.injectArray(obj.records[j], columnIndex, historyRecord.records[j]);
                        var index = 0
                        for (var i = columnIndex; i < (historyRecord.numOfColumns + columnIndex); i++) {
                            obj.rows[j].insertBefore(historyRecord.records[j][index], obj.rows[j].children[i + 1]);
                            index++;
                        }
                    }
                }

                // Adjust nested headers
                if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                    // Flexible way to handle nestedheaders
                    if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                        for (var j = 0; j < obj.options.nestedHeaders.length; j++) {
                            if (type == 1) {
                                var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan) - historyRecord.numOfColumns;
                            } else {
                                var colspan = parseInt(obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan) + historyRecord.numOfColumns;
                            }
                            obj.options.nestedHeaders[j][obj.options.nestedHeaders[j].length - 1].colspan = colspan;
                            obj.thead.children[j].children[obj.thead.children[j].children.length - 1].setAttribute('colspan', colspan);
                        }
                    } else {
                        if (type == 1) {
                            var colspan = parseInt(obj.options.nestedHeaders[0].colspan) - historyRecord.numOfColumns;
                        } else {
                            var colspan = parseInt(obj.options.nestedHeaders[0].colspan) + historyRecord.numOfColumns;
                        }
                        obj.options.nestedHeaders[0].colspan = colspan;
                        obj.thead.children[0].children[obj.thead.children[0].children.length - 1].setAttribute('colspan', colspan);
                    }
                }

                obj.updateTableReferences();
            }

            /**
             * Undo last action
             */
            obj.undo = function () {
                // Ignore events and history
                var ignoreEvents = obj.ignoreEvents ? true : false;
                var ignoreHistory = obj.ignoreHistory ? true : false;

                obj.ignoreEvents = true;
                obj.ignoreHistory = true;

                // Records
                var records = [];

                // Update cells
                if (obj.historyIndex >= 0) {
                    // History
                    var historyRecord = obj.history[obj.historyIndex--];

                    if (historyRecord.action == 'insertRow') {
                        obj.historyProcessRow(1, historyRecord);
                    } else if (historyRecord.action == 'deleteRow') {
                        obj.historyProcessRow(0, historyRecord);
                    } else if (historyRecord.action == 'insertColumn') {
                        obj.historyProcessColumn(1, historyRecord);
                    } else if (historyRecord.action == 'deleteColumn') {
                        obj.historyProcessColumn(0, historyRecord);
                    } else if (historyRecord.action == 'moveRow') {
                        obj.moveRow(historyRecord.newValue, historyRecord.oldValue);
                    } else if (historyRecord.action == 'moveColumn') {
                        obj.moveColumn(historyRecord.newValue, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setMerge') {
                        obj.removeMerge(historyRecord.column, historyRecord.data);
                    } else if (historyRecord.action == 'setStyle') {
                        obj.setStyle(historyRecord.oldValue, null, null, 1);
                    } else if (historyRecord.action == 'setWidth') {
                        obj.setWidth(historyRecord.column, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setHeight') {
                        obj.setHeight(historyRecord.row, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setHeader') {
                        obj.setHeader(historyRecord.column, historyRecord.oldValue);
                    } else if (historyRecord.action == 'setComments') {
                        obj.setComments(historyRecord.column, historyRecord.oldValue[0], historyRecord.oldValue[1]);
                    } else if (historyRecord.action == 'orderBy') {
                        var rows = [];
                        for (var j = 0; j < historyRecord.rows.length; j++) {
                            rows[historyRecord.rows[j]] = j;
                        }
                        obj.updateOrderArrow(historyRecord.column, historyRecord.order ? 0 : 1);
                        obj.updateOrder(rows);
                    } else if (historyRecord.action == 'setValue') {
                        // Redo for changes in cells
                        for (var i = 0; i < historyRecord.records.length; i++) {
                            obj.updateCell(historyRecord.records[i].col, historyRecord.records[i].row, historyRecord.records[i].oldValue);
                            obj.updateFormulaChain(historyRecord.records[i].col, historyRecord.records[i].row, records);
                            if (historyRecord.oldStyle) {
                                obj.resetStyle(historyRecord.oldStyle, true);
                            }
                        }
                        // Update selection
                        if (!historyRecord.selection) {
                            historyRecord.selection = [historyRecord.records[0].col, historyRecord.records[0].row];
                        }
                        obj.updateSelectionFromCoords(historyRecord.selection[0], historyRecord.selection[1], historyRecord.selection[2], historyRecord.selection[3]);
                        // Update table
                        obj.updateTable();
                    }
                }
                obj.ignoreEvents = ignoreEvents;
                obj.ignoreHistory = ignoreHistory;
            }

            /**
             * Redo previously undone action
             */
            obj.redo = function () {
                // Ignore events and history
                var ignoreEvents = obj.ignoreEvents ? true : false;
                var ignoreHistory = obj.ignoreHistory ? true : false;

                obj.ignoreEvents = true;
                obj.ignoreHistory = true;

                // Records
                var records = [];

                // Update cells
                if (obj.historyIndex < obj.history.length - 1) {
                    // History
                    var historyRecord = obj.history[++obj.historyIndex];

                    if (historyRecord.action == 'insertRow') {
                        obj.historyProcessRow(0, historyRecord);
                    } else if (historyRecord.action == 'deleteRow') {
                        obj.historyProcessRow(1, historyRecord);
                    } else if (historyRecord.action == 'insertColumn') {
                        obj.historyProcessColumn(0, historyRecord);
                    } else if (historyRecord.action == 'deleteColumn') {
                        obj.historyProcessColumn(1, historyRecord);
                    } else if (historyRecord.action == 'moveRow') {
                        obj.moveRow(historyRecord.oldValue, historyRecord.newValue);
                    } else if (historyRecord.action == 'moveColumn') {
                        obj.moveColumn(historyRecord.oldValue, historyRecord.newValue);
                    } else if (historyRecord.action == 'setMerge') {
                        obj.setMerge(historyRecord.column, historyRecord.colspan, historyRecord.rowspan, 1);
                    } else if (historyRecord.action == 'setStyle') {
                        obj.setStyle(historyRecord.newValue, null, null, 1);
                    } else if (historyRecord.action == 'setWidth') {
                        obj.setWidth(historyRecord.column, historyRecord.newValue);
                    } else if (historyRecord.action == 'setHeight') {
                        obj.setHeight(historyRecord.row, historyRecord.newValue);
                    } else if (historyRecord.action == 'setHeader') {
                        obj.setHeader(historyRecord.column, historyRecord.newValue);
                    } else if (historyRecord.action == 'setComments') {
                        obj.setComments(historyRecord.column, historyRecord.newValue[0], historyRecord.newValue[1]);
                    } else if (historyRecord.action == 'orderBy') {
                        obj.updateOrderArrow(historyRecord.column, historyRecord.order);
                        obj.updateOrder(historyRecord.rows);
                    } else if (historyRecord.action == 'setValue') {
                        // Redo for changes in cells
                        for (var i = 0; i < historyRecord.records.length; i++) {
                            obj.updateCell(historyRecord.records[i].col, historyRecord.records[i].row, historyRecord.records[i].newValue);
                            obj.updateFormulaChain(historyRecord.records[i].col, historyRecord.records[i].row, records);
                            if (historyRecord.newStyle) {
                                obj.resetStyle(historyRecord.newStyle, true);
                            }
                        }

                        // Update selection
                        if (!historyRecord.selection) {
                            historyRecord.selection = [historyRecord.records[0].col, historyRecord.records[0].row];
                        }
                        obj.updateSelectionFromCoords(historyRecord.selection[0], historyRecord.selection[1], historyRecord.selection[2], historyRecord.selection[3]);
                        // Update table
                        obj.updateTable();
                    }
                }
                obj.ignoreEvents = ignoreEvents;
                obj.ignoreHistory = ignoreHistory;
            }

            /**
             * Get dropdown value from key
             */
            obj.getDropDownValue = function (column, key) {
                var value = [];

                if (obj.options.columns[column] && obj.options.columns[column].source) {
                    // Create array from source
                    var combo = [];
                    var source = obj.options.columns[column].source;

                    for (var i = 0; i < source.length; i++) {
                        if (typeof (source[i]) == 'object') {
                            combo[source[i].id] = source[i].name;
                        } else {
                            combo[source[i]] = source[i];
                        }
                    }

                    // Garante single multiple compatibily
                    var keys = ('' + key).split(';')

                    for (var i = 0; i < keys.length; i++) {
                        if (combo[keys[i]]) {
                            value.push(combo[keys[i]]);
                        }
                    }
                } else {
                    console.error('Invalid column');
                }

                return (value.length > 0) ? value.join('; ') : '';
            }

            /**
             * From starckoverflow contributions
             */
            obj.parseCSV = function (str, delimiter) {
                // Remove last line break
                str = str.replace(/\r?\n$|\r$|\n$/g, "");
                // Last caracter is the delimiter
                if (str.charCodeAt(str.length - 1) == 9) {
                    str += "\0";
                }
                // user-supplied delimeter or default comma
                delimiter = (delimiter || ",");

                var arr = [];
                var quote = false;  // true means we're inside a quoted field
                // iterate over each character, keep track of current row and column (of the returned array)
                for (var row = 0, col = 0, c = 0; c < str.length; c++) {
                    var cc = str[c], nc = str[c + 1];
                    arr[row] = arr[row] || [];
                    arr[row][col] = arr[row][col] || '';

                    // If the current character is a quotation mark, and we're inside a quoted field, and the next character is also a quotation mark, add a quotation mark to the current column and skip the next character
                    if (cc == '"' && quote && nc == '"') { arr[row][col] += cc; ++c; continue; }

                    // If it's just one quotation mark, begin/end quoted field
                    if (cc == '"') { quote = !quote; continue; }

                    // If it's a comma and we're not in a quoted field, move on to the next column
                    if (cc == delimiter && !quote) { ++col; continue; }

                    // If it's a newline (CRLF) and we're not in a quoted field, skip the next character and move on to the next row and move to column 0 of that new row
                    if (cc == '\r' && nc == '\n' && !quote) { ++row; col = 0; ++c; continue; }

                    // If it's a newline (LF or CR) and we're not in a quoted field, move on to the next row and move to column 0 of that new row
                    if (cc == '\n' && !quote) { ++row; col = 0; continue; }
                    if (cc == '\r' && !quote) { ++row; col = 0; continue; }

                    // Otherwise, append the current character to the current column
                    arr[row][col] += cc;
                }
                return arr;
            }

            obj.hash = function (str) {
                var hash = 0, i, chr;

                if (str.length === 0) {
                    return hash;
                } else {
                    for (i = 0; i < str.length; i++) {
                        chr = str.charCodeAt(i);
                        hash = ((hash << 5) - hash) + chr;
                        hash |= 0;
                    }
                }
                return hash;
            }

            /**
             * Initialization method
             */
            obj.init = function () {
                jexcel.current = obj;

                // Build handlers
                if (typeof (jexcel.build) == 'function') {
                    jexcel.build();
                    jexcel.build = null;
                }

                // Load the table data based on an CSV file
                if (obj.options.csv) {
                    // Loading
                    if (obj.options.loadingSpin == true) {
                        jSuites.loading.show();
                    }

                    // Load CSV file
                    jSuites.ajax({
                        url: obj.options.csv,
                        method: 'GET',
                        dataType: 'text',
                        success: function (result) {
                            // Convert data
                            var newData = obj.parseCSV(result, obj.options.csvDelimiter)

                            // Headers
                            if (obj.options.csvHeaders == true && newData.length > 0) {
                                var headers = newData.shift();
                                for (var i = 0; i < headers.length; i++) {
                                    if (!obj.options.columns[i]) {
                                        obj.options.columns[i] = { type: 'text', align: 'center', width: obj.options.defaultColWidth };
                                    }
                                    // Precedence over pre-configurated titles
                                    if (typeof obj.options.columns[i].title === 'undefined') {
                                        obj.options.columns[i].title = headers[i];
                                    }
                                }
                            }
                            // Data
                            obj.options.data = newData;
                            // Prepare table
                            obj.prepareTable();
                            // Hide spin
                            if (obj.options.loadingSpin == true) {
                                jSuites.loading.hide();
                            }
                        }
                    });
                } else if (obj.options.url) {
                    // Loading
                    if (obj.options.loadingSpin == true) {
                        jSuites.loading.show();
                    }

                    jSuites.ajax({
                        url: obj.options.url,
                        method: 'GET',
                        dataType: 'json',
                        success: function (result) {
                            // Data
                            obj.options.data = (result.data) ? result.data : result;
                            // Prepare table
                            obj.prepareTable();
                            // Hide spin
                            if (obj.options.loadingSpin == true) {
                                jSuites.loading.hide();
                            }
                        }
                    });
                } else {
                    // Prepare table
                    obj.prepareTable();
                }
            }

            // Context menu
            if (options && options.contextMenu != null) {
                obj.options.contextMenu = options.contextMenu;
            } else {
                obj.options.contextMenu = function (el, x, y, e) {
                    var items = [];

                    if (y == null) {
                        // Insert a new column
                        if (obj.options.allowInsertColumn == true) {
                            items.push({
                                title: obj.options.text.insertANewColumnBefore,
                                onclick: function () {
                                    obj.insertColumn(1, parseInt(x), 1);
                                }
                            });
                        }

                        if (obj.options.allowInsertColumn == true) {
                            items.push({
                                title: obj.options.text.insertANewColumnAfter,
                                onclick: function () {
                                    obj.insertColumn(1, parseInt(x), 0);
                                }
                            });
                        }

                        // Delete a column
                        if (obj.options.allowDeleteColumn == true) {
                            items.push({
                                title: obj.options.text.deleteSelectedColumns,
                                onclick: function () {
                                    obj.deleteColumn(obj.getSelectedColumns().length ? undefined : parseInt(x));
                                }
                            });
                        }

                        // Rename column
                        if (obj.options.allowRenameColumn == true) {
                            items.push({
                                title: obj.options.text.renameThisColumn,
                                onclick: function () {
                                    obj.setHeader(x);
                                }
                            });
                        }

                        // Sorting
                        if (obj.options.columnSorting == true) {
                            // Line
                            items.push({ type: 'line' });

                            items.push({
                                title: obj.options.text.orderAscending,
                                onclick: function () {
                                    obj.orderBy(x, 0);
                                }
                            });
                            items.push({
                                title: obj.options.text.orderDescending,
                                onclick: function () {
                                    obj.orderBy(x, 1);
                                }
                            });
                        }
                    } else {
                        // Insert new row
                        if (obj.options.allowInsertRow == true) {
                            items.push({
                                title: obj.options.text.insertANewRowBefore,
                                onclick: function () {
                                    obj.insertRow(1, parseInt(y), 1);
                                }
                            });

                            items.push({
                                title: obj.options.text.insertANewRowAfter,
                                onclick: function () {
                                    obj.insertRow(1, parseInt(y));
                                }
                            });
                        }

                        if (obj.options.allowDeleteRow == true) {
                            items.push({
                                title: obj.options.text.deleteSelectedRows,
                                onclick: function () {
                                    obj.deleteRow(obj.getSelectedRows().length ? undefined : parseInt(y));
                                }
                            });
                        }

                        if (x) {
                            if (obj.options.allowComments == true) {
                                items.push({ type: 'line' });

                                var title = obj.records[y][x].getAttribute('title') || '';

                                items.push({
                                    title: title ? obj.options.text.editComments : obj.options.text.addComments,
                                    onclick: function () {
                                        obj.setComments([x, y], prompt(obj.options.text.comments, title));
                                    }
                                });

                                if (title) {
                                    items.push({
                                        title: obj.options.text.clearComments,
                                        onclick: function () {
                                            obj.setComments([x, y], '');
                                        }
                                    });
                                }
                            }
                        }
                    }

                    // Line
                    items.push({ type: 'line' });

                    // Copy
                    items.push({
                        title: obj.options.text.copy,
                        shortcut: 'Ctrl + C',
                        onclick: function () {
                            obj.copy(true);
                        }
                    });

                    // Paste
                    if (navigator && navigator.clipboard) {
                        items.push({
                            title: obj.options.text.paste,
                            shortcut: 'Ctrl + V',
                            onclick: function () {
                                if (obj.selectedCell) {
                                    navigator.clipboard.readText().then(function (text) {
                                        if (text) {
                                            jexcel.current.paste(obj.selectedCell[0], obj.selectedCell[1], text);
                                        }
                                    });
                                }
                            }
                        });
                    }

                    // Save
                    if (obj.options.allowExport) {
                        items.push({
                            title: obj.options.text.saveAs,
                            shortcut: 'Ctrl + S',
                            onclick: function () {
                                obj.download(true);
                            }
                        });
                    }

                    // About
                    if (obj.options.about) {
                        items.push({
                            title: obj.options.text.about,
                            onclick: function () {
                                alert(obj.options.about);
                            }
                        });
                    }

                    return items;
                }
            }

            obj.scrollControls = function (e) {
                if (obj.options.lazyLoading == true) {
                    if (jexcel.timeControlLoading == null) {
                        jexcel.timeControlLoading = setTimeout(function () {
                            if (obj.content.scrollTop + obj.content.clientHeight >= obj.content.scrollHeight) {
                                if (obj.loadDown()) {
                                    if (obj.content.scrollTop + obj.content.clientHeight > obj.content.scrollHeight - 10) {
                                        obj.content.scrollTop = obj.content.scrollTop - obj.content.clientHeight;
                                    }
                                    obj.updateCornerPosition();
                                }
                            } else if (obj.content.scrollTop <= obj.content.clientHeight) {
                                if (obj.loadUp()) {
                                    if (obj.content.scrollTop < 10) {
                                        obj.content.scrollTop = obj.content.scrollTop + obj.content.clientHeight;
                                    }
                                    obj.updateCornerPosition();
                                }
                            }

                            jexcel.timeControlLoading = null;
                        }, 100);
                    }
                }

                // Close editor
                if (obj.options.lazyLoading == true || obj.options.tableOverflow == true) {
                    if (obj.edition && e.target.className.substr(0, 9) != 'jdropdown') {
                        obj.closeEditor(obj.edition[0], true);
                    }
                }
            }

            el.addEventListener("DOMMouseScroll", obj.scrollControls);
            el.addEventListener("mousewheel", obj.scrollControls);

            el.jexcel = obj;

            obj.init();

            return obj;
        });

        jexcel.current = null;
        jexcel.timeControl = null;
        jexcel.timeControlLoading = null;

        jexcel.destroy = function (element, destroyEventHandlers) {
            if (element.jexcel) {
                element.jexcel = null;
                element.innerHTML = '';

                if (destroyEventHandlers) {
                    document.removeEventListener("keydown", jexcel.keyDownControls);
                    document.removeEventListener("mouseup", jexcel.mouseUpControls);
                    document.removeEventListener("mousedown", jexcel.mouseDownControls);
                    document.removeEventListener("mousemove", jexcel.mouseMoveControls);
                    document.removeEventListener("mouseover", jexcel.mouseOverControls);
                    document.removeEventListener("dblclick", jexcel.doubleClickControls);
                    document.removeEventListener("copy", jexcel.copyControls);
                    document.removeEventListener("cut", jexcel.cutControls);
                    document.removeEventListener("paste", jexcel.pasteControls);
                    document.removeEventListener("contextmenu", jexcel.contextMenuControls);
                    document.removeEventListener("touchstart", jexcel.touchStartControls);
                    document.removeEventListener("touchend", jexcel.touchEndControls);
                    document.removeEventListener("touchcancel", jexcel.touchEndControls);
                    jexcel = null;
                }
            }
        }

        jexcel.build = function () {
            document.addEventListener("keydown", jexcel.keyDownControls);
            document.addEventListener("mouseup", jexcel.mouseUpControls);
            document.addEventListener("mousedown", jexcel.mouseDownControls);
            document.addEventListener("mousemove", jexcel.mouseMoveControls);
            document.addEventListener("mouseover", jexcel.mouseOverControls);
            document.addEventListener("dblclick", jexcel.doubleClickControls);
            document.addEventListener("copy", jexcel.copyControls);
            document.addEventListener("cut", jexcel.cutControls);
            document.addEventListener("paste", jexcel.pasteControls);
            document.addEventListener("contextmenu", jexcel.contextMenuControls);
            document.addEventListener("touchstart", jexcel.touchStartControls);
            document.addEventListener("touchend", jexcel.touchEndControls);
            document.addEventListener("touchcancel", jexcel.touchEndControls);
            document.addEventListener("touchmove", jexcel.touchEndControls);
        }

        /**
         * Helper injectArray
         */
        jexcel.injectArray = function (o, idx, arr) {
            return o.slice(0, idx).concat(arr).concat(o.slice(idx));
        }

        /**
         * Get letter based on a number
         *
         * @param integer i
         * @return string letter
         */
        jexcel.getColumnName = function (i) {
            var letter = '';
            if (i > 701) {
                letter += String.fromCharCode(64 + parseInt(i / 676));
                letter += String.fromCharCode(64 + parseInt((i % 676) / 26));
            } else if (i > 25) {
                letter += String.fromCharCode(64 + parseInt(i / 26));
            }
            letter += String.fromCharCode(65 + (i % 26));

            return letter;
        }

        /**
         * Convert excel like column to jexcel id
         *
         * @param string id
         * @return string id
         */
        jexcel.getIdFromColumnName = function (id, arr) {
            // Get the letters
            var t = /^[a-zA-Z]+/.exec(id);

            if (t) {
                // Base 26 calculation
                var code = 0;
                for (var i = 0; i < t[0].length; i++) {
                    code += parseInt(t[0].charCodeAt(i) - 64) * Math.pow(26, (t[0].length - 1 - i));
                }
                code--;
                // Make sure jexcel starts on zero
                if (code < 0) {
                    code = 0;
                }

                // Number
                var number = parseInt(/[0-9]+$/.exec(id));
                if (number > 0) {
                    number--;
                }

                if (arr == true) {
                    id = [code, number];
                } else {
                    id = code + '-' + number;
                }
            }

            return id;
        }

        /**
         * Convert jexcel id to excel like column name
         *
         * @param string id
         * @return string id
         */
        jexcel.getColumnNameFromId = function (cellId) {
            if (!Array.isArray(cellId)) {
                cellId = cellId.split('-');
            }

            return jexcel.getColumnName(parseInt(cellId[0])) + (parseInt(cellId[1]) + 1);
        }

        /**
         * Inside jexcel table
         *
         * @param string id
         * @return string id
         */
        jexcel.getElement = function (element) {
            var jexcelSection = 0;
            var jexcelElement = 0;

            function path(element) {
                if (element.className) {
                    if (element.classList.contains('jexcel_container')) {
                        jexcelElement = element;
                    }
                }

                if (element.tagName == 'THEAD') {
                    jexcelSection = 1;
                } else if (element.tagName == 'TBODY') {
                    jexcelSection = 2;
                }

                if (element.parentNode) {
                    path(element.parentNode);
                }
            }

            path(element);

            return [jexcelElement, jexcelSection];
        }

        /**
         * Events
         */
        jexcel.keyDownControls = function (e) {
            if (jexcel.current) {
                if (jexcel.current.edition) {
                    if (e.which == 27) {
                        // Escape
                        if (jexcel.current.edition) {
                            // Exit without saving
                            jexcel.current.closeEditor(jexcel.current.edition[0], false);
                        }
                        e.preventDefault();
                    } else if (e.which == 13) {
                        // Enter
                        if (jexcel.current.options.columns[jexcel.current.edition[2]].type == 'calendar') {
                            jexcel.current.editor[0].children[0].calendar.close(1);
                        } else if (jexcel.current.options.columns[jexcel.current.edition[2]].type == 'dropdown' ||
                            jexcel.current.options.columns[jexcel.current.edition[2]].type == 'autocomplete') {
                            // Do nothing
                        } else {
                            // Alt enter -> do not close editor
                            if ((jexcel.current.options.wordWrap == true ||
                                jexcel.current.options.columns[jexcel.current.edition[2]].wordWrap == true ||
                                jexcel.current.options.data[jexcel.current.edition[3]][jexcel.current.edition[2]].length > 200) && e.altKey) {
                                // Add new line to the editor
                                var editorTextarea = jexcel.current.edition[0].children[0];
                                var editorValue = jexcel.current.edition[0].children[0].value;
                                var editorIndexOf = editorTextarea.selectionStart;
                                editorValue = editorValue.slice(0, editorIndexOf) + "\n" + editorValue.slice(editorIndexOf);
                                editorTextarea.value = editorValue;
                                editorTextarea.focus();
                                editorTextarea.selectionStart = editorIndexOf + 1;
                                editorTextarea.selectionEnd = editorIndexOf + 1;
                            } else {
                                jexcel.current.edition[0].children[0].blur();
                            }
                        }
                    } else if (e.which == 9) {
                        // Tab
                        if (jexcel.current.options.columns[jexcel.current.edition[2]].type == 'calendar') {
                            jexcel.current.edition[0].children[0].calendar.close(1);
                        } else {
                            jexcel.current.edition[0].children[0].blur();
                        }
                    }
                }

                if (!jexcel.current.edition && jexcel.current.selectedCell) {
                    // Which key
                    if (e.which == 37) {
                        jexcel.current.left(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 39) {
                        jexcel.current.right(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 38) {
                        jexcel.current.up(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 40) {
                        jexcel.current.down(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 36) {
                        jexcel.current.first(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 35) {
                        jexcel.current.last(e.shiftKey, e.ctrlKey);
                        e.preventDefault();
                    } else if (e.which == 32) {
                        if (jexcel.current.options.editable == true) {
                            jexcel.current.setCheckRadioValue();
                        }
                        e.preventDefault();
                    } else if (e.which == 46) {
                        // Delete
                        if (jexcel.current.options.editable == true) {
                            if (jexcel.current.selectedRow) {
                                if (jexcel.current.options.allowDeleteRow == true) {
                                    if (confirm(jexcel.current.options.text.areYouSureToDeleteTheSelectedRows)) {
                                        jexcel.current.deleteRow();
                                    }
                                }
                            } else if (jexcel.current.selectedHeader) {
                                if (jexcel.current.options.allowDeleteColumn == true) {
                                    if (confirm(jexcel.current.options.text.areYouSureToDeleteTheSelectedColumns)) {
                                        jexcel.current.deleteColumn();
                                    }
                                }
                            } else {
                                // Change value
                                jexcel.current.setValue(jexcel.current.highlighted, '');
                            }
                        }
                    } else if (e.which == 13) {
                        // Move cursor
                        if (e.shiftKey) {
                            jexcel.current.up();
                        } else {
                            if (jexcel.current.options.allowInsertRow == true) {
                                if (jexcel.current.options.allowManualInsertRow == true) {
                                    if (jexcel.current.selectedCell[1] == jexcel.current.options.data.length - 1) {
                                        // New record in case selectedCell in the last row
                                        jexcel.current.insertRow();
                                    }
                                }
                            }

                            jexcel.current.down();
                        }
                        e.preventDefault();
                    } else if (e.which == 9) {
                        // Tab
                        if (e.shiftKey) {
                            jexcel.current.left();
                        } else {
                            if (jexcel.current.options.allowInsertColumn == true) {
                                if (jexcel.current.options.allowManualInsertColumn == true) {
                                    if (jexcel.current.selectedCell[0] == jexcel.current.options.data[0].length - 1) {
                                        // New record in case selectedCell in the last column
                                        jexcel.current.insertColumn();
                                    }
                                }
                            }

                            jexcel.current.right();
                        }
                        e.preventDefault();
                    } else {
                        if (!e.shiftKey) {
                            if (e.ctrlKey || e.metaKey) {
                                if (e.which == 65) {
                                    // Ctrl + A
                                    jexcel.current.selectAll();
                                    e.preventDefault();
                                } else if (e.which == 83) {
                                    // Ctrl + S
                                    jexcel.current.download();
                                    e.preventDefault();
                                } else if (e.which == 89) {
                                    // Ctrl + Y
                                    jexcel.current.redo();
                                    e.preventDefault();
                                } else if (e.which == 90) {
                                    // Ctrl + Z
                                    jexcel.current.undo();
                                    e.preventDefault();
                                }
                            } else {
                                if (jexcel.current.selectedCell) {
                                    if (jexcel.current.options.editable == true) {
                                        var rowId = jexcel.current.selectedCell[1];
                                        var columnId = jexcel.current.selectedCell[0];

                                        // If is not readonly
                                        if (jexcel.current.options.columns[columnId].type != 'readonly') {
                                            // Characters able to start a edition
                                            if (e.keyCode == 32) {
                                                // Space
                                                if (jexcel.current.options.columns[columnId].type == 'checkbox' ||
                                                    jexcel.current.options.columns[columnId].type == 'radio') {
                                                    e.preventDefault();
                                                } else {
                                                    // Start edition
                                                    jexcel.current.openEditor(jexcel.current.records[rowId][columnId], true);
                                                }
                                            } else if ((e.keyCode == 8) ||
                                                (e.keyCode >= 48 && e.keyCode <= 57) ||
                                                (e.keyCode >= 65 && e.keyCode <= 90) ||
                                                (e.keyCode >= 96 && e.keyCode <= 122) ||
                                                (e.keyCode >= 187 && e.keyCode <= 190)) {
                                                // Start edition
                                                jexcel.current.openEditor(jexcel.current.records[rowId][columnId], true);
                                                // Prevent entries in the calendar
                                                if (jexcel.current.options.columns[columnId].type == 'calendar') {
                                                    e.preventDefault();
                                                }
                                            } else if (e.keyCode == 113) {
                                                // Start edition with current content F2
                                                jexcel.current.openEditor(jexcel.current.records[rowId][columnId], false);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (e.target.classList.contains('jexcel_search')) {
                        if (jexcel.timeControl) {
                            clearTimeout(jexcel.timeControl);
                        }

                        jexcel.timeControl = setTimeout(function () {
                            jexcel.current.search(e.target.value);
                        }, 200);
                    }
                }
            }
        }

        jexcel.isMouseAction = false;

        jexcel.mouseDownControls = function (e) {
            e = e || window.event;
            if (e.buttons) {
                var mouseButton = e.buttons;
            } else if (e.button) {
                var mouseButton = e.button;
            } else {
                var mouseButton = e.which;
            }

            // Get elements
            var jexcelTable = jexcel.getElement(e.target);

            if (jexcelTable[0]) {
                if (jexcel.current != jexcelTable[0].jexcel) {
                    if (jexcel.current) {
                        jexcel.current.resetSelection();
                    }
                    jexcel.current = jexcelTable[0].jexcel;
                }
            } else {
                if (jexcel.current) {
                    jexcel.current.resetSelection(true);
                    jexcel.current = null;
                }
            }

            if (jexcel.current && mouseButton == 1) {
                if (e.target.classList.contains('jexcel_selectall')) {
                    if (jexcel.current) {
                        jexcel.current.selectAll();
                    }
                } else if (e.target.classList.contains('jexcel_corner')) {
                    if (jexcel.current.options.editable == true) {
                        jexcel.current.selectedCorner = true;
                    }
                } else {
                    // Header found
                    if (jexcelTable[1] == 1) {
                        var columnId = e.target.getAttribute('data-x');
                        if (columnId) {
                            // Update cursor
                            var info = e.target.getBoundingClientRect();
                            if (jexcel.current.options.columnResize == true && info.width - e.offsetX < 6) {
                                // Resize helper
                                jexcel.current.resizing = {
                                    mousePosition: e.pageX,
                                    column: columnId,
                                    width: info.width,
                                };

                                // Border indication
                                jexcel.current.headers[columnId].classList.add('resizing');
                                for (var j = 0; j < jexcel.current.records.length; j++) {
                                    jexcel.current.records[j][columnId].classList.add('resizing');
                                }
                            } else if (jexcel.current.options.columnDrag == true && info.height - e.offsetY < 6) {
                                if (jexcel.current.isColMerged(columnId).length) {
                                    console.error('JEXCEL: This column is part of a merged cell.');
                                } else {
                                    // Reset selection
                                    jexcel.current.resetSelection();
                                    // Drag helper
                                    jexcel.current.dragging = {
                                        element: e.target,
                                        column: columnId,
                                        destination: columnId,
                                    };
                                    // Border indication
                                    jexcel.current.headers[columnId].classList.add('dragging');
                                    for (var j = 0; j < jexcel.current.records.length; j++) {
                                        jexcel.current.records[j][columnId].classList.add('dragging');
                                    }
                                }
                            } else {
                                if (jexcel.current.selectedHeader && (e.shiftKey || e.ctrlKey)) {
                                    var o = jexcel.current.selectedHeader;
                                    var d = columnId;
                                } else {
                                    // Press to rename
                                    if (jexcel.current.selectedHeader == columnId && jexcel.current.options.allowRenameColumn == true) {
                                        jexcel.timeControl = setTimeout(function () {
                                            jexcel.current.setHeader(columnId);
                                        }, 800);
                                    }

                                    // Keep track of which header was selected first
                                    jexcel.current.selectedHeader = columnId;

                                    // Update selection single column
                                    var o = columnId;
                                    var d = columnId;
                                }

                                // Update selection
                                jexcel.current.updateSelectionFromCoords(o, 0, d, jexcel.current.options.data.length - 1);
                            }
                        } else {
                            if (e.target.parentNode.classList.contains('jexcel_nested')) {
                                var column = e.target.getAttribute('data-column').split(',');
                                var c1 = parseInt(column[0]);
                                var c2 = parseInt(column[column.length - 1]);
                                jexcel.current.updateSelectionFromCoords(c1, 0, c2, jexcel.current.options.data.length - 1);
                            }
                        }
                    } else {
                        jexcel.current.selectedHeader = false;
                    }

                    // Body found
                    if (jexcelTable[1] == 2) {
                        var rowId = e.target.getAttribute('data-y');

                        if (e.target.classList.contains('jexcel_row')) {
                            var info = e.target.getBoundingClientRect();
                            if (jexcel.current.options.rowResize == true && info.height - e.offsetY < 6) {
                                // Resize helper
                                jexcel.current.resizing = {
                                    element: e.target.parentNode,
                                    mousePosition: e.pageY,
                                    row: rowId,
                                    height: info.height,
                                };
                                // Border indication
                                e.target.parentNode.classList.add('resizing');
                            } else if (jexcel.current.options.rowDrag == true && info.width - e.offsetX < 6) {
                                if (jexcel.current.isRowMerged(rowId).length) {
                                    console.error('JEXCEL: This row is part of a merged cell');
                                } else if (jexcel.current.options.search == true && jexcel.current.results) {
                                    console.error('JEXCEL: Please clear your search before perform this action');
                                } else {
                                    // Reset selection
                                    jexcel.current.resetSelection();
                                    // Drag helper
                                    jexcel.current.dragging = {
                                        element: e.target.parentNode,
                                        row: rowId,
                                        destination: rowId,
                                    };
                                    // Border indication
                                    e.target.parentNode.classList.add('dragging');
                                }
                            } else {
                                if (jexcel.current.selectedRow && (e.shiftKey || e.ctrlKey)) {
                                    var o = jexcel.current.selectedRow;
                                    var d = rowId;
                                } else {
                                    // Keep track of which header was selected first
                                    jexcel.current.selectedRow = rowId;

                                    // Update selection single column
                                    var o = rowId;
                                    var d = rowId;
                                }

                                // Update selection
                                jexcel.current.updateSelectionFromCoords(0, o, jexcel.current.options.data[0].length - 1, d);
                            }
                        } else {
                            // Jclose
                            if (e.target.classList.contains('jclose') && e.target.clientWidth - e.offsetX < 50 && e.offsetY < 50) {
                                jexcel.current.closeEditor(jexcel.current.edition[0], true);
                            } else {
                                var getCellCoords = function (element) {
                                    var x = element.getAttribute('data-x');
                                    var y = element.getAttribute('data-y');
                                    if (x && y) {
                                        return [x, y];
                                    } else {
                                        if (element.parentNode) {
                                            return getCellCoords(element.parentNode);
                                        }
                                    }
                                };

                                var position = getCellCoords(e.target);
                                if (position) {
                                    var columnId = position[0];
                                    var rowId = position[1];
                                    // Close edition
                                    if (jexcel.current.edition) {
                                        if (jexcel.current.edition[2] != columnId || jexcel.current.edition[3] != rowId) {
                                            jexcel.current.closeEditor(jexcel.current.edition[0], true);
                                        }
                                    }

                                    if (!jexcel.current.edition) {
                                        // Update cell selection
                                        if (e.shiftKey) {
                                            jexcel.current.updateSelectionFromCoords(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], columnId, rowId);
                                        } else {
                                            jexcel.current.updateSelectionFromCoords(columnId, rowId);
                                        }
                                    }

                                    // No full row selected
                                    jexcel.current.selectedHeader = null;
                                    jexcel.current.selectedRow = null;
                                }
                            }
                        }
                    } else {
                        jexcel.current.selectedRow = false;
                    }

                    // Pagination
                    if (e.target.classList.contains('jexcel_page')) {
                        if (e.target.innerText == '<') {
                            jexcel.current.page(0);
                        } else if (e.target.innerText == '>') {
                            jexcel.current.page(e.target.getAttribute('title') - 1);
                        } else {
                            jexcel.current.page(e.target.innerText - 1);
                        }
                    }
                }

                if (jexcel.current.edition) {
                    jexcel.isMouseAction = false;
                } else {
                    jexcel.isMouseAction = true;
                }
            } else {
                jexcel.isMouseAction = false;
            }
        }

        jexcel.mouseUpControls = function (e) {
            if (jexcel.current) {
                // Update cell size
                if (jexcel.current.resizing) {
                    // Columns to be updated
                    if (jexcel.current.resizing.column) {
                        // Remove Class
                        jexcel.current.headers[jexcel.current.resizing.column].classList.remove('resizing');
                        var newWidth = jexcel.current.colgroup[jexcel.current.resizing.column].getAttribute('width');
                        jexcel.current.setWidth(jexcel.current.resizing.column, newWidth, jexcel.current.resizing.width);
                        // Remove border
                        jexcel.current.headers[jexcel.current.resizing.column].classList.remove('resizing');
                        for (var j = 0; j < jexcel.current.records.length; j++) {
                            jexcel.current.records[j][jexcel.current.resizing.column].classList.remove('resizing');
                        }
                    } else {
                        // Remove Class
                        jexcel.current.rows[jexcel.current.resizing.row].children[0].classList.remove('resizing');
                        var newHeight = jexcel.current.rows[jexcel.current.resizing.row].getAttribute('height');
                        jexcel.current.setHeight(jexcel.current.resizing.row, newHeight, jexcel.current.resizing.height);
                        // Remove border
                        jexcel.current.resizing.element.classList.remove('resizing');
                    }
                    // Reset resizing helper
                    jexcel.current.resizing = null;
                } else if (jexcel.current.dragging) {
                    // Reset dragging helper
                    if (jexcel.current.dragging) {
                        if (jexcel.current.dragging.column) {
                            // Target
                            var columnId = e.target.getAttribute('data-x');
                            // Remove move style
                            jexcel.current.headers[jexcel.current.dragging.column].classList.remove('dragging');
                            for (var j = 0; j < jexcel.current.rows.length; j++) {
                                jexcel.current.records[j][jexcel.current.dragging.column].classList.remove('dragging');
                            }
                            for (var i = 0; i < jexcel.current.headers.length; i++) {
                                jexcel.current.headers[i].classList.remove('dragging-left');
                                jexcel.current.headers[i].classList.remove('dragging-right');
                            }
                            // Update position
                            if (columnId) {
                                if (jexcel.current.dragging.column != jexcel.current.dragging.destination) {
                                    jexcel.current.moveColumn(jexcel.current.dragging.column, jexcel.current.dragging.destination);
                                }
                            }
                        } else {
                            var position = Array.prototype.indexOf.call(jexcel.current.dragging.element.parentNode.children, jexcel.current.dragging.element);
                            if (jexcel.current.dragging.row != position) {
                                jexcel.current.moveRow(jexcel.current.dragging.row, position, true);
                            }
                            jexcel.current.dragging.element.classList.remove('dragging');
                        }
                        jexcel.current.dragging = null;
                    }
                } else {
                    // Close any corner selection
                    if (jexcel.current.selectedCorner) {
                        jexcel.current.selectedCorner = false;

                        // Data to be copied
                        if (jexcel.current.selection.length > 0) {
                            // Copy data
                            jexcel.current.copyData(jexcel.current.selection[0], jexcel.current.selection[jexcel.current.selection.length - 1]);

                            // Remove selection
                            jexcel.current.removeCopySelection();
                        }
                    }
                }
            }

            // Clear any time control
            if (jexcel.timeControl) {
                clearTimeout(jexcel.timeControl);
                jexcel.timeControl = null;
            }

            // Mouse up
            jexcel.isMouseAction = false;
        }

        // Mouse move controls
        jexcel.mouseMoveControls = function (e) {
            e = e || window.event;
            if (e.buttons) {
                var mouseButton = e.buttons;
            } else if (e.button) {
                var mouseButton = e.button;
            } else {
                var mouseButton = e.which;
            }

            if (!mouseButton) {
                jexcel.isMouseAction = false;
            }

            if (jexcel.current) {
                if (jexcel.isMouseAction == true) {
                    // Resizing is ongoing
                    if (jexcel.current.resizing) {
                        if (jexcel.current.resizing.column) {
                            var width = e.pageX - jexcel.current.resizing.mousePosition;

                            if (jexcel.current.resizing.width + width > 0) {
                                var tempWidth = jexcel.current.resizing.width + width;
                                jexcel.current.colgroup[jexcel.current.resizing.column].setAttribute('width', tempWidth);

                                jexcel.current.updateCornerPosition();
                            }
                        } else {
                            var height = e.pageY - jexcel.current.resizing.mousePosition;

                            if (jexcel.current.resizing.height + height > 0) {
                                var tempHeight = jexcel.current.resizing.height + height;
                                jexcel.current.rows[jexcel.current.resizing.row].setAttribute('height', tempHeight);

                                jexcel.current.updateCornerPosition();
                            }
                        }
                    }
                } else {
                    var x = e.target.getAttribute('data-x');
                    var y = e.target.getAttribute('data-y');
                    var rect = e.target.getBoundingClientRect();

                    if (e.target.style.cursor) {
                        e.target.style.cursor = '';
                    }

                    if (e.target.parentNode.parentNode && e.target.parentNode.parentNode.className) {
                        if (e.target.parentNode.parentNode.classList.contains('resizable')) {
                            if (e.target && x && !y && (rect.width - (e.clientX - rect.left) < 6)) {
                                e.target.style.cursor = 'col-resize';
                            } else if (e.target && !x && y && (rect.height - (e.clientY - rect.top) < 6)) {
                                e.target.style.cursor = 'row-resize';
                            }
                        }

                        if (e.target.parentNode.parentNode.classList.contains('draggable')) {
                            if (e.target && !x && y && (rect.width - (e.clientX - rect.left) < 6)) {
                                e.target.style.cursor = 'move';
                            } else if (e.target && x && !y && (rect.height - (e.clientY - rect.top) < 6)) {
                                e.target.style.cursor = 'move';
                            }
                        }
                    }
                }
            }
        }

        jexcel.mouseOverControls = function (e) {
            e = e || window.event;
            if (e.buttons) {
                var mouseButton = e.buttons;
            } else if (e.button) {
                var mouseButton = e.button;
            } else {
                var mouseButton = e.which;
            }

            if (!mouseButton) {
                jexcel.isMouseAction = false;
            }

            if (jexcel.current && jexcel.isMouseAction == true) {
                // Get elements
                var jexcelTable = jexcel.getElement(e.target);

                if (jexcelTable[0]) {
                    // Avoid cross reference
                    if (jexcel.current != jexcelTable[0].jexcel) {
                        if (jexcel.current) {
                            return false;
                        }
                    }

                    var columnId = e.target.getAttribute('data-x');
                    var rowId = e.target.getAttribute('data-y');

                    if (jexcel.current.dragging) {
                        if (jexcel.current.dragging.column) {
                            if (columnId) {
                                if (jexcel.current.isColMerged(columnId).length) {
                                    console.error('JEXCEL: This column is part of a merged cell.');
                                } else {
                                    for (var i = 0; i < jexcel.current.headers.length; i++) {
                                        jexcel.current.headers[i].classList.remove('dragging-left');
                                        jexcel.current.headers[i].classList.remove('dragging-right');
                                    }

                                    if (jexcel.current.dragging.column == columnId) {
                                        jexcel.current.dragging.destination = parseInt(columnId);
                                    } else {
                                        if (e.target.clientWidth / 2 > e.offsetX) {
                                            if (jexcel.current.dragging.column < columnId) {
                                                jexcel.current.dragging.destination = parseInt(columnId) - 1;
                                            } else {
                                                jexcel.current.dragging.destination = parseInt(columnId);
                                            }
                                            jexcel.current.headers[columnId].classList.add('dragging-left');
                                        } else {
                                            if (jexcel.current.dragging.column < columnId) {
                                                jexcel.current.dragging.destination = parseInt(columnId);
                                            } else {
                                                jexcel.current.dragging.destination = parseInt(columnId) + 1;
                                            }
                                            jexcel.current.headers[columnId].classList.add('dragging-right');
                                        }
                                    }
                                }
                            }
                        } else {
                            if (rowId) {
                                if (jexcel.current.isRowMerged(rowId).length) {
                                    console.error('JEXCEL: This row is part of a merged cell.');
                                } else {
                                    var target = (e.target.clientHeight / 2 > e.offsetY) ? e.target.parentNode.nextSibling : e.target.parentNode;
                                    e.target.parentNode.parentNode.insertBefore(jexcel.current.dragging.element, target);
                                }
                            }
                        }
                    } else if (jexcel.current.resizing) {
                    } else {
                        // Header found
                        if (jexcelTable[1] == 1) {
                            if (jexcel.current.selectedHeader) {
                                var columnId = e.target.getAttribute('data-x');
                                var o = jexcel.current.selectedHeader;
                                var d = columnId;
                                // Update selection
                                jexcel.current.updateSelectionFromCoords(o, 0, d, jexcel.current.options.data.length - 1);
                            }
                        }

                        // Body found
                        if (jexcelTable[1] == 2) {
                            if (e.target.classList.contains('jexcel_row')) {
                                if (jexcel.current.selectedRow) {
                                    var o = jexcel.current.selectedRow;
                                    var d = rowId;
                                    // Update selection
                                    jexcel.current.updateSelectionFromCoords(0, o, jexcel.current.options.data[0].length - 1, d);
                                }
                            } else {
                                // Do not select edtion is in progress
                                if (!jexcel.current.edition) {
                                    if (columnId && rowId) {
                                        if (jexcel.current.selectedCorner) {
                                            jexcel.current.updateCopySelection(columnId, rowId);
                                        } else {
                                            if (jexcel.current.selectedCell) {
                                                jexcel.current.updateSelectionFromCoords(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], columnId, rowId);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Clear any time control
            if (jexcel.timeControl) {
                clearTimeout(jexcel.timeControl);
                jexcel.timeControl = null;
            }
        }

        /**
         * Double click event handler: controls the double click in the corner, cell edition or column re-ordering.
         */
        jexcel.doubleClickControls = function (e) {
            // Jexcel is selected
            if (jexcel.current) {
                // Corner action
                if (e.target.classList.contains('jexcel_corner')) {
                    // Any selected cells
                    if (jexcel.current.highlighted.length > 0) {
                        // Copy from this
                        var x1 = jexcel.current.highlighted[0].getAttribute('data-x');
                        var y1 = parseInt(jexcel.current.highlighted[jexcel.current.highlighted.length - 1].getAttribute('data-y')) + 1;
                        // Until this
                        var x2 = jexcel.current.highlighted[jexcel.current.highlighted.length - 1].getAttribute('data-x');
                        var y2 = jexcel.current.records.length - 1
                        // Execute copy
                        jexcel.current.copyData(jexcel.current.records[y1][x1], jexcel.current.records[y2][x2]);
                    }
                } else {
                    // Get table
                    var jexcelTable = jexcel.getElement(e.target);

                    // Double click over header
                    if (jexcelTable[1] == 1 && jexcel.current.options.columnSorting == true) {
                        // Check valid column header coords
                        var columnId = e.target.getAttribute('data-x');
                        if (columnId) {
                            jexcel.current.orderBy(columnId);
                        }
                    }

                    // Double click over body
                    if (jexcelTable[1] == 2 && jexcel.current.options.editable == true) {
                        if (!jexcel.current.edition) {
                            var getCellCoords = function (element) {
                                if (element.parentNode) {
                                    var x = element.getAttribute('data-x');
                                    var y = element.getAttribute('data-y');
                                    if (x && y) {
                                        return element;
                                    } else {
                                        return getCellCoords(element.parentNode);
                                    }
                                }
                            }
                            var cell = getCellCoords(e.target);
                            if (cell && cell.classList.contains('highlight')) {
                                jexcel.current.openEditor(cell);
                            }
                        }
                    }
                }
            }
        }

        jexcel.copyControls = function (e) {
            if (jexcel.current && jexcel.copyControls.enabled) {
                if (!jexcel.current.edition) {
                    jexcel.current.copy(true);
                }
            }
        }

        jexcel.cutControls = function (e) {
            if (jexcel.current) {
                if (!jexcel.current.edition) {
                    jexcel.current.copy(true);
                    if (jexcel.current.options.editable == true) {
                        jexcel.current.setValue(jexcel.current.highlighted, '');
                    }
                }
            }
        }

        jexcel.pasteControls = function (e) {
            if (jexcel.current && jexcel.current.selectedCell) {
                if (!jexcel.current.edition) {
                    if (e.clipboardData) {
                        if (jexcel.current.options.editable == true) {
                            jexcel.current.paste(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], e.clipboardData.getData('text'));
                        }
                        e.preventDefault();
                    }
                }
            }
        }

        jexcel.contextMenuControls = function (e) {
            e = e || window.event;
            if ("buttons" in e) {
                var mouseButton = e.buttons;
            } else {
                var mouseButton = e.which || e.button;
            }

            if (jexcel.current) {
                if (jexcel.current.edition) {
                    e.preventDefault();
                } else if (jexcel.current.options.contextMenu) {
                    jexcel.current.contextMenu.contextmenu.close();

                    if (jexcel.current) {
                        var x = e.target.getAttribute('data-x');
                        var y = e.target.getAttribute('data-y');

                        if (x || y) {
                            // Table found
                            var items = jexcel.current.options.contextMenu(jexcel.current, x, y, e);
                            // The id is depending on header and body
                            jexcel.current.contextMenu.contextmenu.open(e, items);
                            // Avoid the real one
                            e.preventDefault();
                        }
                    }
                }
            }
        }

        jexcel.touchStartControls = function (e) {
            var jexcelTable = jexcel.getElement(e.target);

            if (jexcelTable[0]) {
                if (jexcel.current != jexcelTable[0].jexcel) {
                    if (jexcel.current) {
                        jexcel.current.resetSelection();
                    }
                    jexcel.current = jexcelTable[0].jexcel;
                }
            } else {
                if (jexcel.current) {
                    jexcel.current.resetSelection();
                    jexcel.current = null;
                }
            }

            if (jexcel.current) {
                if (!jexcel.current.edition) {
                    var columnId = e.target.getAttribute('data-x');
                    var rowId = e.target.getAttribute('data-y');

                    if (columnId && rowId) {
                        jexcel.current.updateSelectionFromCoords(columnId, rowId);

                        jexcel.timeControl = setTimeout(function () {
                            jexcel.current.openEditor(e.target, false, e);
                        }, 500);
                    }
                }
            }
        }

        jexcel.touchEndControls = function (e) {
            // Clear any time control
            if (jexcel.timeControl) {
                clearTimeout(jexcel.timeControl);
                jexcel.timeControl = null;
            }
        }

        jexcel.copyControls.enabled = true;

        /**
         * Jquery Support
         */

        if (typeof (jQuery) != 'undefined') {
            (function ($) {
                var methods = {
                    init: function (init) {
                        methods = jexcel($(this).get(0), init)
                    }
                };

                $.fn.jexcel = function (method) {
                    if (methods[method]) {
                        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
                    } else if (typeof method === 'object' || !method) {
                        return methods.init.apply(this, arguments);
                    } else {
                        $.error('Method ' + method + ' does not exist on jQuery.tooltip');
                    }
                };

            })(jQuery);
        }

        /**
         * Jexcel extensions
         */

        jexcel.createTabs = function (tabs, result) {
            // Create tab container
            tabs.innerHTML = '';
            tabs.classList.add('jexcel_tabs');
            var spreadsheet = []
            var link = [];
            for (var i = 0; i < result.length; i++) {
                // Spreadsheet container
                spreadsheet[i] = document.createElement('div');
                spreadsheet[i].classList.add('jexcel_tab');
                // Tab link
                link[i] = document.createElement('div');
                link[i].classList.add('jexcel_tab_link');
                link[i].setAttribute('data-spreadsheet', i);
                link[i].innerHTML = result[i].sheetName;
                link[i].onclick = function () {
                    for (var j = 0; j < spreadsheet.length; j++) {
                        spreadsheet[j].style.display = 'none';
                        link[j].classList.remove('selected');
                    }
                    var i = this.getAttribute('data-spreadsheet');
                    spreadsheet[i].style.display = 'block';
                    link[i].classList.add('selected')
                }
                tabs.appendChild(link[i]);
            }

            // Append spreadsheet
            for (var i = 0; i < spreadsheet.length - 1; i++) {
                tabs.appendChild(spreadsheet[i]);
                jexcel(spreadsheet[i], result[i]);
            }

            // First tab
            spreadsheet[0].style.display = 'block';
            link[0].classList.add('selected')
        }

        jexcel.fromSpreadsheet = function (file, __callback) {
            var convert = function (workbook) {
                var spreadsheets = [];
                workbook.SheetNames.forEach(function (sheetName) {
                    var spreadsheet = {};
                    spreadsheet.rows = [];
                    spreadsheet.columns = [];
                    spreadsheet.data = [];
                    spreadsheet.style = {};
                    spreadsheet.sheetName = sheetName;

                    // Column widths
                    var temp = workbook.Sheets[sheetName]['!cols'];
                    if (temp && temp.length) {
                        for (var i = 0; i < temp.length; i++) {
                            spreadsheet.columns[i] = {};
                            spreadsheet.columns[i].width = temp[i].wpx + 'px';
                        }
                    }
                    // Rows heights
                    var temp = workbook.Sheets[sheetName]['!rows'];
                    if (temp && temp.length) {
                        for (var i = 0; i < temp.length; i++) {
                            if (temp[i] && temp[i].hpx) {
                                spreadsheet.rows[i] = {};
                                spreadsheet.rows[i].height = temp[i].hpx + 'px';
                            }
                        }
                    }
                    // Merge cells
                    var temp = workbook.Sheets[sheetName]['!merges'];
                    if (temp && temp.length > 0) {
                        spreadsheet.mergeCells = [];
                        for (var i = 0; i < temp.length; i++) {
                            var x1 = temp[i].s.c;
                            var y1 = temp[i].s.r;
                            var x2 = temp[i].e.c;
                            var y2 = temp[i].e.r;
                            var key = jexcel.getColumnNameFromId([x1, y1]);
                            spreadsheet.mergeCells[key] = [x2 - x1 + 1, y2 - y1 + 1];
                        }
                    }
                    // Data container
                    var max_x = 0;
                    var max_y = 0;
                    var temp = Object.keys(workbook.Sheets[sheetName]);
                    for (var i = 0; i < temp.length; i++) {
                        if (temp[i].substr(0, 1) != '!') {
                            var cell = workbook.Sheets[sheetName][temp[i]];
                            var info = jexcel.getIdFromColumnName(temp[i], true);
                            if (!spreadsheet.data[info[1]]) {
                                spreadsheet.data[info[1]] = [];
                            }
                            spreadsheet.data[info[1]][info[0]] = cell.f ? '=' + cell.f : cell.w;
                            if (max_x < info[0]) {
                                max_x = info[0];
                            }
                            if (max_y < info[1]) {
                                max_y = info[1];
                            }
                            // Style
                            if (cell.style && Object.keys(cell.style).length > 0) {
                                spreadsheet.style[temp[i]] = cell.style;
                            }
                            if (cell.s && cell.s.fgColor) {
                                if (spreadsheet.style[temp[i]]) {
                                    spreadsheet.style[temp[i]] += ';';
                                }
                                spreadsheet.style[temp[i]] += 'background-color:#' + cell.s.fgColor.rgb;
                            }
                        }
                    }
                    var numColumns = spreadsheet.columns;
                    for (var j = 0; j <= max_y; j++) {
                        for (var i = 0; i <= max_x; i++) {
                            if (!spreadsheet.data[j]) {
                                spreadsheet.data[j] = [];
                            }
                            if (!spreadsheet.data[j][i]) {
                                if (numColumns < i) {
                                    spreadsheet.data[j][i] = '';
                                }
                            }
                        }
                    }
                    spreadsheets.push(spreadsheet);
                });

                return spreadsheets;
            }

            var oReq;
            oReq = new XMLHttpRequest();
            oReq.open("GET", file, true);

            if (typeof Uint8Array !== 'undefined') {
                oReq.responseType = "arraybuffer";
                oReq.onload = function (e) {
                    var arraybuffer = oReq.response;
                    var data = new Uint8Array(arraybuffer);
                    var wb = XLSX.read(data, { type: "array", cellFormula: true, cellStyles: true });
                    __callback(convert(wb))
                };
            } else {
                oReq.setRequestHeader("Accept-Charset", "x-user-defined");
                oReq.onreadystatechange = function () {
                    if (oReq.readyState == 4 && oReq.status == 200) {
                        var ff = convertResponseBodyToText(oReq.responseBody);
                        var wb = XLSX.read(ff, { type: "binary", cellFormula: true, cellStyles: true });
                        __callback(convert(wb))
                    }
                };
            }

            oReq.send();
        }

        // Based on sutoiku work (https://github.com/sutoiku)

        var error = (function () {
            var exports = {};

            exports.nil = new Error('#NULL!');
            exports.div0 = new Error('#DIV/0!');
            exports.value = new Error('#VALUE!');
            exports.ref = new Error('#REF!');
            exports.name = new Error('#NAME?');
            exports.num = new Error('#NUM!');
            exports.na = new Error('#N/A');
            exports.error = new Error('#ERROR!');
            exports.data = new Error('#GETTING_DATA');

            return exports;
        })();

        var utils = (function () {
            var exports = {};

            exports.flattenShallow = function (array) {
                if (!array || !array.reduce) {
                    return array;
                }

                return array.reduce(function (a, b) {
                    var aIsArray = Array.isArray(a);
                    var bIsArray = Array.isArray(b);

                    if (aIsArray && bIsArray) {
                        return a.concat(b);
                    }
                    if (aIsArray) {
                        a.push(b);

                        return a;
                    }
                    if (bIsArray) {
                        return [a].concat(b);
                    }

                    return [a, b];
                });
            };

            exports.isFlat = function (array) {
                if (!array) {
                    return false;
                }

                for (var i = 0; i < array.length; ++i) {
                    if (Array.isArray(array[i])) {
                        return false;
                    }
                }

                return true;
            };

            exports.flatten = function () {
                var result = exports.argsToArray.apply(null, arguments);

                while (!exports.isFlat(result)) {
                    result = exports.flattenShallow(result);
                }

                return result;
            };

            exports.argsToArray = function (args) {
                var result = [];

                exports.arrayEach(args, function (value) {
                    result.push(value);
                });

                return result;
            };

            exports.numbers = function () {
                var possibleNumbers = this.flatten.apply(null, arguments);
                return possibleNumbers.filter(function (el) {
                    return typeof el === 'number';
                });
            };

            exports.cleanFloat = function (number) {
                var power = 1e14;
                return Math.round(number * power) / power;
            };

            exports.parseBool = function (bool) {
                if (typeof bool === 'boolean') {
                    return bool;
                }

                if (bool instanceof Error) {
                    return bool;
                }

                if (typeof bool === 'number') {
                    return bool !== 0;
                }

                if (typeof bool === 'string') {
                    var up = bool.toUpperCase();
                    if (up === 'TRUE') {
                        return true;
                    }

                    if (up === 'FALSE') {
                        return false;
                    }
                }

                if (bool instanceof Date && !isNaN(bool)) {
                    return true;
                }

                return error.value;
            };

            exports.parseNumber = function (string) {
                if (string === undefined || string === '') {
                    return error.value;
                }
                if (!isNaN(string)) {
                    return parseFloat(string);
                }

                return error.value;
            };

            exports.parseNumberArray = function (arr) {
                var len;

                if (!arr || (len = arr.length) === 0) {
                    return error.value;
                }

                var parsed;

                while (len--) {
                    parsed = exports.parseNumber(arr[len]);
                    if (parsed === error.value) {
                        return parsed;
                    }
                    arr[len] = parsed;
                }

                return arr;
            };

            exports.parseMatrix = function (matrix) {
                var n;

                if (!matrix || (n = matrix.length) === 0) {
                    return error.value;
                }
                var pnarr;

                for (var i = 0; i < matrix.length; i++) {
                    pnarr = exports.parseNumberArray(matrix[i]);
                    matrix[i] = pnarr;

                    if (pnarr instanceof Error) {
                        return pnarr;
                    }
                }

                return matrix;
            };

            var d1900 = new Date(Date.UTC(1900, 0, 1));
            exports.parseDate = function (date) {
                if (!isNaN(date)) {
                    if (date instanceof Date) {
                        return new Date(date);
                    }
                    var d = parseInt(date, 10);
                    if (d < 0) {
                        return error.num;
                    }
                    if (d <= 60) {
                        return new Date(d1900.getTime() + (d - 1) * 86400000);
                    }
                    return new Date(d1900.getTime() + (d - 2) * 86400000);
                }
                if (typeof date === 'string') {
                    date = new Date(date);
                    if (!isNaN(date)) {
                        return date;
                    }
                }
                return error.value;
            };

            exports.parseDateArray = function (arr) {
                var len = arr.length;
                var parsed;
                while (len--) {
                    parsed = this.parseDate(arr[len]);
                    if (parsed === error.value) {
                        return parsed;
                    }
                    arr[len] = parsed;
                }
                return arr;
            };

            exports.anyIsError = function () {
                var n = arguments.length;
                while (n--) {
                    if (arguments[n] instanceof Error) {
                        return true;
                    }
                }
                return false;
            };

            exports.arrayValuesToNumbers = function (arr) {
                var n = arr.length;
                var el;
                while (n--) {
                    el = arr[n];
                    if (typeof el === 'number') {
                        continue;
                    }
                    if (el === true) {
                        arr[n] = 1;
                        continue;
                    }
                    if (el === false) {
                        arr[n] = 0;
                        continue;
                    }
                    if (typeof el === 'string') {
                        var number = this.parseNumber(el);
                        if (number instanceof Error) {
                            arr[n] = 0;
                        } else {
                            arr[n] = number;
                        }
                    }
                }
                return arr;
            };

            exports.rest = function (array, idx) {
                idx = idx || 1;
                if (!array || typeof array.slice !== 'function') {
                    return array;
                }
                return array.slice(idx);
            };

            exports.initial = function (array, idx) {
                idx = idx || 1;
                if (!array || typeof array.slice !== 'function') {
                    return array;
                }
                return array.slice(0, array.length - idx);
            };

            exports.arrayEach = function (array, iteratee) {
                var index = -1, length = array.length;

                while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                        break;
                    }
                }

                return array;
            };

            exports.transpose = function (matrix) {
                if (!matrix) {
                    return error.value;
                }

                return matrix[0].map(function (col, i) {
                    return matrix.map(function (row) {
                        return row[i];
                    });
                });
            };

            return exports;
        })();

        jexcel.methods = {};

        jexcel.methods.datetime = (function () {
            var exports = {};

            var d1900 = new Date(1900, 0, 1);
            var WEEK_STARTS = [
                undefined,
                0,
                1,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                undefined,
                1,
                2,
                3,
                4,
                5,
                6,
                0
            ];
            var WEEK_TYPES = [
                [],
                [1, 2, 3, 4, 5, 6, 7],
                [7, 1, 2, 3, 4, 5, 6],
                [6, 0, 1, 2, 3, 4, 5],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [7, 1, 2, 3, 4, 5, 6],
                [6, 7, 1, 2, 3, 4, 5],
                [5, 6, 7, 1, 2, 3, 4],
                [4, 5, 6, 7, 1, 2, 3],
                [3, 4, 5, 6, 7, 1, 2],
                [2, 3, 4, 5, 6, 7, 1],
                [1, 2, 3, 4, 5, 6, 7]
            ];
            var WEEKEND_TYPES = [
                [],
                [6, 0],
                [0, 1],
                [1, 2],
                [2, 3],
                [3, 4],
                [4, 5],
                [5, 6],
                undefined,
                undefined,
                undefined, [0, 0],
                [1, 1],
                [2, 2],
                [3, 3],
                [4, 4],
                [5, 5],
                [6, 6]
            ];

            exports.DATE = function (year, month, day) {
                year = utils.parseNumber(year);
                month = utils.parseNumber(month);
                day = utils.parseNumber(day);
                if (utils.anyIsError(year, month, day)) {
                    return error.value;
                }
                if (year < 0 || month < 0 || day < 0) {
                    return error.num;
                }
                var date = new Date(year, month - 1, day);
                return date;
            };

            exports.DATEVALUE = function (date_text) {
                if (typeof date_text !== 'string') {
                    return error.value;
                }
                var date = Date.parse(date_text);
                if (isNaN(date)) {
                    return error.value;
                }
                if (date <= -2203891200000) {
                    return (date - d1900) / 86400000 + 1;
                }
                return (date - d1900) / 86400000 + 2;
            };

            exports.DAY = function (serial_number) {
                var date = utils.parseDate(serial_number);
                if (date instanceof Error) {
                    return date;
                }
                return date.getDate();
            };

            exports.DAYS = function (end_date, start_date) {
                end_date = utils.parseDate(end_date);
                start_date = utils.parseDate(start_date);
                if (end_date instanceof Error) {
                    return end_date;
                }
                if (start_date instanceof Error) {
                    return start_date;
                }
                return serial(end_date) - serial(start_date);
            };

            exports.DAYS360 = function (start_date, end_date, method) {
            };

            exports.EDATE = function (start_date, months) {
                start_date = utils.parseDate(start_date);
                if (start_date instanceof Error) {
                    return start_date;
                }
                if (isNaN(months)) {
                    return error.value;
                }
                months = parseInt(months, 10);
                start_date.setMonth(start_date.getMonth() + months);
                return serial(start_date);
            };

            exports.EOMONTH = function (start_date, months) {
                start_date = utils.parseDate(start_date);
                if (start_date instanceof Error) {
                    return start_date;
                }
                if (isNaN(months)) {
                    return error.value;
                }
                months = parseInt(months, 10);
                return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
            };

            exports.HOUR = function (serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getHours();
            };

            exports.INTERVAL = function (second) {
                if (typeof second !== 'number' && typeof second !== 'string') {
                    return error.value;
                } else {
                    second = parseInt(second, 10);
                }

                var year = Math.floor(second / 946080000);
                second = second % 946080000;
                var month = Math.floor(second / 2592000);
                second = second % 2592000;
                var day = Math.floor(second / 86400);
                second = second % 86400;

                var hour = Math.floor(second / 3600);
                second = second % 3600;
                var min = Math.floor(second / 60);
                second = second % 60;
                var sec = second;

                year = (year > 0) ? year + 'Y' : '';
                month = (month > 0) ? month + 'M' : '';
                day = (day > 0) ? day + 'D' : '';
                hour = (hour > 0) ? hour + 'H' : '';
                min = (min > 0) ? min + 'M' : '';
                sec = (sec > 0) ? sec + 'S' : '';

                return 'P' + year + month + day + 'T' + hour + min + sec;
            };

            exports.ISOWEEKNUM = function (date) {
                date = utils.parseDate(date);
                if (date instanceof Error) {
                    return date;
                }

                date.setHours(0, 0, 0);
                date.setDate(date.getDate() + 4 - (date.getDay() || 7));
                var yearStart = new Date(date.getFullYear(), 0, 1);
                return Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
            };

            exports.MINUTE = function (serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getMinutes();
            };

            exports.MONTH = function (serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getMonth() + 1;
            };

            exports.NETWORKDAYS = function (start_date, end_date, holidays) {
            };

            exports.NETWORKDAYS.INTL = function (start_date, end_date, weekend, holidays) {
            };

            exports.NOW = function () {
                return new Date();
            };

            exports.SECOND = function (serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getSeconds();
            };

            exports.TIME = function (hour, minute, second) {
                hour = utils.parseNumber(hour);
                minute = utils.parseNumber(minute);
                second = utils.parseNumber(second);
                if (utils.anyIsError(hour, minute, second)) {
                    return error.value;
                }
                if (hour < 0 || minute < 0 || second < 0) {
                    return error.num;
                }
                return (3600 * hour + 60 * minute + second) / 86400;
            };

            exports.TIMEVALUE = function (time_text) {
                time_text = utils.parseDate(time_text);
                if (time_text instanceof Error) {
                    return time_text;
                }
                return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400;
            };

            exports.TODAY = function () {
                return new Date();
            };

            exports.WEEKDAY = function (serial_number, return_type) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                if (return_type === undefined) {
                    return_type = 1;
                }
                var day = serial_number.getDay();
                return WEEK_TYPES[return_type][day];
            };

            exports.WEEKNUM = function (serial_number, return_type) {
            };

            exports.WORKDAY = function (start_date, days, holidays) {
            };

            exports.WORKDAY.INTL = function (start_date, days, weekend, holidays) {
            };

            exports.YEAR = function (serial_number) {
                serial_number = utils.parseDate(serial_number);
                if (serial_number instanceof Error) {
                    return serial_number;
                }
                return serial_number.getFullYear();
            };

            function isLeapYear(year) {
                return new Date(year, 1, 29).getMonth() === 1;
            }

            exports.YEARFRAC = function (start_date, end_date, basis) {
            };

            function serial(date) {
                var addOn = (date > -2203891200000) ? 2 : 1;
                return (date - d1900) / 86400000 + addOn;
            }

            return exports;
        })();

        jexcel.methods.database = (function () {
            var exports = {};

            function compact(array) {
                if (!array) {
                    return array;
                }
                var result = [];
                for (var i = 0; i < array.length; ++i) {
                    if (!array[i]) {
                        continue;
                    }
                    result.push(array[i]);
                }
                return result;
            }

            exports.FINDFIELD = function (database, title) {
                var index = null;
                for (var i = 0; i < database.length; i++) {
                    if (database[i][0] === title) {
                        index = i;
                        break;
                    }
                }

                // Return error if the input field title is incorrect
                if (index == null) {
                    return error.value;
                }
                return index;
            };

            function findResultIndex(database, criterias) {
                var matches = {};
                for (var i = 1; i < database[0].length; ++i) {
                    matches[i] = true;
                }
                var maxCriteriaLength = criterias[0].length;
                for (i = 1; i < criterias.length; ++i) {
                    if (criterias[i].length > maxCriteriaLength) {
                        maxCriteriaLength = criterias[i].length;
                    }
                }

                for (var k = 1; k < database.length; ++k) {
                    for (var l = 1; l < database[k].length; ++l) {
                        var currentCriteriaResult = false;
                        var hasMatchingCriteria = false;
                        for (var j = 0; j < criterias.length; ++j) {
                            var criteria = criterias[j];
                            if (criteria.length < maxCriteriaLength) {
                                continue;
                            }

                            var criteriaField = criteria[0];
                            if (database[k][0] !== criteriaField) {
                                continue;
                            }
                            hasMatchingCriteria = true;
                            for (var p = 1; p < criteria.length; ++p) {
                                currentCriteriaResult = currentCriteriaResult
                                    || eval(database[k][l] + criteria[p]); // jshint
                                // ignore:line
                            }
                        }
                        if (hasMatchingCriteria) {
                            matches[l] = matches[l] && currentCriteriaResult;
                        }
                    }
                }

                var result = [];
                for (var n = 0; n < database[0].length; ++n) {
                    if (matches[n]) {
                        result.push(n - 1);
                    }
                }
                return result;
            }

            // Database functions
            exports.DAVERAGE = function (database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var sum = 0;
                for (var i = 0; i < resultIndexes.length; i++) {
                    sum += targetFields[resultIndexes[i]];
                }
                return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
            };

            exports.DCOUNT = function (database, field, criteria) {
            };

            exports.DCOUNTA = function (database, field, criteria) {
            };

            exports.DGET = function (database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                // Return error if no record meets the criteria
                if (resultIndexes.length === 0) {
                    return error.value;
                }
                // Returns the #NUM! error value because more than one record meets the
                // criteria
                if (resultIndexes.length > 1) {
                    return error.num;
                }

                return targetFields[resultIndexes[0]];
            };

            exports.DMAX = function (database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var maxValue = targetFields[resultIndexes[0]];
                for (var i = 1; i < resultIndexes.length; i++) {
                    if (maxValue < targetFields[resultIndexes[i]]) {
                        maxValue = targetFields[resultIndexes[i]];
                    }
                }
                return maxValue;
            };

            exports.DMIN = function (database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var minValue = targetFields[resultIndexes[0]];
                for (var i = 1; i < resultIndexes.length; i++) {
                    if (minValue > targetFields[resultIndexes[i]]) {
                        minValue = targetFields[resultIndexes[i]];
                    }
                }
                return minValue;
            };

            exports.DPRODUCT = function (database, field, criteria) {
                // Return error if field is not a number and not a string
                if (isNaN(field) && (typeof field !== "string")) {
                    return error.value;
                }
                var resultIndexes = findResultIndex(database, criteria);
                var targetFields = [];
                if (typeof field === "string") {
                    var index = exports.FINDFIELD(database, field);
                    targetFields = utils.rest(database[index]);
                } else {
                    targetFields = utils.rest(database[field]);
                }
                var targetValues = [];
                for (var i = 0; i < resultIndexes.length; i++) {
                    targetValues[i] = targetFields[resultIndexes[i]];
                }
                targetValues = compact(targetValues);
                var result = 1;
                for (i = 0; i < targetValues.length; i++) {
                    result *= targetValues[i];
                }
                return result;
            };

            exports.DSTDEV = function (database, field, criteria) {
            };

            exports.DSTDEVP = function (database, field, criteria) {
            };

            exports.DSUM = function (database, field, criteria) {
            };

            exports.DVAR = function (database, field, criteria) {
            };

            exports.DVARP = function (database, field, criteria) {
            };

            exports.MATCH = function (lookupValue, lookupArray, matchType) {
                if (!lookupValue && !lookupArray) {
                    return error.na;
                }
                if (arguments.length === 2) {
                    matchType = 1;
                }
                if (!(lookupArray instanceof Array)) {
                    return error.na;
                }
                if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
                    return error.na;
                }

                var index;
                var indexValue;

                for (var idx = 0; idx < lookupArray.length; idx++) {
                    if (matchType === 1) {
                        if (lookupArray[idx] === lookupValue) {
                            return idx + 1;
                        } else if (lookupArray[idx] < lookupValue) {
                            if (!indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            } else if (lookupArray[idx] > indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            }
                        }
                    } else if (matchType === 0) {
                        if (typeof lookupValue === 'string') {
                            lookupValue = lookupValue.replace(/\?/g, '.');
                            if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
                                return idx + 1;
                            }
                        } else {
                            if (lookupArray[idx] === lookupValue) {
                                return idx + 1;
                            }
                        }
                    } else if (matchType === -1) {
                        if (lookupArray[idx] === lookupValue) {
                            return idx + 1;
                        } else if (lookupArray[idx] > lookupValue) {
                            if (!indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            } else if (lookupArray[idx] < indexValue) {
                                index = idx + 1;
                                indexValue = lookupArray[idx];
                            }
                        }
                    }
                }

                return index ? index : error.na;
            };

            return exports;
        })();

        jexcel.methods.engineering = (function () {
            var exports = {};

            function isValidBinaryNumber(number) {
                return (/^[01]{1,10}$/).test(number);
            }

            exports.BESSELI = function (x, n) {
            };

            exports.BESSELJ = function (x, n) {
            };

            exports.BESSELK = function (x, n) {
            };

            exports.BESSELY = function (x, n) {
            };

            exports.BIN2DEC = function (number) {
                // Return error if number is not binary or contains more than 10
                // characters (10 digits)
                if (!isValidBinaryNumber(number)) {
                    return error.num;
                }

                // Convert binary number to decimal
                var result = parseInt(number, 2);

                // Handle negative numbers
                var stringified = number.toString();
                if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
                    return parseInt(stringified.substring(1), 2) - 512;
                } else {
                    return result;
                }
            };

            exports.BIN2HEX = function (number, places) {
                // Return error if number is not binary or contains more than 10
                // characters (10 digits)
                if (!isValidBinaryNumber(number)) {
                    return error.num;
                }

                // Ignore places and return a 10-character hexadecimal number if number
                // is negative
                var stringified = number.toString();
                if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
                    return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
                }

                // Convert binary number to hexadecimal
                var result = parseInt(number, 2).toString(16);

                // Return hexadecimal number using the minimum number of characters
                // necessary if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.BIN2OCT = function (number, places) {
                // Return error if number is not binary or contains more than 10
                // characters (10 digits)
                if (!isValidBinaryNumber(number)) {
                    return error.num;
                }

                // Ignore places and return a 10-character octal number if number is
                // negative
                var stringified = number.toString();
                if (stringified.length === 10 && stringified.substring(0, 1) === '1') {
                    return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
                }

                // Convert binary number to octal
                var result = parseInt(number, 2).toString(8);

                // Return octal number using the minimum number of characters necessary
                // if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.BITAND = function (number1, number2) {
                // Return error if either number is a non-numeric value
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }

                // Return error if either number is less than 0
                if (number1 < 0 || number2 < 0) {
                    return error.num;
                }

                // Return error if either number is a non-integer
                if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
                    return error.num;
                }

                // Return error if either number is greater than (2^48)-1
                if (number1 > 281474976710655 || number2 > 281474976710655) {
                    return error.num;
                }

                // Return bitwise AND of two numbers
                return number1 & number2;
            };

            exports.BITLSHIFT = function (number, shift) {
                number = utils.parseNumber(number);
                shift = utils.parseNumber(shift);
                if (utils.anyIsError(number, shift)) {
                    return error.value;
                }

                // Return error if number is less than 0
                if (number < 0) {
                    return error.num;
                }

                // Return error if number is a non-integer
                if (Math.floor(number) !== number) {
                    return error.num;
                }

                // Return error if number is greater than (2^48)-1
                if (number > 281474976710655) {
                    return error.num;
                }

                // Return error if the absolute value of shift is greater than 53
                if (Math.abs(shift) > 53) {
                    return error.num;
                }

                // Return number shifted by shift bits to the left or to the right if
                // shift is negative
                return (shift >= 0) ? number << shift : number >> -shift;
            };

            exports.BITOR = function (number1, number2) {
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }

                // Return error if either number is less than 0
                if (number1 < 0 || number2 < 0) {
                    return error.num;
                }

                // Return error if either number is a non-integer
                if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
                    return error.num;
                }

                // Return error if either number is greater than (2^48)-1
                if (number1 > 281474976710655 || number2 > 281474976710655) {
                    return error.num;
                }

                // Return bitwise OR of two numbers
                return number1 | number2;
            };

            exports.BITRSHIFT = function (number, shift) {
                number = utils.parseNumber(number);
                shift = utils.parseNumber(shift);
                if (utils.anyIsError(number, shift)) {
                    return error.value;
                }

                // Return error if number is less than 0
                if (number < 0) {
                    return error.num;
                }

                // Return error if number is a non-integer
                if (Math.floor(number) !== number) {
                    return error.num;
                }

                // Return error if number is greater than (2^48)-1
                if (number > 281474976710655) {
                    return error.num;
                }

                // Return error if the absolute value of shift is greater than 53
                if (Math.abs(shift) > 53) {
                    return error.num;
                }

                // Return number shifted by shift bits to the right or to the left if
                // shift is negative
                return (shift >= 0) ? number >> shift : number << -shift;
            };

            exports.BITXOR = function (number1, number2) {
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }

                // Return error if either number is less than 0
                if (number1 < 0 || number2 < 0) {
                    return error.num;
                }

                // Return error if either number is a non-integer
                if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
                    return error.num;
                }

                // Return error if either number is greater than (2^48)-1
                if (number1 > 281474976710655 || number2 > 281474976710655) {
                    return error.num;
                }

                // Return bitwise XOR of two numbers
                return number1 ^ number2;
            };

            exports.COMPLEX = function (real, imaginary, suffix) {
                real = utils.parseNumber(real);
                imaginary = utils.parseNumber(imaginary);
                if (utils.anyIsError(real, imaginary)) {
                    return real;
                }

                // Set suffix
                suffix = (suffix === undefined) ? 'i' : suffix;

                // Return error if suffix is neither "i" nor "j"
                if (suffix !== 'i' && suffix !== 'j') {
                    return error.value;
                }

                // Return complex number
                if (real === 0 && imaginary === 0) {
                    return 0;
                } else if (real === 0) {
                    return (imaginary === 1) ? suffix : imaginary.toString() + suffix;
                } else if (imaginary === 0) {
                    return real.toString();
                } else {
                    var sign = (imaginary > 0) ? '+' : '';
                    return real.toString() + sign + ((imaginary === 1) ? suffix : imaginary.toString() + suffix);
                }
            };

            exports.CONVERT = function (number, from_unit, to_unit) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }

                // List of units supported by CONVERT and units defined by the
                // International System of Units
                // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion
                // ratio]
                var units = [
                    ["a.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
                    ["a.u. of charge", "e", null, "electric_charge", false, false, 1.60217653141414e-19],
                    ["a.u. of energy", "Eh", null, "energy", false, false, 4.35974417757576e-18],
                    ["a.u. of length", "a?", null, "length", false, false, 5.29177210818182e-11],
                    ["a.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
                    ["a.u. of time", "?/Eh", null, "time", false, false, 2.41888432650516e-17],
                    ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
                    ["ampere", "A", null, "electric_current", true, false, 1],
                    ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
                    ["ångström", "Å", ["ang"], "length", false, true, 1e-10],
                    ["are", "ar", null, "area", false, true, 100],
                    ["astronomical unit", "ua", null, "length", false, false, 1.49597870691667e-11],
                    ["bar", "bar", null, "pressure", false, false, 100000],
                    ["barn", "b", null, "area", false, false, 1e-28],
                    ["becquerel", "Bq", null, "radioactivity", true, false, 1],
                    ["bit", "bit", ["b"], "information", false, true, 1],
                    ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
                    ["byte", "byte", null, "information", false, true, 8],
                    ["candela", "cd", null, "luminous_intensity", true, false, 1],
                    ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
                    ["coulomb", "C", null, "electric_charge", true, false, 1],
                    ["cubic ångström", "ang3", ["ang^3"], "volume", false, true, 1e-30],
                    ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
                    ["cubic inch", "in3", ["in^3"], "volume", false, true, 0.000016387064],
                    ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 8.46786664623715e-47],
                    ["cubic metre", "m?", null, "volume", true, true, 1],
                    ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 4168181825.44058],
                    ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
                    ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 7.58660370370369e-8],
                    ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
                    ["cup", "cup", null, "volume", false, true, 0.0002365882365],
                    ["dalton", "Da", ["u"], "mass", false, false, 1.66053886282828e-27],
                    ["day", "d", ["day"], "time", false, true, 86400],
                    ["degree", "°", null, "angle", false, false, 0.0174532925199433],
                    ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
                    ["dyne", "dyn", ["dy"], "force", false, true, 0.00001],
                    ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
                    ["ell", "ell", null, "length", false, true, 1.143],
                    ["erg", "erg", ["e"], "energy", false, true, 1e-7],
                    ["farad", "F", null, "electric_capacitance", true, false, 1],
                    ["fluid ounce", "oz", null, "volume", false, true, 0.0000295735295625],
                    ["foot", "ft", null, "length", false, true, 0.3048],
                    ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
                    ["gal", "Gal", null, "acceleration", false, false, 0.01],
                    ["gallon", "gal", null, "volume", false, true, 0.003785411784],
                    ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
                    ["grain", "grain", null, "mass", false, true, 0.0000647989],
                    ["gram", "g", null, "mass", false, true, 0.001],
                    ["gray", "Gy", null, "absorbed_dose", true, false, 1],
                    ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
                    ["hectare", "ha", null, "area", false, true, 10000],
                    ["henry", "H", null, "inductance", true, false, 1],
                    ["hertz", "Hz", null, "frequency", true, false, 1],
                    ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
                    ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519.538],
                    ["hour", "h", ["hr"], "time", false, true, 3600],
                    ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 0.00454609],
                    ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
                    ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
                    ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
                    ["inch", "in", null, "length", false, true, 0.0254],
                    ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
                    ["IT calorie", "cal", null, "energy", false, true, 4.1868],
                    ["joule", "J", null, "energy", true, true, 1],
                    ["katal", "kat", null, "catalytic_activity", true, false, 1],
                    ["kelvin", "K", ["kel"], "temperature", true, true, 1],
                    ["kilogram", "kg", null, "mass", true, true, 1],
                    ["knot", "kn", null, "speed", false, true, 0.514444444444444],
                    ["light-year", "ly", null, "length", false, true, 9460730472580800],
                    ["litre", "L", ["l", "lt"], "volume", false, true, 0.001],
                    ["lumen", "lm", null, "luminous_flux", true, false, 1],
                    ["lux", "lx", null, "illuminance", true, false, 1],
                    ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
                    ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
                    ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 0.00027777777777778],
                    ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
                    ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
                    ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
                    ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
                    ["metre", "m", null, "length", true, true, 1],
                    ["miles per hour", "mph", null, "speed", false, true, 0.44704],
                    ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
                    ["minute", "?", null, "angle", false, false, 0.000290888208665722],
                    ["minute", "min", ["mn"], "time", false, true, 60],
                    ["modern teaspoon", "tspm", null, "volume", false, true, 0.000005],
                    ["mole", "mol", null, "amount_of_substance", true, false, 1],
                    ["morgen", "Morgen", null, "area", false, true, 2500],
                    ["n.u. of action", "?", null, "action", false, false, 1.05457168181818e-34],
                    ["n.u. of mass", "m?", null, "mass", false, false, 9.10938261616162e-31],
                    ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
                    ["n.u. of time", "?/(me?c??)", null, "time", false, false, 1.28808866778687e-21],
                    ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
                    ["newton", "N", null, "force", true, true, 1],
                    ["œrsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
                    ["ohm", "Ω", null, "electric_resistance", true, false, 1],
                    ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
                    ["pascal", "Pa", null, "pressure", true, false, 1],
                    ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
                    ["pferdestärke", "PS", null, "power", false, true, 735.49875],
                    ["phot", "ph", null, "illuminance", false, false, 0.0001],
                    ["pica (1/6 inch)", "pica", null, "length", false, true, 0.00035277777777778],
                    ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
                    ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
                    ["pond", "pond", null, "force", false, true, 0.00980665],
                    ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
                    ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
                    ["quart", "qt", null, "volume", false, true, 0.000946352946],
                    ["radian", "rad", null, "angle", true, false, 1],
                    ["second", "?", null, "angle", false, false, 0.00000484813681109536],
                    ["second", "s", ["sec"], "time", true, true, 1],
                    ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
                    ["siemens", "S", null, "electrical_conductance", true, false, 1],
                    ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
                    ["slug", "sg", null, "mass", false, true, 14.59390294],
                    ["square ångström", "ang2", ["ang^2"], "area", false, true, 1e-20],
                    ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
                    ["square inch", "in2", ["in^2"], "area", false, true, 0.00064516],
                    ["square light-year", "ly2", ["ly^2"], "area", false, true, 8.95054210748189e+31],
                    ["square meter", "m?", null, "area", true, true, 1],
                    ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988.110336],
                    ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
                    ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 0.00001792111111111],
                    ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
                    ["statute mile", "mi", null, "length", false, true, 1609.344],
                    ["steradian", "sr", null, "solid_angle", true, false, 1],
                    ["stilb", "sb", null, "luminance", false, false, 0.0001],
                    ["stokes", "St", null, "kinematic_viscosity", false, false, 0.0001],
                    ["stone", "stone", null, "mass", false, true, 6.35029318],
                    ["tablespoon", "tbs", null, "volume", false, true, 0.0000147868],
                    ["teaspoon", "tsp", null, "volume", false, true, 0.00000492892],
                    ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
                    ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
                    ["ton", "ton", null, "mass", false, true, 907.18474],
                    ["tonne", "t", null, "mass", false, false, 1000],
                    ["U.K. pint", "uk_pt", null, "volume", false, true, 0.00056826125],
                    ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
                    ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
                    ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 0.000473176473],
                    ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
                    ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
                    ["volt", "V", null, "voltage", true, false, 1],
                    ["watt", "W", null, "power", true, true, 1],
                    ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
                    ["weber", "Wb", null, "magnetic_flux", true, false, 1],
                    ["yard", "yd", null, "length", false, true, 0.9144],
                    ["year", "yr", null, "time", false, true, 31557600]
                ];

                // Binary prefixes
                // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived
                // from]
                var binary_prefixes = {
                    Yi: ["yobi", 80, 1208925819614629174706176, "Yi", "yotta"],
                    Zi: ["zebi", 70, 1180591620717411303424, "Zi", "zetta"],
                    Ei: ["exbi", 60, 1152921504606846976, "Ei", "exa"],
                    Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
                    Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
                    Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
                    Mi: ["mebi", 20, 1048576, "Mi", "mega"],
                    ki: ["kibi", 10, 1024, "ki", "kilo"]
                };

                // Unit prefixes
                // [Name, Multiplier, Abbreviation]
                var unit_prefixes = {
                    Y: ["yotta", 1e+24, "Y"],
                    Z: ["zetta", 1e+21, "Z"],
                    E: ["exa", 1e+18, "E"],
                    P: ["peta", 1e+15, "P"],
                    T: ["tera", 1e+12, "T"],
                    G: ["giga", 1e+09, "G"],
                    M: ["mega", 1e+06, "M"],
                    k: ["kilo", 1e+03, "k"],
                    h: ["hecto", 1e+02, "h"],
                    e: ["dekao", 1e+01, "e"],
                    d: ["deci", 1e-01, "d"],
                    c: ["centi", 1e-02, "c"],
                    m: ["milli", 1e-03, "m"],
                    u: ["micro", 1e-06, "u"],
                    n: ["nano", 1e-09, "n"],
                    p: ["pico", 1e-12, "p"],
                    f: ["femto", 1e-15, "f"],
                    a: ["atto", 1e-18, "a"],
                    z: ["zepto", 1e-21, "z"],
                    y: ["yocto", 1e-24, "y"]
                };

                // Initialize units and multipliers
                var from = null;
                var to = null;
                var base_from_unit = from_unit;
                var base_to_unit = to_unit;
                var from_multiplier = 1;
                var to_multiplier = 1;
                var alt;

                // Lookup from and to units
                for (var i = 0; i < units.length; i++) {
                    alt = (units[i][2] === null) ? [] : units[i][2];
                    if (units[i][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
                        from = units[i];
                    }
                    if (units[i][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
                        to = units[i];
                    }
                }

                // Lookup from prefix
                if (from === null) {
                    var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
                    var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];

                    // Handle dekao unit prefix (only unit prefix with two characters)
                    if (from_unit.substring(0, 2) === 'da') {
                        from_unit_prefix = ["dekao", 1e+01, "da"];
                    }

                    // Handle binary prefixes first (so that 'Yi' is processed before
                    // 'Y')
                    if (from_binary_prefix) {
                        from_multiplier = from_binary_prefix[2];
                        base_from_unit = from_unit.substring(2);
                    } else if (from_unit_prefix) {
                        from_multiplier = from_unit_prefix[1];
                        base_from_unit = from_unit.substring(from_unit_prefix[2].length);
                    }

                    // Lookup from unit
                    for (var j = 0; j < units.length; j++) {
                        alt = (units[j][2] === null) ? [] : units[j][2];
                        if (units[j][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
                            from = units[j];
                        }
                    }
                }

                // Lookup to prefix
                if (to === null) {
                    var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
                    var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];

                    // Handle dekao unit prefix (only unit prefix with two characters)
                    if (to_unit.substring(0, 2) === 'da') {
                        to_unit_prefix = ["dekao", 1e+01, "da"];
                    }

                    // Handle binary prefixes first (so that 'Yi' is processed before
                    // 'Y')
                    if (to_binary_prefix) {
                        to_multiplier = to_binary_prefix[2];
                        base_to_unit = to_unit.substring(2);
                    } else if (to_unit_prefix) {
                        to_multiplier = to_unit_prefix[1];
                        base_to_unit = to_unit.substring(to_unit_prefix[2].length);
                    }

                    // Lookup to unit
                    for (var k = 0; k < units.length; k++) {
                        alt = (units[k][2] === null) ? [] : units[k][2];
                        if (units[k][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
                            to = units[k];
                        }
                    }
                }

                // Return error if a unit does not exist
                if (from === null || to === null) {
                    return error.na;
                }

                // Return error if units represent different quantities
                if (from[3] !== to[3]) {
                    return error.na;
                }

                // Return converted number
                return number * from[6] * from_multiplier / (to[6] * to_multiplier);
            };

            exports.DEC2BIN = function (number, places) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }

                // Return error if number is not decimal, is lower than -512, or is
                // greater than 511
                if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
                    return error.num;
                }

                // Ignore places and return a 10-character binary number if number is
                // negative
                if (number < 0) {
                    return '1' + REPT('0', 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
                }

                // Convert decimal number to binary
                var result = parseInt(number, 10).toString(2);

                // Return binary number using the minimum number of characters necessary
                // if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.DEC2HEX = function (number, places) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }

                // Return error if number is not decimal, is lower than -549755813888,
                // or is greater than 549755813887
                if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
                    return error.num;
                }

                // Ignore places and return a 10-character hexadecimal number if number
                // is negative
                if (number < 0) {
                    return (1099511627776 + number).toString(16);
                }

                // Convert decimal number to hexadecimal
                var result = parseInt(number, 10).toString(16);

                // Return hexadecimal number using the minimum number of characters
                // necessary if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.DEC2OCT = function (number, places) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }

                // Return error if number is not decimal, is lower than -549755813888,
                // or is greater than 549755813887
                if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
                    return error.num;
                }

                // Ignore places and return a 10-character octal number if number is
                // negative
                if (number < 0) {
                    return (1073741824 + number).toString(8);
                }

                // Convert decimal number to octal
                var result = parseInt(number, 10).toString(8);

                // Return octal number using the minimum number of characters necessary
                // if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.DELTA = function (number1, number2) {
                // Set number2 to zero if undefined
                number2 = (number2 === undefined) ? 0 : number2;
                number1 = utils.parseNumber(number1);
                number2 = utils.parseNumber(number2);
                if (utils.anyIsError(number1, number2)) {
                    return error.value;
                }

                // Return delta
                return (number1 === number2) ? 1 : 0;
            };

            exports.ERF = function (lower_bound, upper_bound) {
            };

            exports.ERF.PRECISE = function () {
            };

            exports.ERFC = function (x) {
            };

            exports.ERFC.PRECISE = function () {
            };

            exports.GESTEP = function (number, step) {
                step = step || 0;
                number = utils.parseNumber(number);
                if (utils.anyIsError(step, number)) {
                    return number;
                }

                // Return delta
                return (number >= step) ? 1 : 0;
            };

            exports.HEX2BIN = function (number, places) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
                    return error.num;
                }

                // Check if number is negative
                var negative = (number.length === 10 && number.substring(0, 1).toLowerCase() === 'f') ? true : false;

                // Convert hexadecimal number to decimal
                var decimal = (negative) ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);

                // Return error if number is lower than -512 or greater than 511
                if (decimal < -512 || decimal > 511) {
                    return error.num;
                }

                // Ignore places and return a 10-character binary number if number is
                // negative
                if (negative) {
                    return '1' + REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
                }

                // Convert decimal number to binary
                var result = decimal.toString(2);

                // Return binary number using the minimum number of characters necessary
                // if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.HEX2DEC = function (number) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
                    return error.num;
                }

                // Convert hexadecimal number to decimal
                var decimal = parseInt(number, 16);

                // Return decimal number
                return (decimal >= 549755813888) ? decimal - 1099511627776 : decimal;
            };

            exports.HEX2OCT = function (number, places) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
                    return error.num;
                }

                // Convert hexadecimal number to decimal
                var decimal = parseInt(number, 16);

                // Return error if number is positive and greater than 0x1fffffff
                // (536870911)
                if (decimal > 536870911 && decimal < 1098974756864) {
                    return error.num;
                }

                // Ignore places and return a 10-character octal number if number is
                // negative
                if (decimal >= 1098974756864) {
                    return (decimal - 1098437885952).toString(8);
                }

                // Convert decimal number to octal
                var result = decimal.toString(8);

                // Return octal number using the minimum number of characters necessary
                // if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.IMABS = function (inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Return absolute value of complex number
                return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            };

            exports.IMAGINARY = function (inumber) {
                if (inumber === undefined || inumber === true || inumber === false) {
                    return error.value;
                }

                // Return 0 if inumber is equal to 0
                if (inumber === 0 || inumber === '0') {
                    return 0;
                }

                // Handle special cases
                if (['i', 'j'].indexOf(inumber) >= 0) {
                    return 1;
                }

                // Normalize imaginary coefficient
                inumber = inumber.replace('+i', '+1i').replace('-i', '-1i').replace('+j', '+1j').replace('-j', '-1j');

                // Lookup sign
                var plus = inumber.indexOf('+');
                var minus = inumber.indexOf('-');
                if (plus === 0) {
                    plus = inumber.indexOf('+', 1);
                }

                if (minus === 0) {
                    minus = inumber.indexOf('-', 1);
                }

                // Lookup imaginary unit
                var last = inumber.substring(inumber.length - 1, inumber.length);
                var unit = (last === 'i' || last === 'j');

                if (plus >= 0 || minus >= 0) {
                    // Return error if imaginary unit is neither i nor j
                    if (!unit) {
                        return error.num;
                    }

                    // Return imaginary coefficient of complex number
                    if (plus >= 0) {
                        return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
                            error.num :
                            Number(inumber.substring(plus + 1, inumber.length - 1));
                    } else {
                        return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
                            error.num :
                            -Number(inumber.substring(minus + 1, inumber.length - 1));
                    }
                } else {
                    if (unit) {
                        return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : inumber.substring(0, inumber.length - 1);
                    } else {
                        return (isNaN(inumber)) ? error.num : 0;
                    }
                }
            };

            exports.IMARGUMENT = function (inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Return error if inumber is equal to zero
                if (x === 0 && y === 0) {
                    return error.div0;
                }

                // Return PI/2 if x is equal to zero and y is positive
                if (x === 0 && y > 0) {
                    return Math.PI / 2;
                }

                // Return -PI/2 if x is equal to zero and y is negative
                if (x === 0 && y < 0) {
                    return -Math.PI / 2;
                }

                // Return zero if x is negative and y is equal to zero
                if (y === 0 && x > 0) {
                    return 0;
                }

                // Return zero if x is negative and y is equal to zero
                if (y === 0 && x < 0) {
                    return -Math.PI;
                }

                // Return argument of complex number
                if (x > 0) {
                    return Math.atan(y / x);
                } else if (x < 0 && y >= 0) {
                    return Math.atan(y / x) + Math.PI;
                } else {
                    return Math.atan(y / x) - Math.PI;
                }
            };

            exports.IMCONJUGATE = function (inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return conjugate of complex number
                return (y !== 0) ? exports.COMPLEX(x, -y, unit) : inumber;
            };

            exports.IMCOS = function (inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return cosine of complex number
                return exports.COMPLEX(Math.cos(x) * (Math.exp(y) + Math.exp(-y)) / 2, -Math.sin(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
            };

            exports.IMCOSH = function (inumber) {
                // Lookup real and imaginary coefficients using exports.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return hyperbolic cosine of complex number
                return exports.COMPLEX(Math.cos(y) * (Math.exp(x) + Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) - Math.exp(-x)) / 2, unit);
            };

            exports.IMCOT = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Return cotangent of complex number
                return exports.IMDIV(exports.IMCOS(inumber), exports.IMSIN(inumber));
            };

            exports.IMDIV = function (inumber1, inumber2) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var a = exports.IMREAL(inumber1);
                var b = exports.IMAGINARY(inumber1);
                var c = exports.IMREAL(inumber2);
                var d = exports.IMAGINARY(inumber2);

                if (utils.anyIsError(a, b, c, d)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit1 = inumber1.substring(inumber1.length - 1);
                var unit2 = inumber2.substring(inumber2.length - 1);
                var unit = 'i';
                if (unit1 === 'j') {
                    unit = 'j';
                } else if (unit2 === 'j') {
                    unit = 'j';
                }

                // Return error if inumber2 is null
                if (c === 0 && d === 0) {
                    return error.num;
                }

                // Return exponential of complex number
                var den = c * c + d * d;
                return exports.COMPLEX((a * c + b * d) / den, (b * c - a * d) / den, unit);
            };

            exports.IMEXP = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return exponential of complex number
                var e = Math.exp(x);
                return exports.COMPLEX(e * Math.cos(y), e * Math.sin(y), unit);
            };

            exports.IMLN = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return exponential of complex number
                return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)), Math.atan(y / x), unit);
            };

            exports.IMLOG10 = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return exponential of complex number
                return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(10), Math.atan(y / x) / Math.log(10), unit);
            };

            exports.IMLOG2 = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return exponential of complex number
                return exports.COMPLEX(Math.log(Math.sqrt(x * x + y * y)) / Math.log(2), Math.atan(y / x) / Math.log(2), unit);
            };

            exports.IMPOWER = function (inumber, number) {
                number = utils.parseNumber(number);
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);
                if (utils.anyIsError(number, x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Calculate power of modulus
                var p = Math.pow(exports.IMABS(inumber), number);

                // Calculate argument
                var t = exports.IMARGUMENT(inumber);

                // Return exponential of complex number
                return exports.COMPLEX(p * Math.cos(number * t), p * Math.sin(number * t), unit);
            };

            exports.IMPRODUCT = function () {
                // Initialize result
                var result = arguments[0];

                // Loop on all numbers
                for (var i = 1; i < arguments.length; i++) {
                    // Lookup coefficients of two complex numbers
                    var a = exports.IMREAL(result);
                    var b = exports.IMAGINARY(result);
                    var c = exports.IMREAL(arguments[i]);
                    var d = exports.IMAGINARY(arguments[i]);

                    if (utils.anyIsError(a, b, c, d)) {
                        return error.value;
                    }

                    // Complute product of two complex numbers
                    result = exports.COMPLEX(a * c - b * d, a * d + b * c);
                }

                // Return product of complex numbers
                return result;
            };

            exports.IMREAL = function (inumber) {
                if (inumber === undefined || inumber === true || inumber === false) {
                    return error.value;
                }

                // Return 0 if inumber is equal to 0
                if (inumber === 0 || inumber === '0') {
                    return 0;
                }

                // Handle special cases
                if (['i', '+i', '1i', '+1i', '-i', '-1i', 'j', '+j', '1j', '+1j', '-j', '-1j'].indexOf(inumber) >= 0) {
                    return 0;
                }

                // Lookup sign
                var plus = inumber.indexOf('+');
                var minus = inumber.indexOf('-');
                if (plus === 0) {
                    plus = inumber.indexOf('+', 1);
                }
                if (minus === 0) {
                    minus = inumber.indexOf('-', 1);
                }

                // Lookup imaginary unit
                var last = inumber.substring(inumber.length - 1, inumber.length);
                var unit = (last === 'i' || last === 'j');

                if (plus >= 0 || minus >= 0) {
                    // Return error if imaginary unit is neither i nor j
                    if (!unit) {
                        return error.num;
                    }

                    // Return real coefficient of complex number
                    if (plus >= 0) {
                        return (isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1))) ?
                            error.num :
                            Number(inumber.substring(0, plus));
                    } else {
                        return (isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1))) ?
                            error.num :
                            Number(inumber.substring(0, minus));
                    }
                } else {
                    if (unit) {
                        return (isNaN(inumber.substring(0, inumber.length - 1))) ? error.num : 0;
                    } else {
                        return (isNaN(inumber)) ? error.num : inumber;
                    }
                }
            };

            exports.IMSEC = function (inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }

                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Return secant of complex number
                return exports.IMDIV('1', exports.IMCOS(inumber));
            };

            exports.IMSECH = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Return hyperbolic secant of complex number
                return exports.IMDIV('1', exports.IMCOSH(inumber));
            };

            exports.IMSIN = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return sine of complex number
                return exports.COMPLEX(Math.sin(x) * (Math.exp(y) + Math.exp(-y)) / 2, Math.cos(x) * (Math.exp(y) - Math.exp(-y)) / 2, unit);
            };

            exports.IMSINH = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Return hyperbolic sine of complex number
                return exports.COMPLEX(Math.cos(y) * (Math.exp(x) - Math.exp(-x)) / 2, Math.sin(y) * (Math.exp(x) + Math.exp(-x)) / 2, unit);
            };

            exports.IMSQRT = function (inumber) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit = inumber.substring(inumber.length - 1);
                unit = (unit === 'i' || unit === 'j') ? unit : 'i';

                // Calculate power of modulus
                var s = Math.sqrt(exports.IMABS(inumber));

                // Calculate argument
                var t = exports.IMARGUMENT(inumber);

                // Return exponential of complex number
                return exports.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
            };

            exports.IMCSC = function (inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }

                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.num;
                }

                // Return cosecant of complex number
                return exports.IMDIV('1', exports.IMSIN(inumber));
            };

            exports.IMCSCH = function (inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }

                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                // Return error if either coefficient is not a number
                if (utils.anyIsError(x, y)) {
                    return error.num;
                }

                // Return hyperbolic cosecant of complex number
                return exports.IMDIV('1', exports.IMSINH(inumber));
            };

            exports.IMSUB = function (inumber1, inumber2) {
                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var a = this.IMREAL(inumber1);
                var b = this.IMAGINARY(inumber1);
                var c = this.IMREAL(inumber2);
                var d = this.IMAGINARY(inumber2);

                if (utils.anyIsError(a, b, c, d)) {
                    return error.value;
                }

                // Lookup imaginary unit
                var unit1 = inumber1.substring(inumber1.length - 1);
                var unit2 = inumber2.substring(inumber2.length - 1);
                var unit = 'i';
                if (unit1 === 'j') {
                    unit = 'j';
                } else if (unit2 === 'j') {
                    unit = 'j';
                }

                // Return _ of two complex numbers
                return this.COMPLEX(a - c, b - d, unit);
            };

            exports.IMSUM = function () {
                var args = utils.flatten(arguments);

                // Initialize result
                var result = args[0];

                // Loop on all numbers
                for (var i = 1; i < args.length; i++) {
                    // Lookup coefficients of two complex numbers
                    var a = this.IMREAL(result);
                    var b = this.IMAGINARY(result);
                    var c = this.IMREAL(args[i]);
                    var d = this.IMAGINARY(args[i]);

                    if (utils.anyIsError(a, b, c, d)) {
                        return error.value;
                    }

                    // Complute product of two complex numbers
                    result = this.COMPLEX(a + c, b + d);
                }

                // Return sum of complex numbers
                return result;
            };

            exports.IMTAN = function (inumber) {
                // Return error if inumber is a logical value
                if (inumber === true || inumber === false) {
                    return error.value;
                }

                // Lookup real and imaginary coefficients using Formula.js
                // [http://formulajs.org]
                var x = exports.IMREAL(inumber);
                var y = exports.IMAGINARY(inumber);

                if (utils.anyIsError(x, y)) {
                    return error.value;
                }

                // Return tangent of complex number
                return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
            };

            exports.OCT2BIN = function (number, places) {
                // Return error if number is not hexadecimal or contains more than ten
                // characters (10 digits)
                if (!/^[0-7]{1,10}$/.test(number)) {
                    return error.num;
                }

                // Check if number is negative
                var negative = (number.length === 10 && number.substring(0, 1) === '7') ? true : false;

                // Convert octal number to decimal
                var decimal = (negative) ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);

                // Return error if number is lower than -512 or greater than 511
                if (decimal < -512 || decimal > 511) {
                    return error.num;
                }

                // Ignore places and return a 10-character binary number if number is
                // negative
                if (negative) {
                    return '1' + REPT('0', 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
                }

                // Convert decimal number to binary
                var result = decimal.toString(2);

                // Return binary number using the minimum number of characters necessary
                // if places is undefined
                if (typeof places === 'undefined') {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            exports.OCT2DEC = function (number) {
                // Return error if number is not octal or contains more than ten
                // characters (10 digits)
                if (!/^[0-7]{1,10}$/.test(number)) {
                    return error.num;
                }

                // Convert octal number to decimal
                var decimal = parseInt(number, 8);

                // Return decimal number
                return (decimal >= 536870912) ? decimal - 1073741824 : decimal;
            };

            exports.OCT2HEX = function (number, places) {
                // Return error if number is not octal or contains more than ten
                // characters (10 digits)
                if (!/^[0-7]{1,10}$/.test(number)) {
                    return error.num;
                }

                // Convert octal number to decimal
                var decimal = parseInt(number, 8);

                // Ignore places and return a 10-character octal number if number is
                // negative
                if (decimal >= 536870912) {
                    return 'ff' + (decimal + 3221225472).toString(16);
                }

                // Convert decimal number to hexadecimal
                var result = decimal.toString(16);

                // Return hexadecimal number using the minimum number of characters
                // necessary if places is undefined
                if (places === undefined) {
                    return result;
                } else {
                    // Return error if places is nonnumeric
                    if (isNaN(places)) {
                        return error.value;
                    }

                    // Return error if places is negative
                    if (places < 0) {
                        return error.num;
                    }

                    // Truncate places in case it is not an integer
                    places = Math.floor(places);

                    // Pad return value with leading 0s (zeros) if necessary (using
                    // Underscore.string)
                    return (places >= result.length) ? REPT('0', places - result.length) + result : error.num;
                }
            };

            return exports;
        })();

        jexcel.methods.financial = (function () {
            var exports = {};

            function validDate(d) {
                return d && d.getTime && !isNaN(d.getTime());
            }

            function ensureDate(d) {
                return (d instanceof Date) ? d : new Date(d);
            }

            exports.ACCRINT = function (issue, first, settlement, rate, par, frequency, basis) {
                // Return error if either date is invalid
                issue = ensureDate(issue);
                first = ensureDate(first);
                settlement = ensureDate(settlement);
                if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
                    return '#VALUE!';
                }

                // Return error if either rate or par are lower than or equal to zero
                if (rate <= 0 || par <= 0) {
                    return '#NUM!';
                }

                // Return error if frequency is neither 1, 2, or 4
                if ([1, 2, 4].indexOf(frequency) === -1) {
                    return '#NUM!';
                }

                // Return error if basis is neither 0, 1, 2, 3, or 4
                if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
                    return '#NUM!';
                }

                // Return error if settlement is before or equal to issue
                if (settlement <= issue) {
                    return '#NUM!';
                }

                // Set default values
                par = par || 0;
                basis = basis || 0;

                // Compute accrued interest
                return par * rate * YEARFRAC(issue, settlement, basis);
            };

            exports.ACCRINTM = null;

            exports.AMORDEGRC = null;

            exports.AMORLINC = null;

            exports.COUPDAYBS = null;

            exports.COUPDAYS = null;

            exports.COUPDAYSNC = null;

            exports.COUPNCD = null;

            exports.COUPNUM = null;

            exports.COUPPCD = null;

            exports.CUMIPMT = function (rate, periods, value, start, end, type) {
                // Credits: algorithm inspired by Apache OpenOffice
                // Credits: Hannes Stiebitzhofer for the translations of function and
                // variable names
                // Requires exports.FV() and exports.PMT() from exports.js
                // [http://stoic.com/exports/]

                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                value = utils.parseNumber(value);
                if (utils.anyIsError(rate, periods, value)) {
                    return error.value;
                }

                // Return error if either rate, periods, or value are lower than or
                // equal to zero
                if (rate <= 0 || periods <= 0 || value <= 0) {
                    return error.num;
                }

                // Return error if start < 1, end < 1, or start > end
                if (start < 1 || end < 1 || start > end) {
                    return error.num;
                }

                // Return error if type is neither 0 nor 1
                if (type !== 0 && type !== 1) {
                    return error.num;
                }

                // Compute cumulative interest
                var payment = exports.PMT(rate, periods, value, 0, type);
                var interest = 0;

                if (start === 1) {
                    if (type === 0) {
                        interest = -value;
                        start++;
                    }
                }

                for (var i = start; i <= end; i++) {
                    if (type === 1) {
                        interest += exports.FV(rate, i - 2, payment, value, 1) - payment;
                    } else {
                        interest += exports.FV(rate, i - 1, payment, value, 0);
                    }
                }
                interest *= rate;

                // Return cumulative interest
                return interest;
            };

            exports.CUMPRINC = function (rate, periods, value, start, end, type) {
                // Credits: algorithm inspired by Apache OpenOffice
                // Credits: Hannes Stiebitzhofer for the translations of function and
                // variable names

                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                value = utils.parseNumber(value);
                if (utils.anyIsError(rate, periods, value)) {
                    return error.value;
                }

                // Return error if either rate, periods, or value are lower than or
                // equal to zero
                if (rate <= 0 || periods <= 0 || value <= 0) {
                    return error.num;
                }

                // Return error if start < 1, end < 1, or start > end
                if (start < 1 || end < 1 || start > end) {
                    return error.num;
                }

                // Return error if type is neither 0 nor 1
                if (type !== 0 && type !== 1) {
                    return error.num;
                }

                // Compute cumulative principal
                var payment = exports.PMT(rate, periods, value, 0, type);
                var principal = 0;
                if (start === 1) {
                    if (type === 0) {
                        principal = payment + value * rate;
                    } else {
                        principal = payment;
                    }
                    start++;
                }
                for (var i = start; i <= end; i++) {
                    if (type > 0) {
                        principal += payment - (exports.FV(rate, i - 2, payment, value, 1) - payment) * rate;
                    } else {
                        principal += payment - exports.FV(rate, i - 1, payment, value, 0) * rate;
                    }
                }

                // Return cumulative principal
                return principal;
            };

            exports.DB = function (cost, salvage, life, period, month) {
                // Initialize month
                month = (month === undefined) ? 12 : month;

                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                period = utils.parseNumber(period);
                month = utils.parseNumber(month);
                if (utils.anyIsError(cost, salvage, life, period, month)) {
                    return error.value;
                }

                // Return error if any of the parameters is negative
                if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
                    return error.num;
                }

                // Return error if month is not an integer between 1 and 12
                if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
                    return error.num;
                }

                // Return error if period is greater than life
                if (period > life) {
                    return error.num;
                }

                // Return 0 (zero) if salvage is greater than or equal to cost
                if (salvage >= cost) {
                    return 0;
                }

                // Rate is rounded to three decimals places
                var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);

                // Compute initial depreciation
                var initial = cost * rate * month / 12;

                // Compute total depreciation
                var total = initial;
                var current = 0;
                var ceiling = (period === life) ? life - 1 : period;
                for (var i = 2; i <= ceiling; i++) {
                    current = (cost - total) * rate;
                    total += current;
                }

                // Depreciation for the first and last periods are special cases
                if (period === 1) {
                    // First period
                    return initial;
                } else if (period === life) {
                    // Last period
                    return (cost - total) * rate;
                } else {
                    return current;
                }
            };

            exports.DDB = function (cost, salvage, life, period, factor) {
                // Initialize factor
                factor = (factor === undefined) ? 2 : factor;

                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                period = utils.parseNumber(period);
                factor = utils.parseNumber(factor);
                if (utils.anyIsError(cost, salvage, life, period, factor)) {
                    return error.value;
                }

                // Return error if any of the parameters is negative or if factor is
                // null
                if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
                    return error.num;
                }

                // Return error if period is greater than life
                if (period > life) {
                    return error.num;
                }

                // Return 0 (zero) if salvage is greater than or equal to cost
                if (salvage >= cost) {
                    return 0;
                }

                // Compute depreciation
                var total = 0;
                var current = 0;
                for (var i = 1; i <= period; i++) {
                    current = Math.min((cost - total) * (factor / life), (cost - salvage - total));
                    total += current;
                }

                // Return depreciation
                return current;
            };

            exports.DISC = null;

            exports.DOLLARDE = function (dollar, fraction) {
                // Credits: algorithm inspired by Apache OpenOffice

                dollar = utils.parseNumber(dollar);
                fraction = utils.parseNumber(fraction);
                if (utils.anyIsError(dollar, fraction)) {
                    return error.value;
                }

                // Return error if fraction is negative
                if (fraction < 0) {
                    return error.num;
                }

                // Return error if fraction is greater than or equal to 0 and less than
                // 1
                if (fraction >= 0 && fraction < 1) {
                    return error.div0;
                }

                // Truncate fraction if it is not an integer
                fraction = parseInt(fraction, 10);

                // Compute integer part
                var result = parseInt(dollar, 10);

                // Add decimal part
                result += (dollar % 1) * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;

                // Round result
                var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
                result = Math.round(result * power) / power;

                // Return converted dollar price
                return result;
            };

            exports.DOLLARFR = function (dollar, fraction) {
                // Credits: algorithm inspired by Apache OpenOffice

                dollar = utils.parseNumber(dollar);
                fraction = utils.parseNumber(fraction);
                if (utils.anyIsError(dollar, fraction)) {
                    return error.value;
                }

                // Return error if fraction is negative
                if (fraction < 0) {
                    return error.num;
                }

                // Return error if fraction is greater than or equal to 0 and less than
                // 1
                if (fraction >= 0 && fraction < 1) {
                    return error.div0;
                }

                // Truncate fraction if it is not an integer
                fraction = parseInt(fraction, 10);

                // Compute integer part
                var result = parseInt(dollar, 10);

                // Add decimal part
                result += (dollar % 1) * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;

                // Return converted dollar price
                return result;
            };

            exports.DURATION = null;

            exports.EFFECT = function (rate, periods) {
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                if (utils.anyIsError(rate, periods)) {
                    return error.value;
                }

                // Return error if rate <=0 or periods < 1
                if (rate <= 0 || periods < 1) {
                    return error.num;
                }

                // Truncate periods if it is not an integer
                periods = parseInt(periods, 10);

                // Return effective annual interest rate
                return Math.pow(1 + rate / periods, periods) - 1;
            };

            exports.FV = function (rate, periods, payment, value, type) {
                // Credits: algorithm inspired by Apache OpenOffice

                value = value || 0;
                type = type || 0;

                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                payment = utils.parseNumber(payment);
                value = utils.parseNumber(value);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, payment, value, type)) {
                    return error.value;
                }

                // Return future value
                var result;
                if (rate === 0) {
                    result = value + payment * periods;
                } else {
                    var term = Math.pow(1 + rate, periods);
                    if (type === 1) {
                        result = value * term + payment * (1 + rate) * (term - 1) / rate;
                    } else {
                        result = value * term + payment * (term - 1) / rate;
                    }
                }
                return -result;
            };

            exports.FVSCHEDULE = function (principal, schedule) {
                principal = utils.parseNumber(principal);
                schedule = utils.parseNumberArray(utils.flatten(schedule));
                if (utils.anyIsError(principal, schedule)) {
                    return error.value;
                }

                var n = schedule.length;
                var future = principal;

                // Apply all interests in schedule
                for (var i = 0; i < n; i++) {
                    // Apply scheduled interest
                    future *= 1 + schedule[i];
                }

                // Return future value
                return future;
            };

            exports.INTRATE = null;

            exports.IPMT = function (rate, period, periods, present, future, type) {
                // Credits: algorithm inspired by Apache OpenOffice

                future = future || 0;
                type = type || 0;

                rate = utils.parseNumber(rate);
                period = utils.parseNumber(period);
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, period, periods, present, future, type)) {
                    return error.value;
                }

                // Compute payment
                var payment = exports.PMT(rate, periods, present, future, type);

                // Compute interest
                var interest;
                if (period === 1) {
                    if (type === 1) {
                        interest = 0;
                    } else {
                        interest = -present;
                    }
                } else {
                    if (type === 1) {
                        interest = exports.FV(rate, period - 2, payment, present, 1) - payment;
                    } else {
                        interest = exports.FV(rate, period - 1, payment, present, 0);
                    }
                }

                // Return interest
                return interest * rate;
            };

            exports.IRR = function (values, guess) {
                // Credits: algorithm inspired by Apache OpenOffice

                guess = guess || 0;

                values = utils.parseNumberArray(utils.flatten(values));
                guess = utils.parseNumber(guess);
                if (utils.anyIsError(values, guess)) {
                    return error.value;
                }

                // Calculates the resulting amount
                var irrResult = function (values, dates, rate) {
                    var r = rate + 1;
                    var result = values[0];
                    for (var i = 1; i < values.length; i++) {
                        result += values[i] / Math.pow(r, (dates[i] - dates[0]) / 365);
                    }
                    return result;
                };

                // Calculates the first derivation
                var irrResultDeriv = function (values, dates, rate) {
                    var r = rate + 1;
                    var result = 0;
                    for (var i = 1; i < values.length; i++) {
                        var frac = (dates[i] - dates[0]) / 365;
                        result -= frac * values[i] / Math.pow(r, frac + 1);
                    }
                    return result;
                };

                // Initialize dates and check that values contains at least one positive
                // value and one negative value
                var dates = [];
                var positive = false;
                var negative = false;
                for (var i = 0; i < values.length; i++) {
                    dates[i] = (i === 0) ? 0 : dates[i - 1] + 365;
                    if (values[i] > 0) {
                        positive = true;
                    }
                    if (values[i] < 0) {
                        negative = true;
                    }
                }

                // Return error if values does not contain at least one positive value
                // and one negative value
                if (!positive || !negative) {
                    return error.num;
                }

                // Initialize guess and resultRate
                guess = (guess === undefined) ? 0.1 : guess;
                var resultRate = guess;

                // Set maximum epsilon for end of iteration
                var epsMax = 1e-10;

                // Implement Newton's method
                var newRate, epsRate, resultValue;
                var contLoop = true;
                do {
                    resultValue = irrResult(values, dates, resultRate);
                    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
                    epsRate = Math.abs(newRate - resultRate);
                    resultRate = newRate;
                    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
                } while (contLoop);

                // Return internal rate of return
                return resultRate;
            };

            exports.ISPMT = function (rate, period, periods, value) {
                rate = utils.parseNumber(rate);
                period = utils.parseNumber(period);
                periods = utils.parseNumber(periods);
                value = utils.parseNumber(value);
                if (utils.anyIsError(rate, period, periods, value)) {
                    return error.value;
                }

                // Return interest
                return value * rate * (period / periods - 1);
            };

            exports.MDURATION = null;

            exports.MIRR = function (values, finance_rate, reinvest_rate) {
                values = utils.parseNumberArray(utils.flatten(values));
                finance_rate = utils.parseNumber(finance_rate);
                reinvest_rate = utils.parseNumber(reinvest_rate);
                if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
                    return error.value;
                }

                // Initialize number of values
                var n = values.length;

                // Lookup payments (negative values) and incomes (positive values)
                var payments = [];
                var incomes = [];
                for (var i = 0; i < n; i++) {
                    if (values[i] < 0) {
                        payments.push(values[i]);
                    } else {
                        incomes.push(values[i]);
                    }
                }

                // Return modified internal rate of return
                var num = -exports.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n - 1);
                var den = exports.NPV(finance_rate, payments) * (1 + finance_rate);
                return Math.pow(num / den, 1 / (n - 1)) - 1;
            };

            exports.NOMINAL = function (rate, periods) {
                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                if (utils.anyIsError(rate, periods)) {
                    return error.value;
                }

                // Return error if rate <=0 or periods < 1
                if (rate <= 0 || periods < 1) {
                    return error.num;
                }

                // Truncate periods if it is not an integer
                periods = parseInt(periods, 10);

                // Return nominal annual interest rate
                return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
            };

            exports.NPER = function (rate, payment, present, future, type) {
                type = (type === undefined) ? 0 : type;
                future = (future === undefined) ? 0 : future;

                rate = utils.parseNumber(rate);
                payment = utils.parseNumber(payment);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, payment, present, future, type)) {
                    return error.value;
                }

                // Return number of periods
                var num = payment * (1 + rate * type) - future * rate;
                var den = (present * rate + payment * (1 + rate * type));
                return Math.log(num / den) / Math.log(1 + rate);
            };

            exports.NPV = function () {
                var args = utils.parseNumberArray(utils.flatten(arguments));
                if (args instanceof Error) {
                    return args;
                }

                // Lookup rate
                var rate = args[0];

                // Initialize net present value
                var value = 0;

                // Loop on all values
                for (var j = 1; j < args.length; j++) {
                    value += args[j] / Math.pow(1 + rate, j);
                }

                // Return net present value
                return value;
            };

            exports.ODDFPRICE = null;

            exports.ODDFYIELD = null;

            exports.ODDLPRICE = null;

            exports.ODDLYIELD = null;

            exports.PDURATION = function (rate, present, future) {
                rate = utils.parseNumber(rate);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                if (utils.anyIsError(rate, present, future)) {
                    return error.value;
                }

                // Return error if rate <=0
                if (rate <= 0) {
                    return error.num;
                }

                // Return number of periods
                return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
            };

            exports.PMT = function (rate, periods, present, future, type) {
                // Credits: algorithm inspired by Apache OpenOffice

                future = future || 0;
                type = type || 0;

                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, present, future, type)) {
                    return error.value;
                }

                // Return payment
                var result;
                if (rate === 0) {
                    result = (present + future) / periods;
                } else {
                    var term = Math.pow(1 + rate, periods);
                    if (type === 1) {
                        result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
                    } else {
                        result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
                    }
                }
                return -result;
            };

            exports.PPMT = function (rate, period, periods, present, future, type) {
                future = future || 0;
                type = type || 0;

                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, present, future, type)) {
                    return error.value;
                }

                return exports.PMT(rate, periods, present, future, type) - exports.IPMT(rate, period, periods, present, future, type);
            };

            exports.PRICE = null;

            exports.PRICEDISC = null;

            exports.PRICEMAT = null;

            exports.PV = function (rate, periods, payment, future, type) {
                future = future || 0;
                type = type || 0;

                rate = utils.parseNumber(rate);
                periods = utils.parseNumber(periods);
                payment = utils.parseNumber(payment);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                if (utils.anyIsError(rate, periods, payment, future, type)) {
                    return error.value;
                }

                // Return present value
                if (rate === 0) {
                    return -payment * periods - future;
                } else {
                    return (((1 - Math.pow(1 + rate, periods)) / rate) * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
                }
            };

            exports.RATE = function (periods, payment, present, future, type, guess) {
                // Credits: rabugento

                guess = (guess === undefined) ? 0.01 : guess;
                future = (future === undefined) ? 0 : future;
                type = (type === undefined) ? 0 : type;

                periods = utils.parseNumber(periods);
                payment = utils.parseNumber(payment);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                type = utils.parseNumber(type);
                guess = utils.parseNumber(guess);
                if (utils.anyIsError(periods, payment, present, future, type, guess)) {
                    return error.value;
                }

                // Set maximum epsilon for end of iteration
                var epsMax = 1e-6;

                // Set maximum number of iterations
                var iterMax = 100;
                var iter = 0;
                var close = false;
                var rate = guess;

                while (iter < iterMax && !close) {
                    var t1 = Math.pow(rate + 1, periods);
                    var t2 = Math.pow(rate + 1, periods - 1);

                    var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type + 1) / rate;
                    var f2 = periods * t2 * present - payment * (t1 - 1) * (rate * type + 1) / Math.pow(rate, 2);
                    var f3 = periods * payment * t2 * (rate * type + 1) / rate + payment * (t1 - 1) * type / rate;

                    var newRate = rate - f1 / (f2 + f3);

                    if (Math.abs(newRate - rate) < epsMax) close = true;
                    iter++
                    rate = newRate;
                }

                if (!close) return Number.NaN + rate;
                return rate;
            };

            // TODO
            exports.RECEIVED = null;

            exports.RRI = function (periods, present, future) {
                periods = utils.parseNumber(periods);
                present = utils.parseNumber(present);
                future = utils.parseNumber(future);
                if (utils.anyIsError(periods, present, future)) {
                    return error.value;
                }

                // Return error if periods or present is equal to 0 (zero)
                if (periods === 0 || present === 0) {
                    return error.num;
                }

                // Return equivalent interest rate
                return Math.pow(future / present, 1 / periods) - 1;
            };

            exports.SLN = function (cost, salvage, life) {
                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                if (utils.anyIsError(cost, salvage, life)) {
                    return error.value;
                }

                // Return error if life equal to 0 (zero)
                if (life === 0) {
                    return error.num;
                }

                // Return straight-line depreciation
                return (cost - salvage) / life;
            };

            exports.SYD = function (cost, salvage, life, period) {
                // Return error if any of the parameters is not a number
                cost = utils.parseNumber(cost);
                salvage = utils.parseNumber(salvage);
                life = utils.parseNumber(life);
                period = utils.parseNumber(period);
                if (utils.anyIsError(cost, salvage, life, period)) {
                    return error.value;
                }

                // Return error if life equal to 0 (zero)
                if (life === 0) {
                    return error.num;
                }

                // Return error if period is lower than 1 or greater than life
                if (period < 1 || period > life) {
                    return error.num;
                }

                // Truncate period if it is not an integer
                period = parseInt(period, 10);

                // Return straight-line depreciation
                return ((cost - salvage) * (life - period + 1) * 2) / (life * (life + 1));
            };

            exports.TBILLEQ = function (settlement, maturity, discount) {
                settlement = utils.parseDate(settlement);
                maturity = utils.parseDate(maturity);
                discount = utils.parseNumber(discount);
                if (utils.anyIsError(settlement, maturity, discount)) {
                    return error.value;
                }

                // Return error if discount is lower than or equal to zero
                if (discount <= 0) {
                    return error.num;
                }

                // Return error if settlement is greater than maturity
                if (settlement > maturity) {
                    return error.num;
                }

                // Return error if maturity is more than one year after settlement
                if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
                    return error.num;
                }

                // Return bond-equivalent yield
                return (365 * discount) / (360 - discount * DAYS360(settlement, maturity, false));
            };

            exports.TBILLPRICE = function (settlement, maturity, discount) {
                settlement = utils.parseDate(settlement);
                maturity = utils.parseDate(maturity);
                discount = utils.parseNumber(discount);
                if (utils.anyIsError(settlement, maturity, discount)) {
                    return error.value;
                }

                // Return error if discount is lower than or equal to zero
                if (discount <= 0) {
                    return error.num;
                }

                // Return error if settlement is greater than maturity
                if (settlement > maturity) {
                    return error.num;
                }

                // Return error if maturity is more than one year after settlement
                if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
                    return error.num;
                }

                // Return bond-equivalent yield
                return 100 * (1 - discount * DAYS360(settlement, maturity, false) / 360);
            };

            exports.TBILLYIELD = function (settlement, maturity, price) {
                settlement = utils.parseDate(settlement);
                maturity = utils.parseDate(maturity);
                price = utils.parseNumber(price);
                if (utils.anyIsError(settlement, maturity, price)) {
                    return error.value;
                }

                // Return error if price is lower than or equal to zero
                if (price <= 0) {
                    return error.num;
                }

                // Return error if settlement is greater than maturity
                if (settlement > maturity) {
                    return error.num;
                }

                // Return error if maturity is more than one year after settlement
                if (maturity - settlement > 365 * 24 * 60 * 60 * 1000) {
                    return error.num;
                }

                // Return bond-equivalent yield
                return (100 - price) * 360 / (price * DAYS360(settlement, maturity, false));
            };

            exports.VDB = null;

            exports.XIRR = function (values, dates, guess) {
                // Credits: algorithm inspired by Apache OpenOffice

                values = utils.parseNumberArray(utils.flatten(values));
                dates = utils.parseDateArray(utils.flatten(dates));
                guess = utils.parseNumber(guess);
                if (utils.anyIsError(values, dates, guess)) {
                    return error.value;
                }

                // Calculates the resulting amount
                var irrResult = function (values, dates, rate) {
                    var r = rate + 1;
                    var result = values[0];
                    for (var i = 1; i < values.length; i++) {
                        result += values[i] / Math.pow(r, DAYS(dates[i], dates[0]) / 365);
                    }
                    return result;
                };

                // Calculates the first derivation
                var irrResultDeriv = function (values, dates, rate) {
                    var r = rate + 1;
                    var result = 0;
                    for (var i = 1; i < values.length; i++) {
                        var frac = DAYS(dates[i], dates[0]) / 365;
                        result -= frac * values[i] / Math.pow(r, frac + 1);
                    }
                    return result;
                };

                // Check that values contains at least one positive value and one
                // negative value
                var positive = false;
                var negative = false;
                for (var i = 0; i < values.length; i++) {
                    if (values[i] > 0) {
                        positive = true;
                    }
                    if (values[i] < 0) {
                        negative = true;
                    }
                }

                // Return error if values does not contain at least one positive value
                // and one negative value
                if (!positive || !negative) {
                    return error.num;
                }

                // Initialize guess and resultRate
                guess = guess || 0.1;
                var resultRate = guess;

                // Set maximum epsilon for end of iteration
                var epsMax = 1e-10;

                // Implement Newton's method
                var newRate, epsRate, resultValue;
                var contLoop = true;
                do {
                    resultValue = irrResult(values, dates, resultRate);
                    newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
                    epsRate = Math.abs(newRate - resultRate);
                    resultRate = newRate;
                    contLoop = (epsRate > epsMax) && (Math.abs(resultValue) > epsMax);
                } while (contLoop);

                // Return internal rate of return
                return resultRate;
            };

            exports.XNPV = function (rate, values, dates) {
                rate = utils.parseNumber(rate);
                values = utils.parseNumberArray(utils.flatten(values));
                dates = utils.parseDateArray(utils.flatten(dates));
                if (utils.anyIsError(rate, values, dates)) {
                    return error.value;
                }

                var result = 0;
                for (var i = 0; i < values.length; i++) {
                    result += values[i] / Math.pow(1 + rate, DAYS(dates[i], dates[0]) / 365);
                }
                return result;
            };

            exports.YIELD = null;

            exports.YIELDDISC = null;

            exports.YIELDMAT = null;

            return exports;
        })();

        jexcel.methods.information = (function () {
            var exports = {};
            exports.CELL = null;

            exports.ERROR = {};
            exports.ERROR.TYPE = function (error_val) {
                switch (error_val) {
                    case error.nil: return 1;
                    case error.div0: return 2;
                    case error.value: return 3;
                    case error.ref: return 4;
                    case error.name: return 5;
                    case error.num: return 6;
                    case error.na: return 7;
                    case error.data: return 8;
                }
                return error.na;
            };

            exports.INFO = null;

            exports.ISBLANK = function (value) {
                return value === null;
            };

            exports.ISBINARY = function (number) {
                return (/^[01]{1,10}$/).test(number);
            };

            exports.ISERR = function (value) {
                return ([error.value, error.ref, error.div0, error.num, error.name, error.nil]).indexOf(value) >= 0 ||
                    (typeof value === 'number' && (isNaN(value) || !isFinite(value)));
            };

            exports.ISERROR = function (value) {
                return exports.ISERR(value) || value === error.na;
            };

            exports.ISEVEN = function (number) {
                return (Math.floor(Math.abs(number)) & 1) ? false : true;
            };

            // TODO
            exports.ISFORMULA = null;

            exports.ISLOGICAL = function (value) {
                return value === true || value === false;
            };

            exports.ISNA = function (value) {
                return value === error.na;
            };

            exports.ISNONTEXT = function (value) {
                return typeof (value) !== 'string';
            };

            exports.ISNUMBER = function (value) {
                return typeof (value) === 'number' && !isNaN(value) && isFinite(value);
            };

            exports.ISODD = function (number) {
                return (Math.floor(Math.abs(number)) & 1) ? true : false;
            };

            exports.ISREF = null;

            exports.ISTEXT = function (value) {
                return typeof (value) === 'string';
            };

            exports.N = function (value) {
                if (this.ISNUMBER(value)) {
                    return value;
                }
                if (value instanceof Date) {
                    return value.getTime();
                }
                if (value === true) {
                    return 1;
                }
                if (value === false) {
                    return 0;
                }
                if (this.ISERROR(value)) {
                    return value;
                }
                return 0;
            };

            exports.NA = function () {
                return error.na;
            };

            exports.SHEET = null;

            exports.SHEETS = null;

            exports.TYPE = function (value) {
                if (this.ISNUMBER(value)) {
                    return 1;
                }
                if (this.ISTEXT(value)) {
                    return 2;
                }
                if (this.ISLOGICAL(value)) {
                    return 4;
                }
                if (this.ISERROR(value)) {
                    return 16;
                }
                if (Array.isArray(value)) {
                    return 64;
                }
            };

            return exports;
        })();

        jexcel.methods.logical = (function () {
            var exports = {};

            exports.AND = function () {
                var args = utils.flatten(arguments);
                var result = true;
                for (var i = 0; i < args.length; i++) {
                    if (!args[i]) {
                        result = false;
                    }
                }
                return result;
            };

            exports.CHOOSE = function () {
                if (arguments.length < 2) {
                    return error.na;
                }

                var index = arguments[0];
                if (index < 1 || index > 254) {
                    return error.value;
                }

                if (arguments.length < index + 1) {
                    return error.value;
                }

                return arguments[index];
            };

            exports.FALSE = function () {
                return false;
            };

            exports.IF = function (test, then_value, otherwise_value) {
                return test ? then_value : otherwise_value;
            };

            exports.IFERROR = function (value, valueIfError) {
                if (ISERROR(value)) {
                    return valueIfError;
                }
                return value;
            };

            exports.IFNA = function (value, value_if_na) {
                return value === error.na ? value_if_na : value;
            };

            exports.NOT = function (logical) {
                return !logical;
            };

            exports.OR = function () {
                var args = utils.flatten(arguments);
                var result = false;
                for (var i = 0; i < args.length; i++) {
                    if (args[i]) {
                        result = true;
                    }
                }
                return result;
            };

            exports.TRUE = function () {
                return true;
            };

            exports.XOR = function () {
                var args = utils.flatten(arguments);
                var result = 0;
                for (var i = 0; i < args.length; i++) {
                    if (args[i]) {
                        result++;
                    }
                }
                return (Math.floor(Math.abs(result)) & 1) ? true : false;
            };

            exports.SWITCH = function () {
                var result;
                if (arguments.length > 0) {
                    var targetValue = arguments[0];
                    var argc = arguments.length - 1;
                    var switchCount = Math.floor(argc / 2);
                    var switchSatisfied = false;
                    var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];

                    if (switchCount) {
                        for (var index = 0; index < switchCount; index++) {
                            if (targetValue === arguments[index * 2 + 1]) {
                                result = arguments[index * 2 + 2];
                                switchSatisfied = true;
                                break;
                            }
                        }
                    }

                    if (!switchSatisfied && defaultClause) {
                        result = defaultClause;
                    }
                }

                return result;
            };

            return exports;
        })();

        jexcel.methods.math = (function () {
            var exports = {};

            exports.ABS = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.abs(utils.parseNumber(number));
            };

            exports.ACOS = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.acos(number);
            };

            exports.ACOSH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number + Math.sqrt(number * number - 1));
            };

            exports.ACOT = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.atan(1 / number);
            };

            exports.ACOTH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 0.5 * Math.log((number + 1) / (number - 1));
            };

            exports.AGGREGATE = null

            exports.ARABIC = function (text) {
                // Credits: Rafa? Kukawski
                if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text)) {
                    return error.value;
                }
                var r = 0;
                text.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function (i) {
                    r += {
                        M: 1000,
                        CM: 900,
                        D: 500,
                        CD: 400,
                        C: 100,
                        XC: 90,
                        L: 50,
                        XL: 40,
                        X: 10,
                        IX: 9,
                        V: 5,
                        IV: 4,
                        I: 1
                    }[i];
                });
                return r;
            };

            exports.ASIN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.asin(number);
            };

            exports.ASINH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number + Math.sqrt(number * number + 1));
            };

            exports.ATAN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.atan(number);
            };

            exports.ATAN2 = function (number_x, number_y) {
                number_x = utils.parseNumber(number_x);
                number_y = utils.parseNumber(number_y);
                if (utils.anyIsError(number_x, number_y)) {
                    return error.value;
                }
                return Math.atan2(number_x, number_y);
            };

            exports.ATANH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log((1 + number) / (1 - number)) / 2;
            };

            exports.BASE = function (number, radix, min_length) {
                min_length = min_length || 0;

                number = utils.parseNumber(number);
                radix = utils.parseNumber(radix);
                min_length = utils.parseNumber(min_length);
                if (utils.anyIsError(number, radix, min_length)) {
                    return error.value;
                }
                min_length = (min_length === undefined) ? 0 : min_length;
                var result = number.toString(radix);
                return new Array(Math.max(min_length + 1 - result.length, 0)).join('0') + result;
            };

            exports.CEILING = function (number, significance, mode) {
                significance = (significance === undefined) ? 1 : significance;
                mode = (mode === undefined) ? 0 : mode;

                number = utils.parseNumber(number);
                significance = utils.parseNumber(significance);
                mode = utils.parseNumber(mode);
                if (utils.anyIsError(number, significance, mode)) {
                    return error.value;
                }
                if (significance === 0) {
                    return 0;
                }

                significance = Math.abs(significance);
                if (number >= 0) {
                    return Math.ceil(number / significance) * significance;
                } else {
                    if (mode === 0) {
                        return -1 * Math.floor(Math.abs(number) / significance) * significance;
                    } else {
                        return -1 * Math.ceil(Math.abs(number) / significance) * significance;
                    }
                }
            };

            exports.CEILING.MATH = exports.CEILING;

            exports.CEILING.PRECISE = exports.CEILING;

            exports.COMBIN = function (number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return exports.FACT(number) / (exports.FACT(number_chosen) * exports.FACT(number - number_chosen));
            };

            exports.COMBINA = function (number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return (number === 0 && number_chosen === 0) ? 1 : exports.COMBIN(number + number_chosen - 1, number - 1);
            };

            exports.COS = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.cos(number);
            };

            exports.COSH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return (Math.exp(number) + Math.exp(-number)) / 2;
            };

            exports.COT = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 1 / Math.tan(number);
            };

            exports.COTH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var e2 = Math.exp(2 * number);
                return (e2 + 1) / (e2 - 1);
            };

            exports.CSC = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 1 / Math.sin(number);
            };

            exports.CSCH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 2 / (Math.exp(number) - Math.exp(-number));
            };

            exports.DECIMAL = function (number, radix) {
                if (arguments.length < 1) {
                    return error.value;
                }


                return parseInt(number, radix);
            };

            exports.DEGREES = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return number * 180 / Math.PI;
            };

            exports.EVEN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return exports.CEILING(number, -2, -1);
            };

            exports.EXP = Math.exp;

            var MEMOIZED_FACT = [];
            exports.FACT = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var n = Math.floor(number);
                if (n === 0 || n === 1) {
                    return 1;
                } else if (MEMOIZED_FACT[n] > 0) {
                    return MEMOIZED_FACT[n];
                } else {
                    MEMOIZED_FACT[n] = exports.FACT(n - 1) * n;
                    return MEMOIZED_FACT[n];
                }
            };

            exports.FACTDOUBLE = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var n = Math.floor(number);
                if (n <= 0) {
                    return 1;
                } else {
                    return n * exports.FACTDOUBLE(n - 2);
                }
            };

            exports.FLOOR = function (number, significance, mode) {
                significance = (significance === undefined) ? 1 : significance;
                mode = (mode === undefined) ? 0 : mode;

                number = utils.parseNumber(number);
                significance = utils.parseNumber(significance);
                mode = utils.parseNumber(mode);
                if (utils.anyIsError(number, significance, mode)) {
                    return error.value;
                }
                if (significance === 0) {
                    return 0;
                }

                significance = Math.abs(significance);
                if (number >= 0) {
                    return Math.floor(number / significance) * significance;
                } else {
                    if (mode === 0) {
                        return -1 * Math.ceil(Math.abs(number) / significance) * significance;
                    } else {
                        return -1 * Math.floor(Math.abs(number) / significance) * significance;
                    }
                }
            };

            exports.FLOOR.MATH = exports.FLOOR;

            exports.GCD = null;

            exports.INT = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.floor(number);
            };

            exports.LCM = function () {
                // Credits: Jonas Raoni Soares Silva
                var o = utils.parseNumberArray(utils.flatten(arguments));
                if (o instanceof Error) {
                    return o;
                }
                for (var i, j, n, d, r = 1;
                    (n = o.pop()) !== undefined;) {
                    while (n > 1) {
                        if (n % 2) {
                            for (i = 3, j = Math.floor(Math.sqrt(n)); i <= j && n % i; i += 2) {
                                //empty
                            }
                            d = (i <= j) ? i : n;
                        } else {
                            d = 2;
                        }
                        for (n /= d, r *= d, i = o.length; i;
                            (o[--i] % d) === 0 && (o[i] /= d) === 1 && o.splice(i, 1)) {
                            //empty
                        }
                    }
                }
                return r;
            };

            exports.LN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number);
            };

            exports.LOG = function (number, base) {
                number = utils.parseNumber(number);
                base = (base === undefined) ? 10 : utils.parseNumber(base);

                if (utils.anyIsError(number, base)) {
                    return error.value;
                }

                return Math.log(number) / Math.log(base);
            };

            exports.LOG10 = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.log(number) / Math.log(10);
            };

            exports.MDETERM = null;

            exports.MINVERSE = null;

            exports.MMULT = null;

            exports.MOD = function (dividend, divisor) {
                dividend = utils.parseNumber(dividend);
                divisor = utils.parseNumber(divisor);
                if (utils.anyIsError(dividend, divisor)) {
                    return error.value;
                }
                if (divisor === 0) {
                    return error.div0;
                }
                var modulus = Math.abs(dividend % divisor);
                return (divisor > 0) ? modulus : -modulus;
            };

            exports.MROUND = function (number, multiple) {
                number = utils.parseNumber(number);
                multiple = utils.parseNumber(multiple);
                if (utils.anyIsError(number, multiple)) {
                    return error.value;
                }
                if (number * multiple < 0) {
                    return error.num;
                }

                return Math.round(number / multiple) * multiple;
            };

            exports.MULTINOMIAL = function () {
                var args = utils.parseNumberArray(utils.flatten(arguments));
                if (args instanceof Error) {
                    return args;
                }
                var sum = 0;
                var divisor = 1;
                for (var i = 0; i < args.length; i++) {
                    sum += args[i];
                    divisor *= exports.FACT(args[i]);
                }
                return exports.FACT(sum) / divisor;
            };

            exports.MUNIT = null;

            exports.ODD = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var temp = Math.ceil(Math.abs(number));
                temp = (temp & 1) ? temp : temp + 1;
                return (number > 0) ? temp : -temp;
            };

            exports.PI = function () {
                return Math.PI;
            };

            exports.POWER = function (number, power) {
                number = utils.parseNumber(number);
                power = utils.parseNumber(power);
                if (utils.anyIsError(number, power)) {
                    return error.value;
                }
                var result = Math.pow(number, power);
                if (isNaN(result)) {
                    return error.num;
                }

                return result;
            };

            exports.PRODUCT = function () {
                var args = utils.parseNumberArray(utils.flatten(arguments));
                if (args instanceof Error) {
                    return args;
                }
                var result = 1;
                for (var i = 0; i < args.length; i++) {
                    result *= args[i];
                }
                return result;
            };

            exports.QUOTIENT = function (numerator, denominator) {
                numerator = utils.parseNumber(numerator);
                denominator = utils.parseNumber(denominator);
                if (utils.anyIsError(numerator, denominator)) {
                    return error.value;
                }
                return parseInt(numerator / denominator, 10);
            };

            exports.RADIANS = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return number * Math.PI / 180;
            };

            exports.RAND = function () {
                return Math.random();
            };

            exports.RANDBETWEEN = function (bottom, top) {
                bottom = utils.parseNumber(bottom);
                top = utils.parseNumber(top);
                if (utils.anyIsError(bottom, top)) {
                    return error.value;
                }
                // Creative Commons Attribution 3.0 License
                // Copyright (c) 2012 eqcode
                return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
            };

            exports.ROMAN = null;

            exports.ROUND = function (number, digits) {
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
            };

            exports.ROUNDDOWN = function (number, digits) {
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                var sign = (number > 0) ? 1 : -1;
                return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
            };

            exports.ROUNDUP = function (number, digits) {
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                var sign = (number > 0) ? 1 : -1;
                return sign * (Math.ceil(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
            };

            exports.SEC = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 1 / Math.cos(number);
            };

            exports.SECH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return 2 / (Math.exp(number) + Math.exp(-number));
            };

            exports.SERIESSUM = function (x, n, m, coefficients) {
                x = utils.parseNumber(x);
                n = utils.parseNumber(n);
                m = utils.parseNumber(m);
                coefficients = utils.parseNumberArray(coefficients);
                if (utils.anyIsError(x, n, m, coefficients)) {
                    return error.value;
                }
                var result = coefficients[0] * Math.pow(x, n);
                for (var i = 1; i < coefficients.length; i++) {
                    result += coefficients[i] * Math.pow(x, n + i * m);
                }
                return result;
            };

            exports.SIGN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                if (number < 0) {
                    return -1;
                } else if (number === 0) {
                    return 0;
                } else {
                    return 1;
                }
            };

            exports.SIN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.sin(number);
            };

            exports.SINH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return (Math.exp(number) - Math.exp(-number)) / 2;
            };

            exports.SQRT = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                if (number < 0) {
                    return error.num;
                }
                return Math.sqrt(number);
            };

            exports.SQRTPI = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.sqrt(number * Math.PI);
            };

            exports.SUBTOTAL = null;

            exports.ADD = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.value;
                }

                return num1 + num2;
            };

            exports.MINUS = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.value;
                }

                return num1 - num2;
            };

            exports.DIVIDE = function (dividend, divisor) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                dividend = utils.parseNumber(dividend);
                divisor = utils.parseNumber(divisor);
                if (utils.anyIsError(dividend, divisor)) {
                    return error.value;
                }

                if (divisor === 0) {
                    return error.div0;
                }

                return dividend / divisor;
            };

            exports.MULTIPLY = function (factor1, factor2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                factor1 = utils.parseNumber(factor1);
                factor2 = utils.parseNumber(factor2);
                if (utils.anyIsError(factor1, factor2)) {
                    return error.value;
                }

                return factor1 * factor2;
            };

            exports.GTE = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.error;
                }

                return num1 >= num2;
            };

            exports.LT = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.error;
                }

                return num1 < num2;
            };

            exports.LTE = function (num1, num2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                num1 = utils.parseNumber(num1);
                num2 = utils.parseNumber(num2);
                if (utils.anyIsError(num1, num2)) {
                    return error.error;
                }

                return num1 <= num2;
            };

            exports.EQ = function (value1, value2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                return value1 === value2;
            };

            exports.NE = function (value1, value2) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                return value1 !== value2;
            };

            exports.POW = function (base, exponent) {
                if (arguments.length !== 2) {
                    return error.na;
                }

                base = utils.parseNumber(base);
                exponent = utils.parseNumber(exponent);
                if (utils.anyIsError(base, exponent)) {
                    return error.error;
                }

                return exports.POWER(base, exponent);
            };

            exports.SUM = function () {
                var result = 0;
                var argsKeys = Object.keys(arguments);
                for (var i = 0; i < argsKeys.length; ++i) {
                    var elt = arguments[argsKeys[i]];
                    if (typeof elt === 'number') {
                        result += elt;
                    } else if (typeof elt === 'string') {
                        var parsed = parseFloat(elt);
                        !isNaN(parsed) && (result += parsed);
                    } else if (Array.isArray(elt)) {
                        result += exports.SUM.apply(null, elt);
                    }
                }
                return result;
            };

            exports.SUMIF = function (range, criteria) {
                range = utils.parseNumberArray(utils.flatten(range));
                if (range instanceof Error) {
                    return range;
                }
                var result = 0;
                for (var i = 0; i < range.length; i++) {
                    result += (eval(range[i] + criteria)) ? range[i] : 0; // jshint ignore:line
                }
                return result;
            };

            exports.SUMIFS = function () {
                var args = utils.argsToArray(arguments);
                var range = utils.parseNumberArray(utils.flatten(args.shift()));
                if (range instanceof Error) {
                    return range;
                }
                var criteria = args;

                var n_range_elements = range.length;
                var n_criterias = criteria.length;

                var result = 0;
                for (var i = 0; i < n_range_elements; i++) {
                    var el = range[i];
                    var condition = '';
                    for (var c = 0; c < n_criterias; c++) {
                        condition += el + criteria[c];
                        if (c !== n_criterias - 1) {
                            condition += '&&';
                        }
                    }
                    if (eval(condition)) { // jshint ignore:line
                        result += el;
                    }
                }
                return result;
            };

            exports.SUMPRODUCT = null;

            exports.SUMSQ = function () {
                var numbers = utils.parseNumberArray(utils.flatten(arguments));
                if (numbers instanceof Error) {
                    return numbers;
                }
                var result = 0;
                var length = numbers.length;
                for (var i = 0; i < length; i++) {
                    result += (ISNUMBER(numbers[i])) ? numbers[i] * numbers[i] : 0;
                }
                return result;
            };

            exports.SUMX2MY2 = function (array_x, array_y) {
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                if (utils.anyIsError(array_x, array_y)) {
                    return error.value;
                }
                var result = 0;
                for (var i = 0; i < array_x.length; i++) {
                    result += array_x[i] * array_x[i] - array_y[i] * array_y[i];
                }
                return result;
            };

            exports.SUMX2PY2 = function (array_x, array_y) {
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                if (utils.anyIsError(array_x, array_y)) {
                    return error.value;
                }
                var result = 0;
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                for (var i = 0; i < array_x.length; i++) {
                    result += array_x[i] * array_x[i] + array_y[i] * array_y[i];
                }
                return result;
            };

            exports.SUMXMY2 = function (array_x, array_y) {
                array_x = utils.parseNumberArray(utils.flatten(array_x));
                array_y = utils.parseNumberArray(utils.flatten(array_y));
                if (utils.anyIsError(array_x, array_y)) {
                    return error.value;
                }
                var result = 0;
                array_x = utils.flatten(array_x);
                array_y = utils.flatten(array_y);
                for (var i = 0; i < array_x.length; i++) {
                    result += Math.pow(array_x[i] - array_y[i], 2);
                }
                return result;
            };

            exports.TAN = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return Math.tan(number);
            };

            exports.TANH = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                var e2 = Math.exp(2 * number);
                return (e2 - 1) / (e2 + 1);
            };

            exports.TRUNC = function (number, digits) {
                digits = (digits === undefined) ? 0 : digits;
                number = utils.parseNumber(number);
                digits = utils.parseNumber(digits);
                if (utils.anyIsError(number, digits)) {
                    return error.value;
                }
                var sign = (number > 0) ? 1 : -1;
                return sign * (Math.floor(Math.abs(number) * Math.pow(10, digits))) / Math.pow(10, digits);
            };

            return exports;
        })();

        jexcel.methods.misc = (function () {
            var exports = {};

            exports.UNIQUE = function () {
                var result = [];
                for (var i = 0; i < arguments.length; ++i) {
                    var hasElement = false;
                    var element = arguments[i];

                    // Check if we've already seen this element.
                    for (var j = 0; j < result.length; ++j) {
                        hasElement = result[j] === element;
                        if (hasElement) { break; }
                    }

                    // If we did not find it, add it to the result.
                    if (!hasElement) {
                        result.push(element);
                    }
                }
                return result;
            };

            exports.FLATTEN = utils.flatten;

            exports.ARGS2ARRAY = function () {
                return Array.prototype.slice.call(arguments, 0);
            };

            exports.REFERENCE = function (context, reference) {
                try {
                    var path = reference.split('.');
                    var result = context;
                    for (var i = 0; i < path.length; ++i) {
                        var step = path[i];
                        if (step[step.length - 1] === ']') {
                            var opening = step.indexOf('[');
                            var index = step.substring(opening + 1, step.length - 1);
                            result = result[step.substring(0, opening)][index];
                        } else {
                            result = result[step];
                        }
                    }
                    return result;
                } catch (error) { }
            };

            exports.JOIN = function (array, separator) {
                return array.join(separator);
            };

            exports.NUMBERS = function () {
                var possibleNumbers = utils.flatten(arguments);
                return possibleNumbers.filter(function (el) {
                    return typeof el === 'number';
                });
            };

            exports.NUMERAL = null;

            return exports;
        })();

        jexcel.methods.text = (function () {
            var exports = {};

            exports.ASC = null;

            exports.BAHTTEXT = null;

            exports.CHAR = function (number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return String.fromCharCode(number);
            };

            exports.CLEAN = function (text) {
                text = text || '';
                var re = /[\0-\x1F]/g;
                return text.replace(re, "");
            };

            exports.CODE = function (text) {
                text = text || '';
                return text.charCodeAt(0);
            };

            exports.CONCATENATE = function () {
                var args = utils.flatten(arguments);

                var trueFound = 0;
                while ((trueFound = args.indexOf(true)) > -1) {
                    args[trueFound] = 'TRUE';
                }

                var falseFound = 0;
                while ((falseFound = args.indexOf(false)) > -1) {
                    args[falseFound] = 'FALSE';
                }

                return args.join('');
            };

            exports.DBCS = null;

            exports.DOLLAR = null;

            exports.EXACT = function (text1, text2) {
                return text1 === text2;
            };

            exports.FIND = function (find_text, within_text, position) {
                position = (position === undefined) ? 0 : position;
                return within_text ? within_text.indexOf(find_text, position - 1) + 1 : null;
            };

            exports.FIXED = null;

            exports.HTML2TEXT = function (value) {
                var result = '';

                if (value) {
                    if (value instanceof Array) {
                        value.forEach(function (line) {
                            if (result !== '') {
                                result += '\n';
                            }
                            result += (line.replace(/<(?:.|\n)*?>/gm, ''));
                        });
                    } else {
                        result = value.replace(/<(?:.|\n)*?>/gm, '');
                    }
                }

                return result;
            };

            exports.LEFT = function (text, number) {
                number = (number === undefined) ? 1 : number;
                number = utils.parseNumber(number);
                if (number instanceof Error || typeof text !== 'string') {
                    return error.value;
                }
                return text ? text.substring(0, number) : null;
            };

            exports.LEN = function (text) {
                if (arguments.length === 0) {
                    return error.error;
                }

                if (typeof text === 'string') {
                    return text ? text.length : 0;
                }

                if (text.length) {
                    return text.length;
                }

                return error.value;
            };

            exports.LOWER = function (text) {
                if (typeof text !== 'string') {
                    return error.value;
                }
                return text ? text.toLowerCase() : text;
            };

            exports.MID = function (text, start, number) {
                start = utils.parseNumber(start);
                number = utils.parseNumber(number);
                if (utils.anyIsError(start, number) || typeof text !== 'string') {
                    return number;
                }

                var begin = start - 1;
                var end = begin + number;

                return text.substring(begin, end);
            };

            exports.NUMBERVALUE = null;

            exports.PRONETIC = null;

            exports.PROPER = function (text) {
                if (text === undefined || text.length === 0) {
                    return error.value;
                }
                if (text === true) {
                    text = 'TRUE';
                }
                if (text === false) {
                    text = 'FALSE';
                }
                if (isNaN(text) && typeof text === 'number') {
                    return error.value;
                }
                if (typeof text === 'number') {
                    text = '' + text;
                }

                return text.replace(/\w\S*/g, function (txt) {
                    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                });
            };

            exports.REGEXEXTRACT = function (text, regular_expression) {
                var match = text.match(new RegExp(regular_expression));
                return match ? (match[match.length > 1 ? match.length - 1 : 0]) : null;
            };

            exports.REGEXMATCH = function (text, regular_expression, full) {
                var match = text.match(new RegExp(regular_expression));
                return full ? match : !!match;
            };

            exports.REGEXREPLACE = function (text, regular_expression, replacement) {
                return text.replace(new RegExp(regular_expression), replacement);
            };

            exports.REPLACE = function (text, position, length, new_text) {
                position = utils.parseNumber(position);
                length = utils.parseNumber(length);
                if (utils.anyIsError(position, length) ||
                    typeof text !== 'string' ||
                    typeof new_text !== 'string') {
                    return error.value;
                }
                return text.substr(0, position - 1) + new_text + text.substr(position - 1 + length);
            };

            exports.REPT = function (text, number) {
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return new Array(number + 1).join(text);
            };

            exports.RIGHT = function (text, number) {
                number = (number === undefined) ? 1 : number;
                number = utils.parseNumber(number);
                if (number instanceof Error) {
                    return number;
                }
                return text ? text.substring(text.length - number) : null;
            };

            exports.SEARCH = function (find_text, within_text, position) {
                var foundAt;
                if (typeof find_text !== 'string' || typeof within_text !== 'string') {
                    return error.value;
                }
                position = (position === undefined) ? 0 : position;
                foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1) + 1;
                return (foundAt === 0) ? error.value : foundAt;
            };

            exports.SPLIT = function (text, separator) {
                return text.split(separator);
            };

            exports.SUBSTITUTE = function (text, old_text, new_text, occurrence) {
                if (!text || !old_text || !new_text) {
                    return text;
                } else if (occurrence === undefined) {
                    return text.replace(new RegExp(old_text, 'g'), new_text);
                } else {
                    var index = 0;
                    var i = 0;
                    while (text.indexOf(old_text, index) > 0) {
                        index = text.indexOf(old_text, index + 1);
                        i++;
                        if (i === occurrence) {
                            return text.substring(0, index) + new_text + text.substring(index + old_text.length);
                        }
                    }
                }
            };

            exports.T = function (value) {
                return (typeof value === "string") ? value : '';
            };

            exports.TEXT = null;

            exports.TRIM = function (text) {
                if (typeof text !== 'string') {
                    return error.value;
                }
                return text.replace(/ +/g, ' ').trim();
            };

            exports.UNICHAR = exports.CHAR;

            exports.UNICODE = exports.CODE;

            exports.UPPER = function (text) {
                if (typeof text !== 'string') {
                    return error.value;
                }
                return text.toUpperCase();
            };

            exports.VALUE = null;

            return exports;
        })();

        jexcel.methods.stats = (function () {
            var exports = {};

            var SQRT2PI = 2.5066282746310002;

            exports.AVEDEV = null;

            exports.AVERAGE = function () {
                var range = utils.numbers(utils.flatten(arguments));
                var n = range.length;
                var sum = 0;
                var count = 0;
                for (var i = 0; i < n; i++) {
                    sum += range[i];
                    count += 1;
                }
                return sum / count;
            };

            exports.AVERAGEA = function () {
                var range = utils.flatten(arguments);
                var n = range.length;
                var sum = 0;
                var count = 0;
                for (var i = 0; i < n; i++) {
                    var el = range[i];
                    if (typeof el === 'number') {
                        sum += el;
                    }
                    if (el === true) {
                        sum++;
                    }
                    if (el !== null) {
                        count++;
                    }
                }
                return sum / count;
            };

            exports.AVERAGEIF = function (range, criteria, average_range) {
                average_range = average_range || range;
                range = utils.flatten(range);
                average_range = utils.parseNumberArray(utils.flatten(average_range));
                if (average_range instanceof Error) {
                    return average_range;
                }
                var average_count = 0;
                var result = 0;
                for (var i = 0; i < range.length; i++) {
                    if (eval(range[i] + criteria)) { // jshint ignore:line
                        result += average_range[i];
                        average_count++;
                    }
                }
                return result / average_count;
            };

            exports.AVERAGEIFS = null;

            exports.COUNT = function () {
                return utils.numbers(utils.flatten(arguments)).length;
            };

            exports.COUNTA = function () {
                var range = utils.flatten(arguments);
                return range.length - exports.COUNTBLANK(range);
            };

            exports.COUNTIN = function (range, value) {
                var result = 0;
                for (var i = 0; i < range.length; i++) {
                    if (range[i] === value) {
                        result++;
                    }
                }
                return result;
            };

            exports.COUNTBLANK = function () {
                var range = utils.flatten(arguments);
                var blanks = 0;
                var element;
                for (var i = 0; i < range.length; i++) {
                    element = range[i];
                    if (element === null || element === '') {
                        blanks++;
                    }
                }
                return blanks;
            };

            exports.COUNTIF = function (range, criteria) {
                range = utils.flatten(range);
                if (!/[<>=!]/.test(criteria)) {
                    criteria = '=="' + criteria + '"';
                }
                var matches = 0;
                for (var i = 0; i < range.length; i++) {
                    if (typeof range[i] !== 'string') {
                        if (eval(range[i] + criteria)) { // jshint ignore:line
                            matches++;
                        }
                    } else {
                        if (eval('"' + range[i] + '"' + criteria)) { // jshint ignore:line
                            matches++;
                        }
                    }
                }
                return matches;
            };

            exports.COUNTIFS = function () {
                var args = utils.argsToArray(arguments);
                var results = new Array(utils.flatten(args[0]).length);
                for (var i = 0; i < results.length; i++) {
                    results[i] = true;
                }
                for (i = 0; i < args.length; i += 2) {
                    var range = utils.flatten(args[i]);
                    var criteria = args[i + 1];
                    if (!/[<>=!]/.test(criteria)) {
                        criteria = '=="' + criteria + '"';
                    }
                    for (var j = 0; j < range.length; j++) {
                        if (typeof range[j] !== 'string') {
                            results[j] = results[j] && eval(range[j] + criteria); // jshint ignore:line
                        } else {
                            results[j] = results[j] && eval('"' + range[j] + '"' + criteria); // jshint ignore:line
                        }
                    }
                }
                var result = 0;
                for (i = 0; i < results.length; i++) {
                    if (results[i]) {
                        result++;
                    }
                }
                return result;
            };

            exports.COUNTUNIQUE = function () {
                return UNIQUE.apply(null, utils.flatten(arguments)).length;
            };

            exports.FISHER = function (x) {
                x = utils.parseNumber(x);
                if (x instanceof Error) {
                    return x;
                }
                return Math.log((1 + x) / (1 - x)) / 2;
            };

            exports.FISHERINV = function (y) {
                y = utils.parseNumber(y);
                if (y instanceof Error) {
                    return y;
                }
                var e2y = Math.exp(2 * y);
                return (e2y - 1) / (e2y + 1);
            };

            exports.FREQUENCY = function (data, bins) {
                data = utils.parseNumberArray(utils.flatten(data));
                bins = utils.parseNumberArray(utils.flatten(bins));
                if (utils.anyIsError(data, bins)) {
                    return error.value;
                }
                var n = data.length;
                var b = bins.length;
                var r = [];
                for (var i = 0; i <= b; i++) {
                    r[i] = 0;
                    for (var j = 0; j < n; j++) {
                        if (i === 0) {
                            if (data[j] <= bins[0]) {
                                r[0] += 1;
                            }
                        } else if (i < b) {
                            if (data[j] > bins[i - 1] && data[j] <= bins[i]) {
                                r[i] += 1;
                            }
                        } else if (i === b) {
                            if (data[j] > bins[b - 1]) {
                                r[b] += 1;
                            }
                        }
                    }
                }
                return r;
            };

            exports.LARGE = function (range, k) {
                range = utils.parseNumberArray(utils.flatten(range));
                k = utils.parseNumber(k);
                if (utils.anyIsError(range, k)) {
                    return range;
                }
                return range.sort(function (a, b) {
                    return b - a;
                })[k - 1];
            };

            exports.MAX = function () {
                var range = utils.numbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.max.apply(Math, range);
            };

            exports.MAXA = function () {
                var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.max.apply(Math, range);
            };

            exports.MIN = function () {
                var range = utils.numbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.min.apply(Math, range);
            };

            exports.MINA = function () {
                var range = utils.arrayValuesToNumbers(utils.flatten(arguments));
                return (range.length === 0) ? 0 : Math.min.apply(Math, range);
            };

            exports.MODE = {};

            exports.MODE.MULT = function () {
                // Credits: Roönaän
                var range = utils.parseNumberArray(utils.flatten(arguments));
                if (range instanceof Error) {
                    return range;
                }
                var n = range.length;
                var count = {};
                var maxItems = [];
                var max = 0;
                var currentItem;

                for (var i = 0; i < n; i++) {
                    currentItem = range[i];
                    count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
                    if (count[currentItem] > max) {
                        max = count[currentItem];
                        maxItems = [];
                    }
                    if (count[currentItem] === max) {
                        maxItems[maxItems.length] = currentItem;
                    }
                }
                return maxItems;
            };

            exports.MODE.SNGL = function () {
                var range = utils.parseNumberArray(utils.flatten(arguments));
                if (range instanceof Error) {
                    return range;
                }
                return exports.MODE.MULT(range).sort(function (a, b) {
                    return a - b;
                })[0];
            };

            exports.PERCENTILE = {};

            exports.PERCENTILE.EXC = function (array, k) {
                array = utils.parseNumberArray(utils.flatten(array));
                k = utils.parseNumber(k);
                if (utils.anyIsError(array, k)) {
                    return error.value;
                }
                array = array.sort(function (a, b) {
                    {
                        return a - b;
                    }
                });
                var n = array.length;
                if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
                    return error.num;
                }
                var l = k * (n + 1) - 1;
                var fl = Math.floor(l);
                return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
            };

            exports.PERCENTILE.INC = function (array, k) {
                array = utils.parseNumberArray(utils.flatten(array));
                k = utils.parseNumber(k);
                if (utils.anyIsError(array, k)) {
                    return error.value;
                }
                array = array.sort(function (a, b) {
                    return a - b;
                });
                var n = array.length;
                var l = k * (n - 1);
                var fl = Math.floor(l);
                return utils.cleanFloat((l === fl) ? array[l] : array[fl] + (l - fl) * (array[fl + 1] - array[fl]));
            };

            exports.PERCENTRANK = {};

            exports.PERCENTRANK.EXC = function (array, x, significance) {
                significance = (significance === undefined) ? 3 : significance;
                array = utils.parseNumberArray(utils.flatten(array));
                x = utils.parseNumber(x);
                significance = utils.parseNumber(significance);
                if (utils.anyIsError(array, x, significance)) {
                    return error.value;
                }
                array = array.sort(function (a, b) {
                    return a - b;
                });
                var uniques = UNIQUE.apply(null, array);
                var n = array.length;
                var m = uniques.length;
                var power = Math.pow(10, significance);
                var result = 0;
                var match = false;
                var i = 0;
                while (!match && i < m) {
                    if (x === uniques[i]) {
                        result = (array.indexOf(uniques[i]) + 1) / (n + 1);
                        match = true;
                    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
                        result = (array.indexOf(uniques[i]) + 1 + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n + 1);
                        match = true;
                    }
                    i++;
                }
                return Math.floor(result * power) / power;
            };

            exports.PERCENTRANK.INC = function (array, x, significance) {
                significance = (significance === undefined) ? 3 : significance;
                array = utils.parseNumberArray(utils.flatten(array));
                x = utils.parseNumber(x);
                significance = utils.parseNumber(significance);
                if (utils.anyIsError(array, x, significance)) {
                    return error.value;
                }
                array = array.sort(function (a, b) {
                    return a - b;
                });
                var uniques = UNIQUE.apply(null, array);
                var n = array.length;
                var m = uniques.length;
                var power = Math.pow(10, significance);
                var result = 0;
                var match = false;
                var i = 0;
                while (!match && i < m) {
                    if (x === uniques[i]) {
                        result = array.indexOf(uniques[i]) / (n - 1);
                        match = true;
                    } else if (x >= uniques[i] && (x < uniques[i + 1] || i === m - 1)) {
                        result = (array.indexOf(uniques[i]) + (x - uniques[i]) / (uniques[i + 1] - uniques[i])) / (n - 1);
                        match = true;
                    }
                    i++;
                }
                return Math.floor(result * power) / power;
            };

            exports.PERMUT = function (number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return FACT(number) / FACT(number - number_chosen);
            };

            exports.PERMUTATIONA = function (number, number_chosen) {
                number = utils.parseNumber(number);
                number_chosen = utils.parseNumber(number_chosen);
                if (utils.anyIsError(number, number_chosen)) {
                    return error.value;
                }
                return Math.pow(number, number_chosen);
            };

            exports.PHI = function (x) {
                x = utils.parseNumber(x);
                if (x instanceof Error) {
                    return error.value;
                }
                return Math.exp(-0.5 * x * x) / SQRT2PI;
            };

            exports.PROB = function (range, probability, lower, upper) {
                if (lower === undefined) {
                    return 0;
                }
                upper = (upper === undefined) ? lower : upper;

                range = utils.parseNumberArray(utils.flatten(range));
                probability = utils.parseNumberArray(utils.flatten(probability));
                lower = utils.parseNumber(lower);
                upper = utils.parseNumber(upper);
                if (utils.anyIsError(range, probability, lower, upper)) {
                    return error.value;
                }

                if (lower === upper) {
                    return (range.indexOf(lower) >= 0) ? probability[range.indexOf(lower)] : 0;
                }

                var sorted = range.sort(function (a, b) {
                    return a - b;
                });
                var n = sorted.length;
                var result = 0;
                for (var i = 0; i < n; i++) {
                    if (sorted[i] >= lower && sorted[i] <= upper) {
                        result += probability[range.indexOf(sorted[i])];
                    }
                }
                return result;
            };

            exports.QUARTILE = {};

            exports.QUARTILE.EXC = function (range, quart) {
                range = utils.parseNumberArray(utils.flatten(range));
                quart = utils.parseNumber(quart);
                if (utils.anyIsError(range, quart)) {
                    return error.value;
                }
                switch (quart) {
                    case 1:
                        return exports.PERCENTILE.EXC(range, 0.25);
                    case 2:
                        return exports.PERCENTILE.EXC(range, 0.5);
                    case 3:
                        return exports.PERCENTILE.EXC(range, 0.75);
                    default:
                        return error.num;
                }
            };

            exports.QUARTILE.INC = function (range, quart) {
                range = utils.parseNumberArray(utils.flatten(range));
                quart = utils.parseNumber(quart);
                if (utils.anyIsError(range, quart)) {
                    return error.value;
                }
                switch (quart) {
                    case 1:
                        return exports.PERCENTILE.INC(range, 0.25);
                    case 2:
                        return exports.PERCENTILE.INC(range, 0.5);
                    case 3:
                        return exports.PERCENTILE.INC(range, 0.75);
                    default:
                        return error.num;
                }
            };

            exports.RANK = {};

            exports.RANK.AVG = function (number, range, order) {
                number = utils.parseNumber(number);
                range = utils.parseNumberArray(utils.flatten(range));
                if (utils.anyIsError(number, range)) {
                    return error.value;
                }
                range = utils.flatten(range);
                order = order || false;
                var sort = (order) ? function (a, b) {
                    return a - b;
                } : function (a, b) {
                    return b - a;
                };
                range = range.sort(sort);

                var length = range.length;
                var count = 0;
                for (var i = 0; i < length; i++) {
                    if (range[i] === number) {
                        count++;
                    }
                }

                return (count > 1) ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
            };

            exports.RANK.EQ = function (number, range, order) {
                number = utils.parseNumber(number);
                range = utils.parseNumberArray(utils.flatten(range));
                if (utils.anyIsError(number, range)) {
                    return error.value;
                }
                order = order || false;
                var sort = (order) ? function (a, b) {
                    return a - b;
                } : function (a, b) {
                    return b - a;
                };
                range = range.sort(sort);
                return range.indexOf(number) + 1;
            };

            exports.RSQ = function (data_x, data_y) { // no need to flatten here, PEARSON will take care of that
                data_x = utils.parseNumberArray(utils.flatten(data_x));
                data_y = utils.parseNumberArray(utils.flatten(data_y));
                if (utils.anyIsError(data_x, data_y)) {
                    return error.value;
                }
                return Math.pow(exports.PEARSON(data_x, data_y), 2);
            };

            exports.SMALL = function (range, k) {
                range = utils.parseNumberArray(utils.flatten(range));
                k = utils.parseNumber(k);
                if (utils.anyIsError(range, k)) {
                    return range;
                }
                return range.sort(function (a, b) {
                    return a - b;
                })[k - 1];
            };

            exports.STANDARDIZE = function (x, mean, sd) {
                x = utils.parseNumber(x);
                mean = utils.parseNumber(mean);
                sd = utils.parseNumber(sd);
                if (utils.anyIsError(x, mean, sd)) {
                    return error.value;
                }
                return (x - mean) / sd;
            };

            exports.STDEV = {};

            exports.STDEV.P = function () {
                var v = exports.VAR.P.apply(this, arguments);
                return Math.sqrt(v);
            };

            exports.STDEV.S = function () {
                var v = exports.VAR.S.apply(this, arguments);
                return Math.sqrt(v);
            };

            exports.STDEVA = function () {
                var v = exports.VARA.apply(this, arguments);
                return Math.sqrt(v);
            };

            exports.STDEVPA = function () {
                var v = exports.VARPA.apply(this, arguments);
                return Math.sqrt(v);
            };

            exports.VAR = {};

            exports.VAR.P = function () {
                var range = utils.numbers(utils.flatten(arguments));
                var n = range.length;
                var sigma = 0;
                var mean = exports.AVERAGE(range);
                for (var i = 0; i < n; i++) {
                    sigma += Math.pow(range[i] - mean, 2);
                }
                return sigma / n;
            };

            exports.VAR.S = function () {
                var range = utils.numbers(utils.flatten(arguments));
                var n = range.length;
                var sigma = 0;
                var mean = exports.AVERAGE(range);
                for (var i = 0; i < n; i++) {
                    sigma += Math.pow(range[i] - mean, 2);
                }
                return sigma / (n - 1);
            };

            exports.VARA = function () {
                var range = utils.flatten(arguments);
                var n = range.length;
                var sigma = 0;
                var count = 0;
                var mean = exports.AVERAGEA(range);
                for (var i = 0; i < n; i++) {
                    var el = range[i];
                    if (typeof el === 'number') {
                        sigma += Math.pow(el - mean, 2);
                    } else if (el === true) {
                        sigma += Math.pow(1 - mean, 2);
                    } else {
                        sigma += Math.pow(0 - mean, 2);
                    }

                    if (el !== null) {
                        count++;
                    }
                }
                return sigma / (count - 1);
            };

            exports.VARPA = function () {
                var range = utils.flatten(arguments);
                var n = range.length;
                var sigma = 0;
                var count = 0;
                var mean = exports.AVERAGEA(range);
                for (var i = 0; i < n; i++) {
                    var el = range[i];
                    if (typeof el === 'number') {
                        sigma += Math.pow(el - mean, 2);
                    } else if (el === true) {
                        sigma += Math.pow(1 - mean, 2);
                    } else {
                        sigma += Math.pow(0 - mean, 2);
                    }

                    if (el !== null) {
                        count++;
                    }
                }
                return sigma / count;
            };

            exports.WEIBULL = {};

            exports.WEIBULL.DIST = function (x, alpha, beta, cumulative) {
                x = utils.parseNumber(x);
                alpha = utils.parseNumber(alpha);
                beta = utils.parseNumber(beta);
                if (utils.anyIsError(x, alpha, beta)) {
                    return error.value;
                }
                return (cumulative) ? 1 - Math.exp(-Math.pow(x / beta, alpha)) : Math.pow(x, alpha - 1) * Math.exp(-Math.pow(x / beta, alpha)) * alpha / Math.pow(beta, alpha);
            };

            exports.Z = {};

            exports.Z.TEST = function (range, x, sd) {
                range = utils.parseNumberArray(utils.flatten(range));
                x = utils.parseNumber(x);
                if (utils.anyIsError(range, x)) {
                    return error.value;
                }

                sd = sd || exports.STDEV.S(range);
                var n = range.length;
                return 1 - exports.NORM.S.DIST((exports.AVERAGE(range) - x) / (sd / Math.sqrt(n)), true);
            };

            return exports;
        })();

        for (var i = 0; i < Object.keys(jexcel.methods).length; i++) {
            var methods = jexcel.methods[Object.keys(jexcel.methods)[i]];
            for (var j = 0; j < Object.keys(methods).length; j++) {
                if (typeof (methods[Object.keys(methods)[j]]) == 'function') {
                    window[Object.keys(methods)[j]] = methods[Object.keys(methods)[j]];
                } else {
                    window[Object.keys(methods)[j]] = function () {
                        return Object.keys(methods)[j] + 'Not implemented';
                    }
                }
            }
        }

        if (typeof exports === 'object' && typeof module !== 'undefined') {
            module.exports = jexcel;
        }

    </script>
    <script>

        /**
         * (c) jSuites Javascript Web Components
         *
         * Author: Paul Hodel <paul.hodel@gmail.com>
         * Website: https://bossanova.uk/jsuites/
         * Description: Create amazing web based applications.
         *
         * MIT License
         *
         */
        ; (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                    global.jSuites = factory();

            // Keep compatibility with jtools legacy
            global.jApp = global.jSuites;
        }(this, (function () {

            'use strict';

            var jSuites = function (options) {
                var obj = {}

                // Find root element
                obj.el = document.querySelector('.app');

                // Backdrop
                obj.backdrop = document.createElement('div');
                obj.backdrop.classList.add('jbackdrop');

                obj.getWindowWidth = function () {
                    var w = window,
                        d = document,
                        e = d.documentElement,
                        g = d.getElementsByTagName('body')[0],
                        x = w.innerWidth || e.clientWidth || g.clientWidth;
                    return x;
                }

                obj.getWindowHeight = function () {
                    var w = window,
                        d = document,
                        e = d.documentElement,
                        g = d.getElementsByTagName('body')[0],
                        y = w.innerHeight || e.clientHeight || g.clientHeight;
                    return y;
                }

                obj.getPosition = function (e) {
                    if (e.changedTouches && e.changedTouches[0]) {
                        var x = e.changedTouches[0].pageX;
                        var y = e.changedTouches[0].pageY;
                    } else {
                        var x = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
                        var y = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
                    }

                    return [x, y];
                }

                obj.click = function (el) {
                    if (el.click) {
                        el.click();
                    } else {
                        var evt = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        });
                        el.dispatchEvent(evt);
                    }
                }

                obj.getElement = function (element, className) {
                    var foundElement = false;

                    function path(element) {
                        if (element.className) {
                            if (element.classList.contains(className)) {
                                foundElement = element;
                            }
                        }

                        if (element.parentNode) {
                            path(element.parentNode);
                        }
                    }

                    path(element);

                    return foundElement;
                }

                obj.getLinkElement = function (element) {
                    var targetElement = false;

                    function path(element) {
                        if ((element.tagName == 'A' || element.tagName == 'DIV') && element.getAttribute('data-href')) {
                            targetElement = element;
                        }

                        if (element.parentNode) {
                            path(element.parentNode);
                        }
                    }

                    path(element);

                    return targetElement;
                }

                obj.getFormElements = function (formObject) {
                    var ret = {};

                    if (formObject) {
                        var elements = formObject.querySelectorAll("input, select, textarea");
                    } else {
                        var elements = document.querySelectorAll("input, select, textarea");
                    }

                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        var name = element.name;
                        var value = element.value;

                        if (name) {
                            ret[name] = value;
                        }
                    }

                    return ret;
                }

                obj.exists = function (url, __callback) {
                    var http = new XMLHttpRequest();
                    http.open('HEAD', url, false);
                    http.send();
                    if (http.status) {
                        __callback(http.status);
                    }
                }

                obj.getFiles = function (element) {
                    if (!element) {
                        console.error('No element defined in the arguments of your method');
                    }

                    // Get attachments
                    var files = element.querySelectorAll('.jfile');

                    if (files.length > 0) {
                        var data = [];
                        for (var i = 0; i < files.length; i++) {
                            var file = {};

                            var src = files[i].getAttribute('src');

                            if (files[i].classList.contains('jremove')) {
                                file.remove = 1;
                            } else {
                                if (src.substr(0, 4) == 'data') {
                                    file.content = src.substr(str.indexOf(',') + 1);
                                } else {
                                    file.file = src;

                                    if (jSuites.files[file.file]) {
                                        file.content = jSuites.files[file.file];
                                    }
                                }

                                file.extension = files[i].getAttribute('data-extension');

                                // Optional file information
                                if (files[i].getAttribute('data-name')) {
                                    file.name = files[i].getAttribute('data-name');
                                }

                                if (files[i].getAttribute('data-file')) {
                                    file.file = files[i].getAttribute('data-file');
                                }

                                if (files[i].getAttribute('data-size')) {
                                    file.size = files[i].getAttribute('data-size');
                                }

                                if (files[i].getAttribute('data-date')) {
                                    file.date = files[i].getAttribute('data-date');
                                }

                                if (files[i].getAttribute('data-cover')) {
                                    file.cover = files[i].getAttribute('data-cover');
                                }
                            }

                            // TODO SMALL thumbs?

                            data[i] = file;
                        }

                        return data;
                    }
                }

                obj.ajax = function (options) {
                    if (!options.data) {
                        options.data = {};
                    }

                    if (options.type) {
                        options.method = options.type;
                    }

                    var httpRequest = new XMLHttpRequest();
                    httpRequest.open(options.method, options.url, true);

                    if (options.method == 'POST') {
                        httpRequest.setRequestHeader('Accept', 'application/json');
                        httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                    } else {
                        if (options.dataType == 'json') {
                            httpRequest.setRequestHeader('Content-Type', 'text/json');
                        }
                    }

                    if (options.data) {
                        var data = [];
                        var keys = Object.keys(options.data);

                        if (keys.length) {
                            for (var i = 0; i < keys.length; i++) {
                                if (typeof (options.data[keys[i]]) == 'object') {
                                    var o = options.data[keys[i]];
                                    for (var j = 0; j < o.length; j++) {
                                        if (typeof (o[j]) == 'string') {
                                            data.push(keys[i] + '[' + j + ']=' + encodeURIComponent(o[j]));
                                        } else {
                                            var prop = Object.keys(o[j]);
                                            for (var z = 0; z < prop.length; z++) {
                                                data.push(keys[i] + '[' + j + '][' + prop[z] + ']=' + encodeURIComponent(o[j][prop[z]]));
                                            }
                                        }
                                    }
                                } else {
                                    data.push(keys[i] + '=' + encodeURIComponent(options.data[keys[i]]));
                                }
                            }
                        }
                    }

                    httpRequest.onload = function () {
                        if (httpRequest.status === 200) {
                            if (options.dataType == 'json') {
                                var result = JSON.parse(httpRequest.responseText);
                            } else {
                                var result = httpRequest.responseText;
                            }

                            if (options.success && typeof (options.success) == 'function') {
                                options.success(result);
                            }
                        } else {
                            if (options.error && typeof (options.error) == 'function') {
                                options.error(httpRequest.responseText);
                            }
                        }

                        // Global complete method
                        if (options.multiple && options.multiple.length) {
                            // Get index of this request in the container
                            var index = options.multiple[options.multiple.indexOf(httpRequest)];
                            // Remove from the ajax requests container
                            options.multiple.splice(index, 1);
                            // Last one?
                            if (!options.multiple.length) {
                                if (options.complete && typeof (options.complete) == 'function') {
                                    options.complete(result);
                                }
                            }
                        }
                    }

                    if (data) {
                        httpRequest.send(data.join('&'));
                    } else {
                        httpRequest.send();
                    }

                    return httpRequest;
                }

                obj.slideLeft = function (element, direction, done) {
                    if (direction == true) {
                        element.classList.add('slide-left-in');
                        setTimeout(function () {
                            element.classList.remove('slide-left-in');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    } else {
                        element.classList.add('slide-left-out');
                        setTimeout(function () {
                            element.classList.remove('slide-left-out');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    }
                }

                obj.slideRight = function (element, direction, done) {
                    if (direction == true) {
                        element.classList.add('slide-right-in');
                        setTimeout(function () {
                            element.classList.remove('slide-right-in');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    } else {
                        element.classList.add('slide-right-out');
                        setTimeout(function () {
                            element.classList.remove('slide-right-out');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    }
                }

                obj.slideTop = function (element, direction, done) {
                    if (direction == true) {
                        element.classList.add('slide-top-in');
                        setTimeout(function () {
                            element.classList.remove('slide-top-in');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    } else {
                        element.classList.add('slide-top-out');
                        setTimeout(function () {
                            element.classList.remove('slide-top-out');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    }
                }

                obj.slideBottom = function (element, direction, done) {
                    if (direction == true) {
                        element.classList.add('slide-bottom-in');
                        setTimeout(function () {
                            element.classList.remove('slide-bottom-in');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    } else {
                        element.classList.add('slide-bottom-out');
                        setTimeout(function () {
                            element.classList.remove('slide-bottom-out');
                            if (typeof (done) == 'function') {
                                done();
                            }
                        }, 400);
                    }
                }

                obj.fadeIn = function (element, done) {
                    element.classList.add('fade-in');
                    setTimeout(function () {
                        element.classList.remove('fade-in');
                        if (typeof (done) == 'function') {
                            done();
                        }
                    }, 2000);
                }

                obj.fadeOut = function (element, done) {
                    element.classList.add('fade-out');
                    setTimeout(function () {
                        element.classList.remove('fade-out');
                        if (typeof (done) == 'function') {
                            done();
                        }
                    }, 1000);
                }

                obj.keyDownControls = function (e) {
                    if (e.which == 27) {
                        var nodes = document.querySelectorAll('.jmodal');
                        if (nodes.length > 0) {
                            for (var i = 0; i < nodes.length; i++) {
                                nodes[i].modal.close();
                            }
                        }

                        var nodes = document.querySelectorAll('.jslider');
                        if (nodes.length > 0) {
                            for (var i = 0; i < nodes.length; i++) {
                                nodes[i].slider.close();
                            }
                        }

                        if (document.querySelector('.jdialog')) {
                            jSuites.dialog.close();
                        }
                    } else if (e.which == 13) {
                        if (document.querySelector('.jdialog')) {
                            if (typeof (jSuites.dialog.options.onconfirm) == 'function') {
                                jSuites.dialog.options.onconfirm();
                            }
                            jSuites.dialog.close();
                        }
                    }

                    // Verify mask
                    if (jSuites.mask) {
                        jSuites.mask.apply(e);
                    }
                }

                obj.actionUpControl = function (e) {
                    var element = null;
                    if (element = jSuites.getLinkElement(e.target)) {
                        var link = element.getAttribute('data-href');
                        if (link == '#back') {
                            window.history.back();
                        } else if (link == '#panel') {
                            jSuites.panel();
                        } else {
                            jSuites.pages(link);
                        }
                    }
                }

                var controlSwipeLeft = function (e) {
                    var element = jSuites.getElement(e.target, 'option');

                    if (element && element.querySelector('.option-actions')) {
                        element.scrollTo({
                            left: 100,
                            behavior: 'smooth'
                        });
                    } else {
                        var element = jSuites.getElement(e.target, 'jcalendar');
                        if (element && jSuites.calendar.current) {
                            jSuites.calendar.current.prev();
                        } else {
                            if (jSuites.panel.get()) {
                                jSuites.panel.close();
                            }
                        }
                    }
                }

                var controlSwipeRight = function (e) {
                    var element = jSuites.getElement(e.target, 'option');
                    if (element && element.querySelector('.option-actions')) {
                        element.scrollTo({
                            left: 0,
                            behavior: 'smooth'
                        });
                    } else {
                        var element = jSuites.getElement(e.target, 'jcalendar');
                        if (element && jSuites.calendar.current) {
                            jSuites.calendar.current.next();
                        } else {
                            var element = jSuites.panel.get();
                            if (element) {
                                if (element.style.display == 'none') {
                                    jSuites.panel();
                                }
                            }
                        }
                    }
                }

                // Create page container
                document.addEventListener('swipeleft', controlSwipeLeft);
                document.addEventListener('swiperight', controlSwipeRight);
                document.addEventListener('touchend', obj.actionUpControl);
                document.addEventListener('keydown', obj.keyDownControls);

                // Pop state control
                window.onpopstate = function (e) {
                    if (e.state && e.state.route) {
                        if (jSuites.pages.get(e.state.route)) {
                            jSuites.pages(e.state.route, true);
                        }
                    }
                }

                return obj;
            }();

            jSuites.files = [];

            jSuites.calendar = (function (el, options) {
                var obj = {};
                obj.options = {};

                // Global container
                if (!jSuites.dropdown.current) {
                    jSuites.dropdown.current = null;
                }

                // Default configuration
                var defaults = {
                    // Date format
                    format: 'DD/MM/YYYY',
                    // Allow keyboard date entry
                    readonly: 0,
                    // Today is default
                    today: 0,
                    // Show timepicker
                    time: 0,
                    // Show the reset button
                    resetButton: true,
                    // Placeholder
                    placeholder: '',
                    // Translations can be done here
                    months: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                    weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    weekdays_short: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                    // Value
                    value: null,
                    // Events
                    onclose: null,
                    onchange: null,
                    // Fullscreen (this is automatic set for screensize < 800)
                    fullscreen: false,
                    // Internal mode controller
                    mode: null,
                    position: null,
                };

                // Loop through our object
                for (var property in defaults) {
                    if (options && options.hasOwnProperty(property)) {
                        obj.options[property] = options[property];
                    } else {
                        obj.options[property] = defaults[property];
                    }
                }

                // Value
                if (!obj.options.value && el.value) {
                    obj.options.value = el.value;
                }

                // Make sure use upper case in the format
                obj.options.format = obj.options.format.toUpperCase();

                if (obj.options.value) {
                    var date = obj.options.value.split(' ');
                    var time = date[1];
                    var date = date[0].split('-');
                    var y = parseInt(date[0]);
                    var m = parseInt(date[1]);
                    var d = parseInt(date[2]);

                    if (time) {
                        var time = time.split(':');
                        var h = parseInt(time[0]);
                        var i = parseInt(time[1]);
                    } else {
                        var h = 0;
                        var i = 0;
                    }
                } else {
                    var date = new Date();
                    var y = date.getFullYear();
                    var m = date.getMonth() + 1;
                    var d = date.getDate();
                    var h = date.getHours();
                    var i = date.getMinutes();
                }

                // Current value
                obj.date = [y, m, d, h, i, 0];

                // Two digits
                var two = function (value) {
                    value = '' + value;
                    if (value.length == 1) {
                        value = '0' + value;
                    }
                    return value;
                }

                // Calendar elements
                var calendarReset = document.createElement('div');
                calendarReset.className = 'jcalendar-reset';
                calendarReset.innerHTML = 'Reset';

                var calendarConfirm = document.createElement('div');
                calendarConfirm.className = 'jcalendar-confirm';
                calendarConfirm.innerHTML = 'Done';

                var calendarControls = document.createElement('div');
                calendarControls.className = 'jcalendar-controls'
                if (obj.options.resetButton) {
                    calendarControls.appendChild(calendarReset);
                }
                calendarControls.appendChild(calendarConfirm);

                var calendarContainer = document.createElement('div');
                calendarContainer.className = 'jcalendar-container';

                var calendarContent = document.createElement('div');
                calendarContent.className = 'jcalendar-content';
                calendarContent.appendChild(calendarControls);
                calendarContainer.appendChild(calendarContent);

                // Main element
                var calendar = document.createElement('div');
                calendar.className = 'jcalendar';
                calendar.appendChild(calendarContainer);

                // Previous button
                var calendarHeaderPrev = document.createElement('td');
                calendarHeaderPrev.setAttribute('colspan', '2');
                calendarHeaderPrev.className = 'jcalendar-prev';

                // Header with year and month
                var calendarLabelYear = document.createElement('span');
                calendarLabelYear.className = 'jcalendar-year';

                var calendarLabelMonth = document.createElement('span');
                calendarLabelMonth.className = 'jcalendar-month';

                var calendarHeaderTitle = document.createElement('td');
                calendarHeaderTitle.className = 'jcalendar-header';
                calendarHeaderTitle.setAttribute('colspan', '3');
                calendarHeaderTitle.appendChild(calendarLabelMonth);
                calendarHeaderTitle.appendChild(calendarLabelYear);

                var calendarHeaderNext = document.createElement('td');
                calendarHeaderNext.setAttribute('colspan', '2');
                calendarHeaderNext.className = 'jcalendar-next';

                var calendarHeaderRow = document.createElement('tr');
                calendarHeaderRow.appendChild(calendarHeaderPrev);
                calendarHeaderRow.appendChild(calendarHeaderTitle);
                calendarHeaderRow.appendChild(calendarHeaderNext);

                var calendarHeader = document.createElement('thead');
                calendarHeader.appendChild(calendarHeaderRow);

                var calendarBody = document.createElement('tbody');
                var calendarFooter = document.createElement('tfoot');

                // Calendar table
                var calendarTable = document.createElement('table');
                calendarTable.setAttribute('cellpadding', '0');
                calendarTable.setAttribute('cellspacing', '0');
                calendarTable.appendChild(calendarHeader);
                calendarTable.appendChild(calendarBody);
                calendarTable.appendChild(calendarFooter);
                calendarContent.appendChild(calendarTable);

                var calendarSelectHour = document.createElement('select');
                calendarSelectHour.onchange = function () {
                    obj.date[3] = this.value;
                }

                for (var i = 0; i < 24; i++) {
                    var element = document.createElement('option');
                    element.value = i;
                    element.innerHTML = two(i);
                    calendarSelectHour.appendChild(element);
                }

                var calendarSelectMin = document.createElement('select');
                calendarSelectMin.onchange = function () {
                    obj.date[4] = this.value;
                }

                for (var i = 0; i < 60; i++) {
                    var element = document.createElement('option');
                    element.value = i;
                    element.innerHTML = two(i);
                    calendarSelectMin.appendChild(element);
                }

                // Footer controls
                var calendarControls = document.createElement('div');
                calendarControls.className = 'jcalendar-controls';

                var calendarControlsTime = document.createElement('div');
                calendarControlsTime.className = 'jcalendar-time';
                calendarControlsTime.style.maxWidth = '140px';
                calendarControlsTime.appendChild(calendarSelectHour);
                calendarControlsTime.appendChild(calendarSelectMin);

                var calendarControlsUpdate = document.createElement('div');
                calendarControlsUpdate.style.flexGrow = '10';
                calendarControlsUpdate.innerHTML = '<input type="button" class="jcalendar-update" value="Update">'
                calendarControls.appendChild(calendarControlsTime);
                calendarControls.appendChild(calendarControlsUpdate);
                calendarContent.appendChild(calendarControls);

                var calendarBackdrop = document.createElement('div');
                calendarBackdrop.className = 'jcalendar-backdrop';
                calendar.appendChild(calendarBackdrop);

                // Methods
                obj.open = function (value) {
                    if (jSuites.calendar.current) {
                        if (jSuites.calendar.current != obj) {
                            jSuites.calendar.current.close();
                        }
                    }

                    if (!jSuites.calendar.current) {
                        jSuites.calendar.current = obj;
                        // Show calendar
                        calendar.classList.add('jcalendar-focus');
                        // Get days
                        obj.getDays();
                        // Hour
                        if (obj.options.time) {
                            calendarSelectHour.value = obj.date[3];
                            calendarSelectMin.value = obj.date[4];
                        }

                        // Get the position of the corner helper
                        if (jSuites.getWindowWidth() < 800 || obj.options.fullscreen) {
                            // Full
                            calendar.classList.add('jcalendar-fullsize');
                            // Animation
                            calendarContent.classList.add('slide-bottom-in');
                        } else {
                            const rect = el.getBoundingClientRect();
                            const rectContent = calendarContent.getBoundingClientRect();

                            if (obj.options.position) {
                                calendarContainer.style.position = 'fixed';
                                if (window.innerHeight < rect.bottom + rectContent.height) {
                                    calendarContainer.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                                } else {
                                    calendarContainer.style.top = (rect.top + rect.height + 2) + 'px';
                                }
                            } else {
                                if (window.innerHeight < rect.bottom + rectContent.height) {
                                    calendarContainer.style.bottom = (1 * rect.height + rectContent.height + 2) + 'px';
                                } else {
                                    calendarContainer.style.top = 2 + 'px';
                                }
                            }
                        }
                    }
                }

                obj.close = function (ignoreEvents, update) {
                    if (jSuites.calendar.current) {
                        jSuites.calendar.current = null;

                        if (update != false && el.tagName == 'INPUT') {
                            obj.setValue(obj.getValue());
                        }

                        if (!ignoreEvents && typeof (obj.options.onclose) == 'function') {
                            obj.options.onclose(el);
                        }

                        // Animation
                        calendarContainer.classList.remove('slide-bottom-in');
                        calendar.classList.remove('jcalendar-focus');
                    }

                    return obj.getValue();
                }

                obj.prev = function () {
                    // Check if the visualization is the days picker or years picker
                    if (obj.options.mode == 'years') {
                        obj.date[0] = obj.date[0] - 12;

                        // Update picker table of days
                        obj.getYears();
                    } else {
                        // Go to the previous month
                        if (obj.date[1] < 2) {
                            obj.date[0] = obj.date[0] - 1;
                            obj.date[1] = 1;
                        } else {
                            obj.date[1] = obj.date[1] - 1;
                        }

                        // Update picker table of days
                        obj.getDays();
                    }
                }

                obj.next = function () {
                    // Check if the visualization is the days picker or years picker
                    if (obj.options.mode == 'years') {
                        obj.date[0] = parseInt(obj.date[0]) + 12;

                        // Update picker table of days
                        obj.getYears();
                    } else {
                        // Go to the previous month
                        if (obj.date[1] > 11) {
                            obj.date[0] = obj.date[0] + 1;
                            obj.date[1] = 1;
                        } else {
                            obj.date[1] = obj.date[1] + 1;
                        }

                        // Update picker table of days
                        obj.getDays();
                    }
                }

                obj.setValue = function (val) {
                    if (val) {
                        // Keep value
                        obj.options.value = val;
                        // Set label
                        var value = obj.setLabel(val, obj.options.format);
                        var date = obj.options.value.split(' ');
                        if (!date[1]) {
                            date[1] = '00:00:00';
                        }
                        var time = date[1].split(':')
                        var date = date[0].split('-');
                        var y = parseInt(date[0]);
                        var m = parseInt(date[1]);
                        var d = parseInt(date[2]);
                        var h = parseInt(time[0]);
                        var i = parseInt(time[1]);
                        obj.date = [y, m, d, h, i, 0];
                        var val = obj.setLabel(val, obj.options.format);

                        if (el.value != val) {
                            el.value = val;
                            // On change
                            if (typeof (obj.options.onchange) == 'function') {
                                obj.options.onchange(el, val, obj.date);
                            }
                        }

                        obj.getDays();
                    }
                }

                obj.getValue = function () {
                    if (obj.date) {
                        if (obj.options.time) {
                            return two(obj.date[0]) + '-' + two(obj.date[1]) + '-' + two(obj.date[2]) + ' ' + two(obj.date[3]) + ':' + two(obj.date[4]) + ':' + two(0);
                        } else {
                            return two(obj.date[0]) + '-' + two(obj.date[1]) + '-' + two(obj.date[2]) + ' ' + two(0) + ':' + two(0) + ':' + two(0);
                        }
                    } else {
                        return "";
                    }
                }

                /**
                 * Update calendar
                 */
                obj.update = function (element) {
                    obj.date[2] = element.innerText;

                    if (!obj.options.time) {
                        obj.close();
                    } else {
                        obj.date[3] = calendarSelectHour.value;
                        obj.date[4] = calendarSelectMin.value;
                    }

                    var elements = calendar.querySelector('.jcalendar-selected');
                    if (elements) {
                        elements.classList.remove('jcalendar-selected');
                    }
                    element.classList.add('jcalendar-selected')
                }

                /**
                 * Set to blank
                 */
                obj.reset = function () {
                    // Clear element
                    obj.date = null;
                    // Reset element
                    el.value = '';
                    // Close calendar
                    obj.close();
                }

                /**
                 * Get calendar days
                 */
                obj.getDays = function () {
                    // Mode
                    obj.options.mode = 'days';

                    // Variables
                    var d = 0;
                    var today = 0;
                    var today_d = 0;
                    var calendar_day;

                    // Setting current values in case of NULLs
                    var date = new Date();

                    var year = obj.date && obj.date[0] ? obj.date[0] : parseInt(date.getFullYear());
                    var month = obj.date && obj.date[1] ? obj.date[1] : parseInt(date.getMonth()) + 1;
                    var day = obj.date && obj.date[2] ? obj.date[2] : parseInt(date.getDay());
                    var hour = obj.date && obj.date[3] ? obj.date[3] : parseInt(date.getHours());
                    var min = obj.date && obj.date[4] ? obj.date[4] : parseInt(date.getMinutes());

                    obj.date = [year, month, day, hour, min, 0];

                    // Update title
                    calendarLabelYear.innerHTML = year;
                    calendarLabelMonth.innerHTML = obj.options.months[month - 1];

                    // Flag if this is the current month and year
                    if ((date.getMonth() == month - 1) && (date.getFullYear() == year)) {
                        today = 1;
                        today_d = date.getDate();
                    }

                    var date = new Date(year, month, 0, 0, 0);
                    var nd = date.getDate();

                    var date = new Date(year, month - 1, 0, hour, min);
                    var fd = date.getDay() + 1;

                    // Reset table
                    calendarBody.innerHTML = '';

                    // Weekdays Row
                    var row = document.createElement('tr');
                    row.setAttribute('align', 'center');
                    calendarBody.appendChild(row);

                    for (var i = 0; i < 7; i++) {
                        var cell = document.createElement('td');
                        cell.setAttribute('width', '30');
                        cell.classList.add('jcalendar-weekday')
                        cell.innerHTML = obj.options.weekdays_short[i];
                        row.appendChild(cell);
                    }

                    // Avoid a blank line
                    if (fd == 7) {
                        var j = 7;
                    } else {
                        var j = 0;
                    }

                    // Days inside the table
                    var row = document.createElement('tr');
                    row.setAttribute('align', 'center');
                    calendarBody.appendChild(row);

                    // Days in the month
                    for (var i = j; i < (Math.ceil((nd + fd) / 7) * 7); i++) {
                        // Create row
                        if ((i > 0) && (!(i % 7))) {
                            var row = document.createElement('tr');
                            row.setAttribute('align', 'center');
                            calendarBody.appendChild(row);
                        }

                        if ((i >= fd) && (i < nd + fd)) {
                            d += 1;
                        } else {
                            d = 0;
                        }

                        // Create cell
                        var cell = document.createElement('td');
                        cell.setAttribute('width', '30');
                        cell.classList.add('jcalendar-set-day');
                        row.appendChild(cell);

                        if (d == 0) {
                            cell.innerHTML = '';
                        } else {
                            if (d < 10) {
                                cell.innerHTML = 0 + d;
                            } else {
                                cell.innerHTML = d;
                            }
                        }

                        // Selected
                        if (d && d == day) {
                            cell.classList.add('jcalendar-selected');
                        }

                        // Sundays
                        if (!(i % 7)) {
                            cell.style.color = 'red';
                        }

                        // Today
                        if ((today == 1) && (today_d == d)) {
                            cell.style.fontWeight = 'bold';
                        }
                    }

                    // Show time controls
                    if (obj.options.time) {
                        calendarControlsTime.style.display = '';
                    } else {
                        calendarControlsTime.style.display = 'none';
                    }
                }

                obj.getMonths = function () {
                    // Mode
                    obj.options.mode = 'months';

                    // Loading month labels
                    var months = obj.options.months;

                    // Update title
                    calendarLabelYear.innerHTML = obj.date[0];
                    calendarLabelMonth.innerHTML = '';

                    // Create months table
                    var html = '<td colspan="7"><table width="100%"><tr align="center">';

                    for (i = 0; i < 12; i++) {
                        if ((i > 0) && (!(i % 4))) {
                            html += '</tr><tr align="center">';
                        }
                        month = parseInt(i) + 1;
                        html += '<td class="jcalendar-set-month" data-value="' + month + '">' + months[i] + '</td>';
                    }

                    html += '</tr></table></td>';

                    calendarBody.innerHTML = html;
                }

                obj.getYears = function () {
                    // Mode
                    obj.options.mode = 'years';

                    // Array of years
                    var y = [];
                    for (i = 0; i < 25; i++) {
                        y[i] = parseInt(obj.date[0]) + (i - 12);
                    }

                    // Assembling the year tables
                    var html = '<td colspan="7"><table width="100%"><tr align="center">';

                    for (i = 0; i < 25; i++) {
                        if ((i > 0) && (!(i % 5))) {
                            html += '</tr><tr align="center">';
                        }
                        html += '<td class="jcalendar-set-year">' + y[i] + '</td>';
                    }

                    html += '</tr></table></td>';

                    calendarBody.innerHTML = html;
                }

                obj.setLabel = function (value, format) {
                    return jSuites.calendar.getDateString(value, format);
                }

                obj.fromFormatted = function (value, format) {
                    return jSuites.calendar.extractDateFromString(value, format);
                }

                // Add properties
                el.setAttribute('autocomplete', 'off');
                el.setAttribute('data-mask', obj.options.format.toLowerCase());

                if (obj.options.readonly) {
                    el.setAttribute('readonly', 'readonly');
                }

                if (obj.options.placeholder) {
                    el.setAttribute('placeholder', obj.options.placeholder);
                }

                // Handle events
                el.addEventListener("focus", function (e) {
                    obj.open();
                });

                el.addEventListener("mousedown", function (e) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    obj.open();
                });

                el.addEventListener("keyup", function (e) {
                    if (e.target.value && e.target.value.length > 3) {
                        var test = jSuites.calendar.extractDateFromString(e.target.value, obj.options.format);
                        if (test) {
                            if (e.target.getAttribute('data-completed') == 'true') {
                                obj.setValue(test);
                            }
                        }
                    }
                });

                if (!jSuites.calendar.hasEvents) {
                    // Add global events
                    document.addEventListener("swipeleft", function (e) {
                        if (calendar.classList.contains('jcalendar-focus')) {
                            obj.prev();
                        }
                    });

                    document.addEventListener("swiperight", function (e) {
                        if (calendar.classList.contains('jcalendar-focus')) {
                            obj.next();
                        }
                    });

                    document.addEventListener("mousedown", jSuites.calendar.mouseDownControls);

                    // Has events
                    jSuites.calendar.hasEvents = true;
                }

                // Append element to the DOM
                el.parentNode.insertBefore(calendar, el.nextSibling);

                // Keep object available from the node
                el.calendar = obj;

                return obj;
            });

            jSuites.calendar.prettify = function (d, texts) {
                if (!texts) {
                    var texts = {
                        justNow: 'Just now',
                        xMinutesAgo: '{0} minutes ago',
                        xHoursAgo: '{0} hours ago',
                        xDaysAgo: '{0} days ago',
                        xWeeksAgo: '{0} weeks ago',
                        xMonthsAgo: '{0} months ago',
                        xYearsAgo: '{0} years ago',
                    }
                }

                var d1 = new Date();
                var d2 = new Date(d);
                var total = parseInt((d1 - d2) / 1000 / 60);

                String.prototype.format = function (o) {
                    return this.replace('{0}', o);
                }

                if (total == 0) {
                    var text = texts.justNow;
                } else if (total < 90) {
                    var text = texts.xMinutesAgo.format(total);
                } else if (total < 1440) { // One day
                    var text = texts.xHoursAgo.format(Math.round(total / 60));
                } else if (total < 20160) { // 14 days
                    var text = texts.xDaysAgo.format(Math.round(total / 1440));
                } else if (total < 43200) { // 30 days
                    var text = texts.xWeeksAgo.format(Math.round(total / 10080));
                } else if (total < 1036800) { // 24 months
                    var text = texts.xMonthsAgo.format(Math.round(total / 43200));
                } else { // 24 months+
                    var text = texts.xYearsAgo.format(Math.round(total / 525600));
                }

                return text;
            }

            jSuites.calendar.prettifyAll = function () {
                var elements = document.querySelectorAll('.prettydate');
                for (var i = 0; i < elements.length; i++) {
                    if (elements[i].getAttribute('data-date')) {
                        elements[i].innerHTML = jSuites.calendar.prettify(elements[i].getAttribute('data-date'));
                    } else {
                        elements[i].setAttribute('data-date', elements[i].innerHTML);
                        elements[i].innerHTML = jSuites.calendar.prettify(elements[i].innerHTML);
                    }
                }
            }

            jSuites.calendar.now = function () {
                var date = new Date();
                var y = date.getFullYear();
                var m = date.getMonth() + 1;
                var d = date.getDate();
                var h = date.getHours();
                var i = date.getMinutes();
                var s = date.getSeconds();

                // Two digits
                var two = function (value) {
                    value = '' + value;
                    if (value.length == 1) {
                        value = '0' + value;
                    }
                    return value;
                }

                return two(y) + '-' + two(m) + '-' + two(d) + ' ' + two(h) + ':' + two(i) + ':' + two(s);
            }

            // Helper to extract date from a string
            jSuites.calendar.extractDateFromString = function (date, format) {
                var v1 = '' + date;
                var v2 = format.replace(/[0-9]/g, '');

                var test = 1;

                // Get year
                var y = v2.search("YYYY");
                y = v1.substr(y, 4);
                if (parseInt(y) != y) {
                    test = 0;
                }

                // Get month
                var m = v2.search("MM");
                m = v1.substr(m, 2);
                if (parseInt(m) != m || d > 12) {
                    test = 0;
                }

                // Get day
                var d = v2.search("DD");
                d = v1.substr(d, 2);
                if (parseInt(d) != d || d > 31) {
                    test = 0;
                }

                // Get hour
                var h = v2.search("HH");
                if (h >= 0) {
                    h = v1.substr(h, 2);
                    if (!parseInt(h) || h > 23) {
                        h = '00';
                    }
                } else {
                    h = '00';
                }

                // Get minutes
                var i = v2.search("MI");
                if (i >= 0) {
                    i = v1.substr(i, 2);
                    if (!parseInt(i) || i > 59) {
                        i = '00';
                    }
                } else {
                    i = '00';
                }

                // Get seconds
                var s = v2.search("SS");
                if (s >= 0) {
                    s = v1.substr(s, 2);
                    if (!parseInt(s) || s > 59) {
                        s = '00';
                    }
                } else {
                    s = '00';
                }

                if (test == 1 && date.length == format.length) {
                    // Update source
                    var data = y + '-' + m + '-' + d + ' ' + h + ':' + i + ':' + s;

                    return data;
                }

                return '';
            }

            // Helper to convert date into string
            jSuites.calendar.getDateString = function (value, format) {
                // Default calendar
                if (!format) {
                    var format = 'DD/MM/YYYY';
                }

                if (value) {
                    var d = '' + value;
                    d = d.split(' ');

                    var h = '';
                    var m = '';
                    var s = '';

                    if (d[1]) {
                        h = d[1].split(':');
                        m = h[1];
                        s = h[2];
                        h = h[0];
                    } else {
                        h = '00';
                        m = '00';
                        s = '00';
                    }

                    d = d[0].split('-');

                    if (d[0] && d[1] && d[2] && d[0] > 0 && d[1] > 0 && d[1] < 13 && d[2] > 0 && d[2] < 32) {
                        var calendar = new Date(d[0], d[1] - 1, d[2]);
                        var weekday = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday');

                        d[1] = (d[1].length < 2 ? '0' : '') + d[1];
                        d[2] = (d[2].length < 2 ? '0' : '') + d[2];
                        h = (h.length < 2 ? '0' : '') + h;
                        m = (m.length < 2 ? '0' : '') + m;
                        s = (s.length < 2 ? '0' : '') + s;

                        value = format;
                        value = value.replace('WD', weekday[calendar.getDay()]);
                        value = value.replace('DD', d[2]);
                        value = value.replace('MM', d[1]);
                        value = value.replace('YYYY', d[0]);
                        value = value.replace('YY', d[0].substring(2, 4));

                        if (h) {
                            value = value.replace('HH24', h);
                        }

                        if (h > 12) {
                            value = value.replace('HH12', h - 12);
                            value = value.replace('HH', h);
                        } else {
                            value = value.replace('HH12', h);
                            value = value.replace('HH', h);
                        }

                        value = value.replace('MI', m);
                        value = value.replace('MM', m);
                        value = value.replace('SS', s);
                    } else {
                        value = '';
                    }
                }

                return value;
            }

            jSuites.calendar.mouseDownControls = function (e) {
                if (!jSuites.getElement(e.target, 'jcalendar')) {
                    if (jSuites.calendar.current) {
                        jSuites.calendar.current.close(false, false);
                    }
                } else {
                    if (jSuites.calendar.current) {
                        var action = e.target.className;

                        // Object id
                        if (action == 'jcalendar-prev') {
                            jSuites.calendar.current.prev();
                        } else if (action == 'jcalendar-next') {
                            jSuites.calendar.current.next();
                        } else if (action == 'jcalendar-month') {
                            jSuites.calendar.current.getMonths();
                        } else if (action == 'jcalendar-year') {
                            jSuites.calendar.current.getYears();
                        } else if (action == 'jcalendar-set-year') {
                            jSuites.calendar.current.date[0] = e.target.innerText;
                            jSuites.calendar.current.getDays();
                        } else if (action == 'jcalendar-set-month') {
                            jSuites.calendar.current.date[1] = parseInt(e.target.getAttribute('data-value'));
                            jSuites.calendar.current.getDays();
                        } else if (action == 'jcalendar-confirm' || action == 'jcalendar-update') {
                            jSuites.calendar.current.close();
                        } else if (action == 'jcalendar-close') {
                            jSuites.calendar.current.close();
                        } else if (action == 'jcalendar-backdrop') {
                            jSuites.calendar.current.close(false, false);
                        } else if (action == 'jcalendar-reset') {
                            jSuites.calendar.current.reset();
                        } else if (e.target.classList.contains('jcalendar-set-day')) {
                            if (e.target.innerText) {
                                // Keep selected day
                                jSuites.calendar.current.update(e.target);
                            }
                        }

                        if (action.substr(0, 9) == 'jcalendar') {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                    }
                }
            }

            /**
             * Color Picker v1.0.1
             * Author: paul.hodel@gmail.com
             * https://github.com/paulhodel/jtools
             */

            jSuites.color = (function (el, options) {
                var obj = {};
                obj.options = {};
                obj.values = [];

                // Global container
                if (!jSuites.color.current) {
                    jSuites.color.current = null;
                }

                // Default configuration
                var defaults = {
                    placeholder: '',
                    value: null,
                    onclose: null,
                    onchange: null,
                    position: null,
                };

                // Loop through our object
                for (var property in defaults) {
                    if (options && options.hasOwnProperty(property)) {
                        obj.options[property] = options[property];
                    } else {
                        obj.options[property] = defaults[property];
                    }
                }

                var x = 0;
                var y = 0;
                var z = 0;

                var palette = {
                    "red": {
                        "50": "#ffebee",
                        "100": "#ffcdd2",
                        "200": "#ef9a9a",
                        "300": "#e57373",
                        "400": "#ef5350",
                        "500": "#f44336",
                        "600": "#e53935",
                        "700": "#d32f2f",
                        "800": "#c62828",
                        "900": "#b71c1c",
                    },
                    "pink": {
                        "50": "#fce4ec",
                        "100": "#f8bbd0",
                        "200": "#f48fb1",
                        "300": "#f06292",
                        "400": "#ec407a",
                        "500": "#e91e63",
                        "600": "#d81b60",
                        "700": "#c2185b",
                        "800": "#ad1457",
                        "900": "#880e4f",
                    },
                    "purple": {
                        "50": "#f3e5f5",
                        "100": "#e1bee7",
                        "200": "#ce93d8",
                        "300": "#ba68c8",
                        "400": "#ab47bc",
                        "500": "#9c27b0",
                        "600": "#8e24aa",
                        "700": "#7b1fa2",
                        "800": "#6a1b9a",
                        "900": "#4a148c",
                    },
                    "deeppurple": {
                        "50": "#ede7f6",
                        "100": "#d1c4e9",
                        "200": "#b39ddb",
                        "300": "#9575cd",
                        "400": "#7e57c2",
                        "500": "#673ab7",
                        "600": "#5e35b1",
                        "700": "#512da8",
                        "800": "#4527a0",
                        "900": "#311b92",
                    },
                    "indigo": {
                        "50": "#e8eaf6",
                        "100": "#c5cae9",
                        "200": "#9fa8da",
                        "300": "#7986cb",
                        "400": "#5c6bc0",
                        "500": "#3f51b5",
                        "600": "#3949ab",
                        "700": "#303f9f",
                        "800": "#283593",
                        "900": "#1a237e",
                    },
                    "blue": {
                        "50": "#e3f2fd",
                        "100": "#bbdefb",
                        "200": "#90caf9",
                        "300": "#64b5f6",
                        "400": "#42a5f5",
                        "500": "#2196f3",
                        "600": "#1e88e5",
                        "700": "#1976d2",
                        "800": "#1565c0",
                        "900": "#0d47a1",
                    },
                    "lightblue": {
                        "50": "#e1f5fe",
                        "100": "#b3e5fc",
                        "200": "#81d4fa",
                        "300": "#4fc3f7",
                        "400": "#29b6f6",
                        "500": "#03a9f4",
                        "600": "#039be5",
                        "700": "#0288d1",
                        "800": "#0277bd",
                        "900": "#01579b",
                    },
                    "cyan": {
                        "50": "#e0f7fa",
                        "100": "#b2ebf2",
                        "200": "#80deea",
                        "300": "#4dd0e1",
                        "400": "#26c6da",
                        "500": "#00bcd4",
                        "600": "#00acc1",
                        "700": "#0097a7",
                        "800": "#00838f",
                        "900": "#006064",
                    },
                    "teal": {
                        "50": "#e0f2f1",
                        "100": "#b2dfdb",
                        "200": "#80cbc4",
                        "300": "#4db6ac",
                        "400": "#26a69a",
                        "500": "#009688",
                        "600": "#00897b",
                        "700": "#00796b",
                        "800": "#00695c",
                        "900": "#004d40",
                    },
                    "green": {
                        "50": "#e8f5e9",
                        "100": "#c8e6c9",
                        "200": "#a5d6a7",
                        "300": "#81c784",
                        "400": "#66bb6a",
                        "500": "#4caf50",
                        "600": "#43a047",
                        "700": "#388e3c",
                        "800": "#2e7d32",
                        "900": "#1b5e20",
                    },
                    "lightgreen": {
                        "50": "#f1f8e9",
                        "100": "#dcedc8",
                        "200": "#c5e1a5",
                        "300": "#aed581",
                        "400": "#9ccc65",
                        "500": "#8bc34a",
                        "600": "#7cb342",
                        "700": "#689f38",
                        "800": "#558b2f",
                        "900": "#33691e",
                    },
                    "lime": {
                        "50": "#f9fbe7",
                        "100": "#f0f4c3",
                        "200": "#e6ee9c",
                        "300": "#dce775",
                        "400": "#d4e157",
                        "500": "#cddc39",
                        "600": "#c0ca33",
                        "700": "#afb42b",
                        "800": "#9e9d24",
                        "900": "#827717",
                    },
                    "yellow": {
                        "50": "#fffde7",
                        "100": "#fff9c4",
                        "200": "#fff59d",
                        "300": "#fff176",
                        "400": "#ffee58",
                        "500": "#ffeb3b",
                        "600": "#fdd835",
                        "700": "#fbc02d",
                        "800": "#f9a825",
                        "900": "#f57f17",
                    },
                    "amber": {
                        "50": "#fff8e1",
                        "100": "#ffecb3",
                        "200": "#ffe082",
                        "300": "#ffd54f",
                        "400": "#ffca28",
                        "500": "#ffc107",
                        "600": "#ffb300",
                        "700": "#ffa000",
                        "800": "#ff8f00",
                        "900": "#ff6f00",
                    },
                    "orange": {
                        "50": "#fff3e0",
                        "100": "#ffe0b2",
                        "200": "#ffcc80",
                        "300": "#ffb74d",
                        "400": "#ffa726",
                        "500": "#ff9800",
                        "600": "#fb8c00",
                        "700": "#f57c00",
                        "800": "#ef6c00",
                        "900": "#e65100",
                    },
                    "deeporange": {
                        "50": "#fbe9e7",
                        "100": "#ffccbc",
                        "200": "#ffab91",
                        "300": "#ff8a65",
                        "400": "#ff7043",
                        "500": "#ff5722",
                        "600": "#f4511e",
                        "700": "#e64a19",
                        "800": "#d84315",
                        "900": "#bf360c",
                    },
                    "brown": {
                        "50": "#efebe9",
                        "100": "#d7ccc8",
                        "200": "#bcaaa4",
                        "300": "#a1887f",
                        "400": "#8d6e63",
                        "500": "#795548",
                        "600": "#6d4c41",
                        "700": "#5d4037",
                        "800": "#4e342e",
                        "900": "#3e2723"
                    },
                    "grey": {
                        "50": "#fafafa",
                        "100": "#f5f5f5",
                        "200": "#eeeeee",
                        "300": "#e0e0e0",
                        "400": "#bdbdbd",
                        "500": "#9e9e9e",
                        "600": "#757575",
                        "700": "#616161",
                        "800": "#424242",
                        "900": "#212121"
                    },
                    "bluegrey": {
                        "50": "#eceff1",
                        "100": "#cfd8dc",
                        "200": "#b0bec5",
                        "300": "#90a4ae",
                        "400": "#78909c",
                        "500": "#607d8b",
                        "600": "#546e7a",
                        "700": "#455a64",
                        "800": "#37474f",
                        "900": "#263238"
                    }
                };

                var x = 0;
                var y = 0;
                var colors = [];

                Object.keys(palette).forEach(function (col) {
                    y = 0;
                    Object.keys(palette[col]).forEach(function (shade) {
                        if (!colors[y]) {
                            colors[y] = [];
                        }
                        colors[y][x] = palette[col][shade];
                        y++;
                    });
                    x++;
                });

                // Table container
                var container = document.createElement('div');
                container.className = 'jcolor';

                // Content
                var content = document.createElement('div');
                content.className = 'jcolor-content';

                // Table pallete
                var table = document.createElement('table');
                table.setAttribute('cellpadding', '7');
                table.setAttribute('cellspacing', '0');

                for (var i = 0; i < colors.length; i++) {
                    var tr = document.createElement('tr');
                    for (var j = 0; j < colors[i].length; j++) {
                        var td = document.createElement('td');
                        td.style.backgroundColor = colors[i][j];
                        td.setAttribute('data-value', colors[i][j]);
                        td.innerHTML = '';
                        tr.appendChild(td);

                        // Selected color
                        if (obj.options.value == colors[i][j]) {
                            td.classList.add('jcolor-selected');
                        }

                        // Possible values
                        obj.values[colors[i][j]] = td;
                    }
                    table.appendChild(tr);
                }

                /**
                 * Open color pallete
                 */
                obj.open = function () {
                    if (jSuites.color.current) {
                        if (jSuites.color.current != obj) {
                            jSuites.color.current.close();
                        }
                    }

                    if (!jSuites.color.current) {
                        // Persist element
                        jSuites.color.current = obj;
                        // Show colorpicker
                        container.classList.add('jcolor-focus');

                        const rect = el.getBoundingClientRect();
                        const rectContent = content.getBoundingClientRect();

                        if (obj.options.position) {
                            content.style.position = 'fixed';
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                content.style.top = (rect.top - (rectContent.height + 2)) + 'px';
                            } else {
                                content.style.top = (rect.top + rect.height + 2) + 'px';;
                            }
                        } else {
                            if (window.innerHeight < rect.bottom + rectContent.height) {
                                content.style.top = (-1 * (rectContent.height + 2)) + 'px';
                            } else {
                                content.style.top = (rect.height + 2) + 'px';
                            }
                        }

                        container.focus();
                    }
                }

                /**
                 * Close color pallete
                 */
                obj.close = function (ignoreEvents) {
                    if (jSuites.color.current) {
                        jSuites.color.current = null;
                        if (!ignoreEvents && typeof (obj.options.onclose) == 'function') {
                            obj.options.onclose(el);
                        }
                        container.classList.remove('jcolor-focus');
                    }

                    return obj.options.value;
                }

                /**
                 * Set value
                 */
                obj.setValue = function (color) {
                    if (color) {
                        el.value = color;
                        obj.options.value = color;
                    }

                    // Remove current selecded mark
                    var selected = container.querySelector('.jcolor-selected');
                    if (selected) {
                        selected.classList.remove('jcolor-selected');
                    }

                    // Mark cell as selected
                    obj.values[color].classList.add('jcolor-selected');

                    // Onchange
                    if (typeof (obj.options.onchange) == 'function') {
                        obj.options.onchange(el, color);
                    }
                }

                /**
                 * Get value
                 */
                obj.getValue = function () {
                    return obj.options.value;
                }

                /**
                 * If element is focus open the picker
                 */
                el.addEventListener("focus", function (e) {
                    obj.open();
                });

                // Select color
                container.addEventListener("click", function (e) {
                    if (e.target.tagName == 'TD') {
                        jSuites.color.current.setValue(e.target.getAttribute('data-value'));
                        jSuites.color.current.close();
                    }
                });

                // Possible to focus the container
                container.setAttribute('tabindex', '900');

                if (obj.options.placeholder) {
                    el.setAttribute('placeholder', obj.options.placeholder);
                }

                // Append to the table
                content.appendChild(table);
                container.appendChild(content);
                container.onblur = function (e) {
                    setTimeout(function () {
                        if (jSuites.color.current) {
                            jSuites.color.current.close();
                        }
                    }, 200);
                }

                // Insert picker after the element
                el.parentNode.insertBefore(container, el);

                // Keep object available from the node
                el.color = obj;

                return obj;
            });

            jSuites.contextmenu = (function (el, options) {
                var obj = {};
                obj.options = {};

                // Default configuration
                var defaults = {
                    items: null,
                };

                // Loop through our object
                for (var property in defaults) {
                    if (options && options.hasOwnProperty(property)) {
                        obj.options[property] = options[property];
                    } else {
                        obj.options[property] = defaults[property];
                    }
                }

                obj.menu = document.createElement('ul');
                obj.menu.classList.add('jcontextmenu');
                obj.menu.setAttribute('tabindex', '900');

                /**
                 * Open contextmenu
                 */
                obj.open = function (e, items) {
                    if (items) {
                        obj.options.items = items;
                    }

                    // Reset content
                    obj.menu.innerHTML = '';

                    // Append items
                    for (var i = 0; i < obj.options.items.length; i++) {
                        if (obj.options.items[i].type && obj.options.items[i].type == 'line') {
                            var itemContainer = document.createElement('hr');
                        } else {
                            var itemContainer = document.createElement('li');
                            var itemText = document.createElement('a');
                            itemText.innerHTML = obj.options.items[i].title;

                            if (obj.options.items[i].disabled) {
                                itemContainer.className = 'jcontextmenu-disabled';
                            } else if (obj.options.items[i].onclick) {
                                itemContainer.onmouseup = obj.options.items[i].onclick;
                            }
                            itemContainer.appendChild(itemText);

                            if (obj.options.items[i].shortcut) {
                                var itemShortCut = document.createElement('span');
                                itemShortCut.innerHTML = obj.options.items[i].shortcut;
                                itemContainer.appendChild(itemShortCut);
                            }
                        }

                        obj.menu.appendChild(itemContainer);
                    }

                    if (e.target) {
                        var x = e.clientX;
                        var y = e.clientY;
                        obj.menu.style.top = y + 'px';
                        obj.menu.style.left = x + 'px';
                    } else {
                        obj.menu.style.top = e.y + 'px';
                        obj.menu.style.left = e.x + 'px';
                    }

                    obj.menu.classList.add('jcontextmenu-focus');
                    obj.menu.focus();
                }

                /**
                 * Close menu
                 */
                obj.close = function () {
                    obj.menu.classList.remove('jcontextmenu-focus');
                }

                el.addEventListener("click", function (e) {
                    obj.close();
                });

                obj.menu.addEventListener('blur', function (e) {
                    obj.close();
                });

                window.addEventListener("mousewheel", function () {
                    obj.close();
                });

                el.appendChild(obj.menu);
                el.contextmenu = obj;

                return obj;
            });

            /**
             * (c) 2013 jDropdown
             * http://www.github.com/paulhodel/jdropdown
             *
             * @author: Paul Hodel <paul.hodel@gmail.com>
             * @description: Custom dropdowns
             */

            jSuites.dropdown = (function (el, options) {
                var obj = {};
                obj.options = {};
                obj.items = [];
                obj.groups = [];

                if (options) {
                    obj.options = options;
                }

                // Global container
                if (!jSuites.dropdown.current) {
                    jSuites.dropdown.current = null;
                }

                // Default configuration
                var defaults = {
                    data: [],
                    multiple: false,
                    autocomplete: false,
                    type: null,
                    width: null,
                    opened: false,
                    onchange: null,
                    onload: null,
                    onopen: null,
                    onclose: null,
                    onblur: null,
                    value: null,
                    placeholder: '',
                };

                // Loop through our object
                for (var property in defaults) {
                    if (options && options.hasOwnProperty(property)) {
                        obj.options[property] = options[property];
                    } else {
                        obj.options[property] = defaults[property];
                    }
                }

                // Create dropdown
                el.classList.add('jdropdown');

                if (obj.options.type == 'searchbar') {
                    el.classList.add('jdropdown-searchbar');
                } else if (obj.options.type == 'list') {
                    el.classList.add('jdropdown-list');
                } else if (obj.options.type == 'picker') {
                    el.classList.add('jdropdown-picker');
                } else {
                    if (jSuites.getWindowWidth() < 800) {
                        el.classList.add('jdropdown-picker');
                        obj.options.type = 'picker';
                    } else {
                        if (obj.options.width) {
                            el.style.width = obj.options.width;
                        }
                        el.classList.add('jdropdown-default');
                        obj.options.type = 'default';
                    }
                }

                // Header container
                var containerHeader = document.createElement('div');
                containerHeader.className = 'jdropdown-container-header';

                // Header
                var header = document.createElement('input');
                header.className = 'jdropdown-header';
                if (typeof (obj.options.onblur) == 'function') {
                    header.onblur = function () {
                        obj.options.onblur(el);
                    }
                }

                // Container
                var container = document.createElement('div');
                container.className = 'jdropdown-container';

                // Dropdown content
                var content = document.createElement('div');
                content.className = 'jdropdown-content';

                // Close button
                var closeButton = document.createElement('div');
                closeButton.className = 'jdropdown-close';
                closeButton.innerHTML = 'Done';

                // Create backdrop
                var backdrop = document.createElement('div');
                backdrop.className = 'jdropdown-backdrop';

                // Autocomplete
                if (obj.options.autocomplete == true) {
                    el.setAttribute('data-autocomplete', true);

                    // Handler
                    header.addEventListener('keyup', function (e) {
                        obj.find(header.value);
                    });
                } else {
                    header.setAttribute('readonly', 'readonly');
                }

                // Place holder
                if (obj.options.placeholder) {
                    header.setAttribute('placeholder', obj.options.placeholder);
                }

                // Append elements
                containerHeader.appendChild(header);
                container.appendChild(closeButton);
                container.appendChild(content);
                el.appendChild(containerHeader);
                el.appendChild(container);
                el.appendChild(backdrop);

                obj.init = function () {
                    if (obj.options.url) {
                        fetch(obj.options.url, { headers: new Headers({ 'content-type': 'text/json' }) })
                            .then(function (data) {
                                data.json().then(function (data) {
                                    if (data) {
                                        obj.options.data = data;
                                        obj.setData();

                                        if (typeof (obj.options.onload) == 'function') {
                                            obj.options.onload(el, obj, data);
                                        }
                                    }
                                })
                            });
                    } else {
                        obj.setData();

                        if (typeof (obj.options.onload) == 'function') {
                            obj.options.onload(el, obj, data);
                        }
                    }

                    // Values
                    obj.setValue(obj.options.value);

                    if (obj.options.opened == true) {
                        obj.open();
                    }

                    // Fix width - Workaround important to get the correct width
                    if (obj.options.type == 'default') {
                        setTimeout(function () {
                            container.style.minWidth = header.outerWidth;
                        }, 0);
                    }
                }

                obj.getUrl = function () {
                    return obj.options.url;
                }

                obj.setUrl = function (url) {
                    obj.options.url = url;
                    fetch(obj.options.url, { headers: new Headers({ 'content-type': 'text/json' }) })
                        .then(function (data) {
                            data.json().then(function (data) {
                                obj.setData(data);
                            })
                        });
                }

                obj.setData = function (data) {
                    if (data) {
                        obj.options.data = data;
                    } else {
                        var data = obj.options.data;
                    }

                    // Make sure the content container is blank
                    content.innerHTML = '';

                    // Containers
                    var items = [];
                    var groups = [];

                    // Foreach in the data to create all items
                    if (data.length) {
                        data.forEach(function (v, k) {
                            // Compatibility
                            if (typeof (v) != 'object') {
                                var value = v;
                                v = {}
                                v.id = value;
                                v.name = value;

                                // Fix array
                                obj.options.data[k] = v;
                            }

                            // Create item
                            items[k] = document.createElement('div');
                            items[k].className = 'jdropdown-item';
                            items[k].value = v.id;
                            items[k].text = v.name;

                            // Image
                            if (v.image) {
                                var image = document.createElement('img');
                                image.className = 'jdropdown-image';
                                image.src = v.image;
                                if (!v.title) {
                                    image.classList.add('jdropdown-image-small');
                                }
                                items[k].appendChild(image);
                            }

                            // Set content
                            var node = document.createElement('div');
                            node.className = 'jdropdown-description';
                            node.innerHTML = v.name;
                            items[k].appendChild(node);

                            // Title
                            if (v.title) {
                                var title = document.createElement('div');
                                title.className = 'jdropdown-title';
                                title.innerHTML = v.title;
                                node.appendChild(title);
                            }

                            // Append to the container
                            if (v.group) {
                                if (!groups[v.group]) {
                                    groups[v.group] = document.createElement('div');
                                    groups[v.group].className = 'jdropdown-group-items';
                                }
                                groups[v.group].appendChild(items[k]);
                            } else {
                                content.appendChild(items[k]);
                            }
                        });

                        // Append groups in case exists
                        if (Object.keys(groups).length > 0) {
                            Object.keys(groups).forEach(function (v, k) {
                                var group = document.createElement('div');
                                group.className = 'jdropdown-group';
                                group.innerHTML = '<div class="jdropdown-group-name">' + v + '<i class="jdropdown-group-arrow jdropdown-group-arrow-down"></i></div>';
                                group.appendChild(groups[v]);
                                obj.groups.push(group);
                                content.appendChild(group);
                            });
                        }

                        // Add index property
                        var items = content.querySelectorAll('.jdropdown-item');
                        for (var i = 0; i < items.length; i++) {
                            obj.items[i] = items[i];
                            items[i].setAttribute('data-index', i);
                        }
                    }

                    // Reset value
                    obj.setValue(obj.options.value ? obj.options.value : '');
                }

                obj.getText = function (asArray) {
                    // Result
                    var result = [];
                    // Get selected items
                    var items = el.querySelectorAll('.jdropdown-selected');
                    // Append options
                    for (var i = 0; i < items.length; i++) {
                        result.push(items[i].text);
                    }

                    if (asArray) {
                        return result
                    } else {
                        return result.join('; ');
                    }
                }

                obj.getValue = function (asArray) {
                    // Result
                    var result = [];
                    // Get selected items
                    var items = el.querySelectorAll('.jdropdown-selected');
                    // Append options
                    for (var i = 0; i < items.length; i++) {
                        result.push(items[i].value);
                    }

                    if (asArray) {
                        return result;
                    } else {
                        return result.join(';');
                    }
                }

                obj.setValue = function (value) {
                    // Remove values
                    var items = el.querySelectorAll('.jdropdown-selected');
                    for (var j = 0; j < items.length; j++) {
                        items[j].classList.remove('jdropdown-selected')
                    }

                    // Set values
                    if (value) {
                        if (typeof (value.forEach) == 'function') {
                            for (var i = 0; i < obj.items.length; i++) {
                                value.forEach(function (val) {
                                    if (obj.items[i].value == val) {
                                        obj.items[i].classList.add('jdropdown-selected');
                                    }
                                });
                            }
                        } else {
                            for (var i = 0; i < obj.items.length; i++) {
                                if (obj.items[i].value == value) {
                                    obj.items[i].classList.add('jdropdown-selected');
                                }
                            }
                        }
                    }

                    // Update labels
                    obj.updateLabel();
                }

                obj.selectIndex = function (index) {
                    // Focus behaviour
                    if (!obj.options.multiple) {
                        // Update selected item
                        obj.items.forEach(function (v) {
                            v.classList.remove('jdropdown-cursor');
                            v.classList.remove('jdropdown-selected');
                        });
                        obj.items[index].classList.add('jdropdown-selected');
                        obj.items[index].classList.add('jdropdown-cursor');
                        // Close
                        obj.close();
                    } else {
                        // Toggle option
                        if (obj.items[index].classList.contains('jdropdown-selected')) {
                            obj.items[index].classList.remove('jdropdown-selected');
                            obj.items[index].classList.remove('jdropdown-cursor');
                        } else {
                            obj.items.forEach(function (v) {
                                v.classList.remove('jdropdown-cursor');
                            });
                            obj.items[index].classList.add('jdropdown-selected');
                            obj.items[index].classList.add('jdropdown-cursor');
                        }
                        // Update cursor position
                        obj.currentIndex = index;

                        // Update labels for multiple dropdown
                        if (!obj.options.autocomplete) {
                            obj.updateLabel();
                        }
                    }

                    // Events
                    if (typeof (obj.options.onchange) == 'function') {
                        var oldValue = obj.getValue();
                        var newValue = obj.items[index].value;

                        obj.options.onchange(el, index, oldValue, newValue);
                    }
                }

                obj.selectItem = function (item) {
                    var index = item.getAttribute('data-index');
                    if (jSuites.dropdown.current) {
                        obj.selectIndex(item.getAttribute('data-index'));
                    } else {
                        // List
                        if (obj.options.type == 'list') {
                            if (!obj.options.multiple) {
                                obj.items.forEach(function (k, v) {
                                    v.classList.remove('jdropdown-cursor');
                                    v.classList.remove('jdropdown-selected');
                                });
                                obj.items[index].classList.add('jdropdown-selected');
                                obj.items[index].classList.add('jdropdown-cursor');
                            } else {
                                // Toggle option
                                if (obj.items[index].classList.contains('jdropdown-selected')) {
                                    obj.items[index].classList.remove('jdropdown-selected');
                                    obj.items[index].classList.remove('jdropdown-cursor');
                                } else {
                                    obj.items.forEach(function (v) {
                                        v.classList.remove('jdropdown-cursor');
                                    });
                                    obj.items[index].classList.add('jdropdown-selected');
                                    obj.items[index].classList.add('jdropdown-cursor');
                                }
                                // Update cursor position
                                obj.currentIndex = index;
                            }
                        }
                    }
                }

                obj.find = function (str) {
                    // Append options
                    for (var i = 0; i < obj.items.length; i++) {
                        if (str == null || obj.items[i].classList.contains('jdropdown-selected') || obj.items[i].innerHTML.toLowerCase().indexOf(str.toLowerCase()) != -1) {
                            obj.items[i].style.display = '';
                        } else {
                            obj.items[i].style.display = 'none';
                        }
                    };

                    var numVisibleItems = function (items) {
                        var visible = 0;
                        for (var j = 0; j < items.length; j++) {
                            if (items[j].style.display != 'none') {
                                visible++;
                            }
                        }
                        return visible;
                    }

                    // Hide groups
                    for (var i = 0; i < obj.groups.length; i++) {
                        if (numVisibleItems(obj.groups[i].querySelectorAll('.jdropdown-item'))) {
                            obj.groups[i].children[0].style.display = '';
                        } else {
                            obj.groups[i].children[0].style.display = 'none';
                        }
                    }
                }

                obj.updateLabel = function () {
                    // Update label
                    header.value = obj.getText();
                }

                obj.open = function () {
                    if (jSuites.dropdown.current != el) {
                        if (jSuites.dropdown.current) {
                            jSuites.dropdown.current.dropdown.close();
                        }
                        jSuites.dropdown.current = el;
                    }

                    // Focus
                    if (!el.classList.contains('jdropdown-focus')) {
                        // Add focus
                        el.classList.add('jdropdown-focus');

                        // Animation
                        if (jSuites.getWindowWidth() < 800) {
                            if (obj.options.type == null || obj.options.type == 'picker') {
                                container.classList.add('slide-bottom-in');
                            }
                        }

                        // Filter
                        if (obj.options.autocomplete == true) {
                            // Redo search
                            obj.find();
                            // Clear search field
                            header.value = '';
                            header.focus();
                        }

                        // Selected
                        var selected = el.querySelector('.jdropdown-selected');
                        // Update cursor position
                        if (selected) {
                            obj.updateCursor(selected.getAttribute('data-index'));
                        }
                        // Container Size
                        if (!obj.options.type || obj.options.type == 'default') {
                            const rect = el.getBoundingClientRect();
                            const rectContainer = container.getBoundingClientRect();
                            container.style.minWidth = rect.width + 'px';
                            //container.style.maxWidth = '100%';

                            if (obj.options.position) {
                                container.style.position = 'fixed';
                                if (window.innerHeight < rect.bottom + rectContainer.height) {
                                    container.style.top = (rect.top - rectContainer.height - 2) + 'px';
                                } else {
                                    container.style.top = (rect.top + rect.height + 1) + 'px';
                                }
                            } else {
                                if (window.innerHeight < rect.bottom + rectContainer.height) {
                                    container.style.top = (-1 * (rectContainer.height)) + 'px';
                                } else {
                                    container.style.top = '';
                                }
                            }
                        }
                    }

                    // Events
                    if (typeof (obj.options.onopen) == 'function') {
                        obj.options.onopen(el);
                    }
                }

                obj.close = function (ignoreEvents) {
                    if (jSuites.dropdown.current) {
                        // Remove controller
                        jSuites.dropdown.current = null
                        // Remove cursor
                        var cursor = el.querySelector('.jdropdown-cursor');
                        if (cursor) {
                            cursor.classList.remove('jdropdown-cursor');
                        }
                        // Update labels
                        obj.updateLabel();
                        // Events
                        if (!ignoreEvents && typeof (obj.options.onclose) == 'function') {
                            obj.options.onclose(el);
                        }
                        // Reset
                        obj.currentIndex = null;
                        // Blur
                        //header.blur();
                        // Remove focus
                        el.classList.remove('jdropdown-focus');
                    }

                    return obj.getValue();
                }

                obj.reset = function () {
                    // Remove current cursor
                    var cursor = el.querySelector('.jdropdown-cursor');
                    if (cursor) {
                        cursor.classList.remove('jdropdown-cursor');
                    }
                    // Unselected all
                    obj.items.forEach(function (v) {
                        v.classList.remove('jdropdown-selected');
                    });
                    // Update labels
                    obj.updateLabel();
                }

                obj.first = function () {
                    var newIndex = null;
                    for (var i = obj.currentIndex - 1; i >= 0; i--) {
                        if (obj.items[i].style.display != 'none') {
                            newIndex = i;
                        }
                    }

                    if (newIndex == null) {
                        return false;
                    }

                    obj.updateCursor(newIndex);
                }

                obj.last = function () {
                    var newIndex = null;
                    for (var i = obj.currentIndex + 1; i < obj.options.data.length; i++) {
                        if (obj.items[i].style.display != 'none') {
                            newIndex = i;
                        }
                    }

                    if (newIndex == null) {
                        return false;
                    }

                    obj.updateCursor(newIndex);
                }

                obj.next = function () {
                    var newIndex = null;
                    for (var i = obj.currentIndex + 1; i < obj.options.data.length; i++) {
                        if (obj.items[i].style.display != 'none') {
                            newIndex = i;
                            break;
                        }
                    }

                    if (newIndex == null) {
                        return false;
                    }

                    obj.updateCursor(newIndex);
                }

                obj.prev = function () {
                    var newIndex = null;
                    for (var i = obj.currentIndex - 1; i >= 0; i--) {
                        if (obj.items[i].style.display != 'none') {
                            newIndex = i;
                            break;
                        }
                    }

                    if (newIndex == null) {
                        return false;
                    }

                    obj.updateCursor(newIndex);
                }

                obj.updateCursor = function (index) {
                    // Update cursor
                    if (obj.items[obj.currentIndex]) {
                        obj.items[obj.currentIndex].classList.remove('jdropdown-cursor');
                    }
                    if (obj.items && obj.items[index]) {
                        obj.items[index].classList.add('jdropdown-cursor');

                        // Update position
                        obj.currentIndex = parseInt(index);

                        // Update scroll
                        var container = content.scrollTop;
                        var element = obj.items[obj.currentIndex];
                        content.scrollTop = element.offsetTop - element.scrollTop + element.clientTop - 95;
                    }
                }

                if (!jSuites.dropdown.hasEvents) {
                    document.addEventListener('click', jSuites.dropdown.onclick);
                    document.addEventListener('keydown', jSuites.dropdown.onkeydown);

                    jSuites.dropdown.hasEvents = true;
                }

                // Start dropdown
                obj.init();

                // Keep object available from the node
                el.dropdown = obj;

                return obj;
            });

            jSuites.dropdown.onclick = function (e) {
                var element = jSuites.getElement(e.target, 'jdropdown');
                if (element) {
                    var dropdown = element.dropdown;
                    if (e.target.classList.contains('jdropdown-header')) {
                        if (element.classList.contains('jdropdown-focus') && element.classList.contains('jdropdown-default')) {
                            dropdown.close();
                        } else {
                            dropdown.open();
                        }
                    } else if (e.target.classList.contains('jdropdown-group-name')) {
                        var items = e.target.nextSibling.children;
                        if (e.target.nextSibling.style.display != 'none') {
                            for (var i = 0; i < items.length; i++) {
                                if (items[i].style.display != 'none') {
                                    dropdown.selectItem(items[i]);
                                }
                            }
                        }
                    } else if (e.target.classList.contains('jdropdown-group-arrow')) {
                        if (e.target.classList.contains('jdropdown-group-arrow-down')) {
                            e.target.classList.remove('jdropdown-group-arrow-down');
                            e.target.classList.add('jdropdown-group-arrow-up');
                            e.target.parentNode.nextSibling.style.display = 'none';
                        } else {
                            e.target.classList.remove('jdropdown-group-arrow-up');
                            e.target.classList.add('jdropdown-group-arrow-down');
                            e.target.parentNode.nextSibling.style.display = '';
                        }
                    } else if (e.target.classList.contains('jdropdown-item')) {
                        dropdown.selectItem(e.target);
                    } else if (e.target.classList.contains('jdropdown-image')) {
                        dropdown.selectIndex(e.target.parentNode.getAttribute('data-index'));
                    } else if (e.target.classList.contains('jdropdown-description')) {
                        dropdown.selectIndex(e.target.parentNode.getAttribute('data-index'));
                    } else if (e.target.classList.contains('jdropdown-title')) {
                        dropdown.selectIndex(e.target.parentNode.parentNode.getAttribute('data-index'));
                    } else if (e.target.classList.contains('jdropdown-close') || e.target.classList.contains('jdropdown-backdrop')) {
                        // Close
                        dropdown.close();
                    }

                    e.stopPropagation();
                    e.preventDefault();
                } else {
                    if (jSuites.dropdown.current) {
                        jSuites.dropdown.current.dropdown.close();
                    }
                }
            }


            // Keydown controls
            jSuites.dropdown.onkeydown = function (e) {
                if (jSuites.dropdown.current) {
                    // Element
                    var element = jSuites.dropdown.current.dropdown;
                    // Index
                    var index = element.currentIndex;

                    if (e.shiftKey) {

                    } else {
                        if (e.which == 13 || e.which == 35 || e.which == 36 || e.which == 38 || e.which == 40) {
                            // Move cursor
                            if (e.which == 13) {
                                element.selectIndex(index)
                            } else if (e.which == 38) {
                                if (index == null) {
                                    element.updateCursor(0);
                                } else if (index > 0) {
                                    element.prev();
                                }
                            } else if (e.which == 40) {
                                if (index == null) {
                                    element.updateCursor(0);
                                } else if (index + 1 < element.options.data.length) {
                                    element.next();
                                }
                            } else if (e.which == 36) {
                                element.first();
                            } else if (e.which == 35) {
                                element.last();
                            }

                            e.stopPropagation();
                            e.preventDefault();
                        }
                    }
                }
            }

            jSuites.image = (function (el, options) {
                var obj = {};
                obj.options = {};

                // Default configuration
                var defaults = {
                    minWidth: false,
                    onchange: null,
                    singleFile: true,
                    remoteParser: null,
                    text: {
                        extensionNotAllowed: 'The extension is not allowed',
                        imageTooSmall: 'The resolution is too low, try a image with a better resolution. width > 800px',
                    }
                };

                // Loop through our object
                for (var property in defaults) {
                    if (options && options.hasOwnProperty(property)) {
                        obj.options[property] = options[property];
                    } else {
                        obj.options[property] = defaults[property];
                    }
                }

                // Upload icon
                el.classList.add('jupload');

                // Add image
                obj.addImage = function (file) {
                    if (!file.date) {
                        file.date = '';
                    }
                    var img = document.createElement('img');
                    img.setAttribute('data-date', file.lastmodified ? file.lastmodified : file.date);
                    img.setAttribute('data-name', file.name);
                    img.setAttribute('data-size', file.size);
                    img.setAttribute('data-small', file.small ? file.small : '');
                    img.setAttribute('data-cover', file.cover ? 1 : 0);
                    img.setAttribute('data-extension', file.extension);
                    img.setAttribute('src', file.file);
                    img.className = 'jfile';
                    img.style.width = '100%';

                    return img;
                }

                // Add image
                obj.addImages = function (files) {
                    if (obj.options.singleFile == true) {
                        el.innerHTML = '';
                    }

                    for (var i = 0; i < files.length; i++) {
                        el.appendChild(obj.addImage(files[i]));
                    }
                }

                obj.addFromFile = function (file) {
                    var type = file.type.split('/');
                    if (type[0] == 'image') {
                        if (obj.options.singleFile == true) {
                            el.innerHTML = '';
                        }

                        var imageFile = new FileReader();
                        imageFile.addEventListener("load", function (v) {

                            var img = new Image();

                            img.onload = function onload() {
                                var canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;

                                var ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                                var data = {
                                    file: canvas.toDataURL(),
                                    extension: file.name.substr(file.name.lastIndexOf('.') + 1),
                                    name: file.name,
                                    size: file.size,
                                    lastmodified: file.lastModified,
                                }
                                var newImage = obj.addImage(data);
                                el.appendChild(newImage);

                                // Onchange
                                if (typeof (obj.options.onchange) == 'function') {
                                    obj.options.onchange(newImage);
                                }
                            };

                            img.src = v.srcElement.result;
                        });

                        imageFile.readAsDataURL(file);
                    } else {
                        alert(text.extentionNotAllowed);
                    }
                }

                obj.addFromUrl = function (src) {
                    if (src.substr(0, 4) != 'data' && !obj.options.remoteParser) {
                        console.error('remoteParser not defined in your initialization');
                    } else {
                        // This is to process cross domain images
                        if (src.substr(0, 4) == 'data') {
                            var extension = src.split(';')
                            extension = extension[0].split('/');
                            extension = extension[1];
                        } else {
                            var extension = src.substr(src.lastIndexOf('.') + 1);
                            // Work for cross browsers
                            src = obj.options.remoteParser + src;
                        }

                        var img = new Image();

                        img.onload = function onload() {
                            var canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;

                            var ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                            canvas.toBlob(function (blob) {
                                var data = {
                                    file: window.URL.createObjectURL(blob),
                                    extension: extension
                                }
                                var newImage = obj.addImage(data);
                                el.appendChild(newImage);

                                // Keep base64 ready to go
                                var content = canvas.toDataURL();
                                jSuites.files[data.file] = content.substr(content.indexOf(',') + 1);

                                // Onchange
                                if (typeof (obj.options.onchange) == 'function') {
                                    obj.options.onchange(newImage);
                                }
                            });
                        };

                        img.src = src;
                    }
                }

                var attachmentInput = document.createElement('input');
                attachmentInput.type = 'file';
                attachmentInput.setAttribute('accept', 'image/*');
                attachmentInput.onchange = function () {
                    for (var i = 0; i < this.files.length; i++) {
                        obj.addFromFile(this.files[i]);
                    }
                }

                el.addEventListener("dblclick", function (e) {
                    jSuites.click(attachmentInput);
                });

                el.addEventListener('dragenter', function (e) {
                    el.style.border = '1px dashed #000';
                });

                el.addEventListener('dragleave', function (e) {
                    el.style.border = '1px solid #eee';
                });

                el.addEventListener('dragstop', function (e) {
                    el.style.border = '1px solid #eee';
                });

                el.addEventListener('dragover', function (e) {
                    e.preventDefault();
                });

                el.addEventListener('drop', function (e) {
                    e.preventDefault();
                    e.stopPropagation();


                    var html = (e.originalEvent || e).dataTransfer.getData('text/html');
                    var file = (e.originalEvent || e).dataTransfer.files;

                    if (file.length) {
                        for (var i = 0; i < e.dataTransfer.files.length; i++) {
                            obj.addFromFile(e.dataTransfer.files[i]);
                        }
                    } else if (html) {
                        if (obj.options.singleFile == true) {
                            el.innerHTML = '';
                        }

                        // Create temp element
                        var div = document.createElement('div');
                        div.innerHTML = html;

                        // Extract images
                        var img = div.querySelectorAll('img');

                        if (img.length) {
                            for (var i = 0; i < img.length; i++) {
                                obj.addFromUrl(img[i].src);
                            }
                        }
                    }

                    el.style.border = '1px solid #eee';

                    return false;
                });

                el.image = obj;

                return obj;
            });

            /**
             * (c) jLoading
             * https://github.com/paulhodel/jtools
             *
             * @author: Paul Hodel <paul.hodel@gmail.com>
             * @description: Page loading spin
             */

            jSuites.loading = (function () {
                var obj = {};

                var loading = document.createElement('div');
                loading.className = 'jloading';

                obj.show = function () {
                    document.body.appendChild(loading);
                };

                obj.hide = function () {
                    document.body.removeChild(loading);
                };

                return obj;
            })();

            /**
             * (c) jTools Input Mask
             * https://github.com/paulhodel/jtools
             *
             * @author: Paul Hodel <paul.hodel@gmail.com>
             * @description: Input mask
             */

            jSuites.mask = (function () {
                var obj = {};
                var index = 0;
                var values = []
                var pieces = [];

                obj.run = function (value, mask, decimal) {
                    if (value && mask) {
                        if (!decimal) {
                            decimal = '.';
                        }
                        if (value == Number(value)) {
                            var number = ('' + value).split('.');
                            var value = number[0];
                            var valueDecimal = number[1];
                        } else {
                            value = '' + value;
                        }
                        index = 0;
                        values = [];
                        // Create mask token
                        obj.prepare(mask);
                        // Current value
                        var currentValue = value;
                        if (currentValue) {
                            // Checking current value
                            for (var i = 0; i < currentValue.length; i++) {
                                if (currentValue[i] != null) {
                                    obj.process(currentValue[i]);
                                }
                            }
                        }
                        if (valueDecimal) {
                            obj.process(decimal);
                            var currentValue = valueDecimal;
                            if (currentValue) {
                                // Checking current value
                                for (var i = 0; i < currentValue.length; i++) {
                                    if (currentValue[i] != null) {
                                        obj.process(currentValue[i]);
                                    }
                                }
                            }
                        }
                        // Formatted value
                        return values.join('');
                    } else {
                        return '';
                    }
                }

                obj.apply = function (e) {
                    var mask = e.target.getAttribute('data-mask');
                    if (mask && e.keyCode > 46) {
                        index = 0;
                        values = [];
                        // Create mask token
                        obj.prepare(mask);
                        // Current value
                        var currentValue = e.target.value;
                        if (currentValue) {
                            // Checking current value
                            for (var i = 0; i < currentValue.length; i++) {
                                if (currentValue[i] != null) {
                                    obj.process(currentValue[i]);
                                }
                            }
                        }
                        // New input
                        obj.process(obj.fromKeyCode(e));
                        // Update value to the element
                        e.target.value = values.join('');
                        if (pieces.length == values.length && pieces[pieces.length - 1].length == values[values.length - 1].length) {
                            e.target.setAttribute('data-completed', 'true');
                        } else {
                            e.target.setAttribute('data-completed', 'false');
                        }
                        // Prevent default
                        e.preventDefault();
                    }
                }

                /**
                 * Process inputs and save to values
                 */
                obj.process = function (input) {
                    do {
                        if (pieces[index] == 'mm') {
                            if (values[index] == null || values[index] == '') {
                                if (parseInt(input) > 1 && parseInt(input) < 10) {
                                    values[index] = '0' + input;
                                    index++;
                                    return true;
                                } else if (parseInt(input) < 10) {
                                    values[index] = input;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                if (values[index] == 1 && values[index] < 2 && parseInt(input) < 3) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else if (values[index] == 0 && values[index] < 10) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else {
                                    return false
                                }
                            }
                        } else if (pieces[index] == 'dd') {
                            if (values[index] == null || values[index] == '') {
                                if (parseInt(input) > 3 && parseInt(input) < 10) {
                                    values[index] = '0' + input;
                                    index++;
                                    return true;
                                } else if (parseInt(input) < 10) {
                                    values[index] = input;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                if (values[index] == 3 && parseInt(input) < 2) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else if (values[index] < 3 && parseInt(input) < 10) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else {
                                    return false
                                }
                            }
                        } else if (pieces[index] == 'hh24') {
                            if (values[index] == null || values[index] == '') {
                                if (parseInt(input) > 2 && parseInt(input) < 10) {
                                    values[index] = '0' + input;
                                    index++;
                                    return true;
                                } else if (parseInt(input) < 10) {
                                    values[index] = input;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                if (values[index] == 2 && parseInt(input) < 4) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else if (values[index] < 2 && parseInt(input) < 10) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else {
                                    return false
                                }
                            }
                        } else if (pieces[index] == 'hh') {
                            if (values[index] == null || values[index] == '') {
                                if (parseInt(input) > 1 && parseInt(input) < 10) {
                                    values[index] = '0' + input;
                                    index++;
                                    return true;
                                } else if (parseInt(input) < 10) {
                                    values[index] = input;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                if (values[index] == 1 && parseInt(input) < 3) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else if (values[index] < 1 && parseInt(input) < 10) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else {
                                    return false
                                }
                            }
                        } else if (pieces[index] == 'mi' || pieces[index] == 'ss') {
                            if (values[index] == null || values[index] == '') {
                                if (parseInt(input) > 5 && parseInt(input) < 10) {
                                    values[index] = '0' + input;
                                    index++;
                                    return true;
                                } else if (parseInt(input) < 10) {
                                    values[index] = input;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                if (parseInt(input) < 10) {
                                    values[index] += input;
                                    index++;
                                    return true;
                                } else {
                                    return false
                                }
                            }
                        } else if (pieces[index] == 'yy' || pieces[index] == 'yyyy') {
                            if (parseInt(input) < 10) {
                                if (values[index] == null || values[index] == '') {
                                    values[index] = input;
                                } else {
                                    values[index] += input;
                                }

                                if (values[index].length == pieces[index].length) {
                                    index++;
                                }
                                return true;
                            } else {
                                return false;
                            }
                        } else if (pieces[index] == '#' || pieces[index] == '#.##' || pieces[index] == '#,##') {
                            if (input.match(/[0-9]/g)) {
                                if (pieces[index] == '#.##') {
                                    var separator = '.';
                                } else if (pieces[index] == '#,##') {
                                    var separator = ',';
                                } else {
                                    var separator = '';
                                }
                                if (values[index] == null || values[index] == '') {
                                    values[index] = input;
                                } else {
                                    values[index] += input;
                                    if (separator) {
                                        values[index] = values[index].match(/[0-9]/g).join('');
                                        var t = [];
                                        var s = 0;
                                        for (var j = values[index].length - 1; j >= 0; j--) {
                                            t.push(values[index][j]);
                                            s++;
                                            if (!(s % 3)) {
                                                t.push(separator);
                                            }
                                        }
                                        t = t.reverse();
                                        values[index] = t.join('');
                                        if (values[index].substr(0, 1) == separator) {
                                            values[index] = values[index].substr(1);
                                        }
                                    }
                                }
                                return true;
                            } else {
                                if (pieces[index] == '#.##' && input == '.') {
                                    // Do nothing
                                } else if (pieces[index] == '#,##' && input == ',') {
                                    // Do nothing
                                } else {
                                    if (values[index]) {
                                        index++;
                                        if (pieces[index]) {
                                            if (pieces[index] == input) {
                                                values[index] = input;
                                                return true;
                                            } else {
                                                if (pieces[index] == '0' && pieces[index + 1] == input) {
                                                    index++;
                                                    values[index] = input;
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }

                                return false;
                            }
                        } else if (pieces[index] == '0') {
                            if (input.match(/[0-9]/g)) {
                                values[index] = input;
                                index++;
                                return true;
                            } else {
                                return false;
                            }
                        } else if (pieces[index] == 'a') {
                            if (input.match(/[a-zA-Z]/g)) {
                                values[index] = input;
                                index++;
                                return true;
                            } else {
                                return false;
                            }
                        } else {
                            if (pieces[index] != null) {
                                if (pieces[index] == '\\a') {
                                    var v = 'a';
                                } else if (pieces[index] == '\\0') {
                                    var v = '0';
                                } else {
                                    var v = pieces[index];
                                }
                                values[index] = v;
                                if (input == v) {
                                    index++;
                                    return true;
                                }
                            }
                        }

                        index++;
                    } while (pieces[index]);
                }

                /**
                 * Create tokens for the mask
                 */
                obj.prepare = function (mask) {
                    pieces = [];
                    for (var i = 0; i < mask.length; i++) {
                        if (mask[i].match(/[0-9]|[a-z]|\\/g)) {
                            if (mask[i] == 'y' && mask[i + 1] == 'y' && mask[i + 2] == 'y' && mask[i + 3] == 'y') {
                                pieces.push('yyyy');
                                i += 3;
                            } else if (mask[i] == 'y' && mask[i + 1] == 'y') {
                                pieces.push('yy');
                                i++;
                            } else if (mask[i] == 'm' && mask[i + 1] == 'm' && mask[i + 2] == 'm' && mask[i + 3] == 'm') {
                                pieces.push('mmmm');
                                i += 3;
                            } else if (mask[i] == 'm' && mask[i + 1] == 'm' && mask[i + 2] == 'm') {
                                pieces.push('mmm');
                                i += 2;
                            } else if (mask[i] == 'm' && mask[i + 1] == 'm') {
                                pieces.push('mm');
                                i++;
                            } else if (mask[i] == 'd' && mask[i + 1] == 'd') {
                                pieces.push('dd');
                                i++;
                            } else if (mask[i] == 'h' && mask[i + 1] == 'h' && mask[i + 2] == '2' && mask[i + 3] == '4') {
                                pieces.push('hh24');
                                i += 3;
                            } else if (mask[i] == 'h' && mask[i + 1] == 'h') {
                                pieces.push('hh');
                                i++;
                            } else if (mask[i] == 'm' && mask[i + 1] == 'i') {
                                pieces.push('mi');
                                i++;
                            } else if (mask[i] == 's' && mask[i + 1] == 's') {
                                pieces.push('ss');
                                i++;
                            } else if (mask[i] == 'a' && mask[i + 1] == 'm') {
                                pieces.push('am');
                                i++;
                            } else if (mask[i] == 'p' && mask[i + 1] == 'm') {
                                pieces.push('pm');
                                i++;
                            } else if (mask[i] == '\\' && mask[i + 1] == '0') {
                                pieces.push('\\0');
                                i++;
                            } else if (mask[i] == '\\' && mask[i + 1] == 'a') {
                                pieces.push('\\a');
                                i++;
                            } else {
                                pieces.push(mask[i]);
                            }
                        } else {
                            if (mask[i] == '#' && mask[i + 1] == '.' && mask[i + 2] == '#' && mask[i + 3] == '#') {
                                pieces.push('#.##');
                                i += 3;
                            } else if (mask[i] == '#' && mask[i + 1] == ',' && mask[i + 2] == '#' && mask[i + 3] == '#') {
                                pieces.push('#,##');
                                i += 3;
                            } else {
                                pieces.push(mask[i]);
                            }
                        }
                    }
                }

                /**
                 * Thanks for the collaboration
                 */
                obj.fromKeyCode = function (e) {
                    var _to_ascii = {
                        '188': '44',
                        '109': '45',
                        '190': '46',
                        '191': '47',
                        '192': '96',
                        '220': '92',
                        '222': '39',
                        '221': '93',
                        '219': '91',
                        '173': '45',
                        '187': '61', //IE Key codes
                        '186': '59', //IE Key codes
                        '189': '45'  //IE Key codes
                    }

                    var shiftUps = {
                        "96": "~",
                        "49": "!",
                        "50": "@",
                        "51": "#",
                        "52": "$",
                        "53": "%",
                        "54": "^",
                        "55": "&",
                        "56": "*",
                        "57": "(",
                        "48": ")",
                        "45": "_",
                        "61": "+",
                        "91": "{",
                        "93": "}",
                        "92": "|",
                        "59": ":",
                        "39": "\"",
                        "44": "<",
                        "46": ">",
                        "47": "?"
                    };

                    var c = e.which;

                    if (_to_ascii.hasOwnProperty(c)) {
                        c = _to_ascii[c];
                    }

                    if (!e.shiftKey && (c >= 65 && c <= 90)) {
                        c = String.fromCharCode(c + 32);
                    } else if (e.shiftKey && shiftUps.hasOwnProperty(c)) {
                        c = shiftUps[c];
                    } else if (96 <= c && c <= 105) {
                        c = String.fromCharCode(c - 48);
                    } else {
                        c = String.fromCharCode(c);
                    }

                    return c;
                }

                return obj;
            })();

            /**
             * (c) jSuites modal
             * https://github.com/paulhodel/jsuites
             *
             * @author: Paul Hodel <paul.hodel@gmail.com>
             * @description: Modal
             */

            jSuites.modal = (function (el, options) {
                var obj = {};
                obj.options = {};

                // Default configuration
                var defaults = {
                    // Events
                    onopen: null,
                    onclose: null,
                    closed: false,
                    width: null,
                    height: null,
                    title: null,
                };

                // Loop through our object
                for (var property in defaults) {
                    if (options && options.hasOwnProperty(property)) {
                        obj.options[property] = options[property];
                    } else {
                        obj.options[property] = defaults[property];
                    }
                }

                el.classList.add('jmodal');

                if (obj.options.title) {
                    el.setAttribute('title', obj.options.title);
                }
                if (obj.options.width) {
                    el.style.width = obj.options.width;
                }
                if (obj.options.height) {
                    el.style.height = obj.options.height;
                }

                var container = document.createElement('div');
                for (var i = 0; i < el.children.length; i++) {
                    container.appendChild(el.children[i]);
                }
                el.appendChild(container);

                // Title
                if (!el.getAttribute('title')) {
                    el.classList.add('no-title');
                }

                if (!obj.options.closed) {
                    el.style.display = 'block';
                }

                obj.open = function () {
                    el.style.display = 'block';

                    if (typeof (obj.options.onopen) == 'function') {
                        obj.options.onopen(el);
                    }
                    // Backdrop
                    document.body.appendChild(jSuites.backdrop);

                    // Current
                    jSuites.modal.current = el;
                }

                obj.isOpen = function () {
                    return el.style.display != 'none' ? true : false;
                }

                obj.close = function () {
                    el.style.display = 'none';

                    if (typeof (obj.options.onclose) == 'function') {
                        obj.options.onclose(el);
                    }
                    // Backdrop
                    jSuites.backdrop.remove();

                    // Current
                    jSuites.modal.current = null;
                }

                if (!jSuites.modal.hasEvents) {
                    jSuites.modal.current = el;

                    document.addEventListener('mousedown', jSuites.modal.mouseDownControls);
                    document.addEventListener('mousemove', jSuites.modal.mouseMoveControls);
                    document.addEventListener('mouseup', jSuites.modal.mouseUpControls);

                    jSuites.modal.hasEvents = true;
                }

                // Keep object available from the node
                el.modal = obj;

                return obj;
            });

            jSuites.modal.current = null;
            jSuites.modal.position = null;

            jSuites.modal.mouseUpControls = function (e) {
                if (jSuites.modal.current) {
                    jSuites.modal.current.style.cursor = 'auto';
                }
                jSuites.modal.position = null;
            }

            jSuites.modal.mouseMoveControls = function (e) {
                if (jSuites.modal.current && jSuites.modal.position) {
                    if (e.which == 1 || e.which == 3) {
                        var position = jSuites.modal.position;
                        jSuites.modal.current.style.top = (position[1] + (e.clientY - position[3]) + (position[5] / 2)) + 'px';
                        jSuites.modal.current.style.left = (position[0] + (e.clientX - position[2]) + (position[4] / 2)) + 'px';
                        jSuites.modal.current.style.cursor = 'move';
                    } else {
                        jSuites.modal.current.style.cursor = 'auto';
                    }
                }
            }

            jSuites.modal.mouseDownControls = function (e) {
                jSuites.modal.position = [];

                if (e.target.classList.contains('jmodal')) {
                    setTimeout(function () {

                        var rect = e.target.getBoundingClientRect();
                        if (rect.width - (e.clientX - rect.left) < 50 && e.clientY - rect.top < 50) {
                            e.target.modal.close();
                        } else {
                            if (e.target.getAttribute('title') && e.clientY - rect.top < 50) {
                                if (document.selection) {
                                    document.selection.empty();
                                } else if (window.getSelection) {
                                    window.getSelection().removeAllRanges();
                                }

                                jSuites.modal.position = [
                                    rect.left,
                                    rect.top,
                                    e.clientX,
                                    e.clientY,
                                    rect.width,
                                    rect.height,
                                ];
                            }
                        }
                    }, 100);
                }
            }



            return jSuites;

        })));
    </script>
    <style>

               /**
        * (c) jSuites Javascript Web Components
        *
        * Author: Paul Hodel <paul.hodel@gmail.com>
        * Website: https://bossanova.uk/jsuites/
        * Description: Create amazing web based applications.
        *
        * MIT License
        *
        */

               /** General **/

               .jdragging {
                   opacity: 0.2;
                   filter: alpha(opacity=20);
               }

               .jupload {
                   background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAAAsTAAALEwEAmpwYAAA7emlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxMzggNzkuMTU5ODI0LCAyMDE2LzA5LzE0LTAxOjA5OjAxICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTctMTItMzFUMjI6NDM6MzBaPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTgtMDEtMDFUMjA6MDM6MjNaPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxOC0wMS0wMVQyMDowMzoyM1o8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6ZDE3NGVkY2UtNWZkNC0wODRkLTkzNzAtZDRhODVmMzdkNjdiPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjBmYzcxZDEyLTg1MGUtY2E0NS05MzE4LWRhYjI5YWZhMmQ4MjwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjBmYzcxZDEyLTg1MGUtY2E0NS05MzE4LWRhYjI5YWZhMmQ4MjwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowZmM3MWQxMi04NTBlLWNhNDUtOTMxOC1kYWIyOWFmYTJkODI8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTctMTItMzFUMjI6NDM6MzBaPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjk2MTA5Y2Y0LTEwM2ItNTc0Ny1hZWE3LWI5NDMxOWY0NWFkZjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxOC0wMS0wMVQyMDowMjoyMFo8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE3IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDE3NGVkY2UtNWZkNC0wODRkLTkzNzAtZDRhODVmMzdkNjdiPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE4LTAxLTAxVDIwOjAzOjIzWjwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjY1NTM1PC9leGlmOkNvbG9yU3BhY2U+CiAgICAgICAgIDxleGlmOlBpeGVsWERpbWVuc2lvbj44MDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj44MDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+tc8AsgAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAGjUlEQVR42uycW2xURRjHf91SoEIBUQpYI8VSVBDExniLERNUJBpQVEDFqE1AEYkX0JCC0YjgBdEYDOIFeVEEFRBilKBogg+KiQoV5Q6Khla8lrZRBLo+zLdazs7ZM2d3zsJu55/sy3dmz5797Vy+y8wWxONxnNJXzCFwAB1AB9ABdHIAHUAH0AF0Cq929fX1ufbMA4HLgSqgHOgPdJJrfwPbgb3AJuBD4KsoH6agrq4uF6CVAncC4wVYGP0ALAVeAva0NYDFwOPARKBzhvc6ArwG1AC/toU5cDSwFXjAAjyAQmACsAOozneATwLLgdMM2/8jLxN1AxYBC/J1CL8F3BjQZhOwCqgFvgd+AuJAT6ACOBMYCVwUcJ91siDlDcC3gRtSXF8IzAe+M7xfOXC3TAOFPm3WA0NzAeDp8oUGASeKrUF60R6Zn6an6CnTgI1pfnYFMAcY43N9GTDueAR4sQylK8RvS0dzgYcsPc9U4Bmfa9XA4uMF4GXypUdkeJ8Z0nNs6hbgdZ9rPcK6OLZX4XbisH5iAd68COABvAHc63NtwbHsgf2B94BKC/faAFwY8Zy8ErhWYx8EbM42wAuAj4ETAtptllh1N9AiC0t/YLCnXV9xT6JUJ6AOKPHYX5HIJ2sAK4BvgQ4+17fJ5LxKIgudzgBGySS/3sAPtKWZwCyPrQk4ydQxtwFwH9BbY4/LIvBEyF5RIF8iG+oC/K7xEUfLEI98EVnsA28/MCQkPIDmLMIDOCDOu1fXZGMVrgJu19gbZCKuJTek62mV2QD4XIoFZT+5o10a2ylRA6wCLtXYp8uikUv6Webr1uoOdIwS4HiNbS/wFLmnZuCgx9Y+hVdhBeBwjW1+BF9uFvBqFiDGDW3a0Cus+gADPLYWVB7PpiaJn5YYZjMigles6W2NskJH0gN1RZ1EJcyWJnvi0hpUbSQK9dRwaDGIqtIGeLbG9o3lnveCT2YmCogVPqvwdpOIKB2A7TU2W+XCiQEZkSggTvGxl8m0NNc2wDKNrcXCF5mASoUFaQYw2xK8Iv4vyvtpmsTxGQHsLPPQLp9frI+FYftyiPY1liAeBs5DZYNS/XgjgTXpApwq4Gaj0k86DbK4YISBmOlwjreaw+8CzvEDJa7bojAATwU+QtUQSg0Wlr4WFwxT2Z4Ta1GZ9Md8rlcDY00ADpFfZViID7/D8oJxrCACPCIjQ6elqOK8ryM9GPg64AM+B1YAW1BJ0r9M/aaQC0YYiAWWne0FQFf0dZnngdsgOaHaXVySLj43XSY3zCRVNclSz9NpTgQRywfAVRr7WcDWmKaxDl4TKuU+LkN4kyOEF1XEMk5GmFf3eOfAKcD5moY/ypy4OsMHeTjDBSPMcF5o8X4NPs70eKAoMYSLJIDuoOl5AwRiJroJWIIq1BwM8DcLDFyPpoAESTEqN/m0aVYlQF1RtRPviB2ZWEQeRJ//Gm0BHqhttieTutJVgkrGBu0FbEbtvmoMgNjLErxEL3yH5L01oxIA79O8aTVqj7ENmWSpGw1DwhZUJTBIf1ieGlZoAFbGxG3pESLIjkolBsMXaVNC9qWrnZTFZJh69SV283v5oHrNlNA9JvGfV0scL+3cm1Q7iaFPKNY6XimTD0fFwuWaRrscqyR11Hgqh2IkZ5gPy7LtdLRKNX7gnzHgkMdYGDIx0FZUrrHVxVBHBLzDup/jlaSrNbbdMWCn5sIAxyspsrlZY18TQ3/mYoxjdpQmkFx8OgKsjAHvat4wlFZZVyce1diWA80x4DOf7Ma8LD+kaYhmGvLZ0ovoa0LP0mpZ1qXXq4Fzs/igiSRBY8BrH3bq0Ca6HlWt82od6iTBfyn9Lj6+Xx2q2nYwSz3Q9FhrE/ZSVX66BPjU51q/RLCR6IEH0KfCe8sQL85SmNRo+Ioa3tgU8Ga2jtS8RaUdPj7gTtQRqS/yfLHogErf+6Xykk52ekOTESm67AbUrvuyPARXAtyPSvz6wduK5myx7pzIcPy3N4D6Z4w3pc0O1IbybAwrWyqSubZUOsYw4DrU4Ro/bUEd3m4wAZjoie8bPtARVNkvVwAWypxu6gqtRW0u0i6kqU4qDUEVUirasANdQ8BhoVSbizai/uRmbhsEtxp1lCPwpJXpWbmBqD++uTWPQ7xm1NaVJeIomzmvIQ8bdpO0zpWozea9Aibf41WHgd9QhaJtqAPia4FfQnv/7l98M5P79zYH0AF0AB1AJwfQAXQAHUCnNPTvAKemiFU6nb96AAAAAElFTkSuQmCC);
                   background-repeat: no-repeat;
                   background-size: 100px;
                   background-position: center;
                   background-color: rgb(230, 230, 230, 0.1);
                   border: 1px dotted #eee;
                   cursor: pointer;
                   box-sizing: border-box;
                   width: 100%;
                   min-height: 180px;
               }

               .jbackdrop {
                   position: fixed;
                   top: 0px;
                   left: 0px;
                   min-width: 100%;
                   min-height: 100%;
                   background-color: rgba(0,0,0,0.5);
                   border: 0px;
                   padding: 0px;
                   z-index: 8000;
                   -webkit-touch-callout: none; /* iOS Safari */
                   -webkit-user-select: none; /* Safari */
                   -khtml-user-select: none; /* Konqueror HTML */
                   -moz-user-select: none; /* Firefox */
                   -ms-user-select: none; /* Internet Explorer/Edge */
                   user-select: none; /* Non-prefixed version, currently
                                         supported by Chrome and Opera */
               }

               .jremove {
                   opacity: 0.2;
                   filter: alpha(opacity=20);
               }

               /** Animations **/
               .fade-in {
                   animation: fade-in 2s forwards;
                   -webkit-animation: fade-in 2s forwards;
               }

               .fade-out {
                   animation: fade-out 1s forwards;
                   -webkit-animation: fade-out 1s forwards;
               }

               .slide-left-in {
                   animation: slide-left-in 0.4s forwards;
                   -webkit-animation: slide-left-in 0.4s forwards;
               }

               .slide-left-out {
                   animation: slide-left-out 0.4s forwards;
                   -webkit-animation: slide-left-out 0.4s forwards;
               }

               .slide-right-in {
                   animation: slide-right-in 0.4s forwards;
                   -webkit-animation: slide-right-in 0.4s forwards;
               }

               .slide-right-out {
                   animation: slide-right-out 0.4s forwards;
                   -webkit-animation: slide-right-out 0.4s forwards;
               }

               .slide-top-in {
                   animation: slide-top-in 0.4s forwards;
                   -webkit-animation: slide-top-in 0.4s forwards;
               }

               .slide-top-out {
                   animation: slide-top-out 0.2s forwards;
                   -webkit-animation: slide-top-out 0.2s forwards;
               }

               .slide-bottom-in {
                   animation: slide-bottom-in 0.4s forwards;
                   -webkit-animation: slide-bottom-in 0.4s forwards;
               }

               .slide-bottom-out {
                   animation: slide-bottom-out 0.2s forwards;
                   -webkit-animation: slide-bottom-out 0.2s forwards;
               }

               /** Fadein and Fadeout **/
               @keyframes fade-in {
                   0% {
                       opacity: 0;
                   }

                   100% {
                       opacity: 100;
                   }
               }

               @-webkit-keyframes fade-in {
                   0% {
                       opacity: 0;
                   }

                   100% {
                       opacity: 100;
                   }
               }

               @keyframes fade-out {
                   0% {
                       opacity: 100;
                   }

                   100% {
                       opacity: 0;
                   }
               }

               @-webkit-keyframes fade-out {
                   0% {
                       opacity: 100;
                   }

                   100% {
                       opacity: 0;
                   }
               }

               /** Keyframes Left to Right **/
               @keyframes slide-left-in {
                   0% {
                       transform: translateX(-100%);
                   }

                   100% {
                       transform: translateX(0%);
                   }
               }

               @-webkit-keyframes slide-left-in {
                   0% {
                       transform: translateX(-100%);
                   }

                   100% {
                       -webkit-transform: translateX(0%);
                   }
               }

               @keyframes slide-left-out {
                   0% {
                       transform: translateX(0%);
                   }

                   100% {
                       transform: translateX(-100%);
                   }
               }

               @-webkit-keyframes slide-left-out {
                   0% {
                       -webkit-transform: translateX(0%);
                   }

                   100% {
                       -webkit-transform: translateX(-100%);
                   }
               }

               /** Keyframes Right to Left **/
               @keyframes slide-right-in {
                   0% {
                       transform: translateX(100%);
                   }

                   100% {
                       transform: translateX(0%);
                   }
               }

               @-webkit-keyframes slide-right-in {
                   0% {
                       transform: translateX(100%);
                   }

                   100% {
                       -webkit-transform: translateX(0%);
                   }
               }

               @keyframes slide-right-out {
                   0% {
                       transform: translateX(0%);
                   }

                   100% {
                       transform: translateX(100%);
                   }
               }

               @-webkit-keyframes slide-right-out {
                   0% {
                       -webkit-transform: translateX(0%);
                   }

                   100% {
                       -webkit-transform: translateX(100%);
                   }
               }

               /** Keyframes Top to Bottom **/
               @keyframes slide-top-in {
                   0% {
                       transform: translateY(-100%);
                   }

                   100% {
                       transform: translateY(0%);
                   }
               }

               @-webkit-keyframes slide-top-in {
                   0% {
                       transform: translateY(-100%);
                   }

                   100% {
                       -webkit-transform: translateY(0%);
                   }
               }

               @keyframes slide-top-out {
                   0% {
                       transform: translateY(0%);
                   }

                   100% {
                       transform: translateY(-100%);
                   }
               }

               @-webkit-keyframes slide-top-out {
                   0% {
                       -webkit-transform: translateY(0%);
                   }

                   100% {
                       -webkit-transform: translateY(-100%);
                   }
               }

               /** Keyframes Bottom to Top **/
               @keyframes slide-bottom-in {
                   0% {
                       transform: translateY(100%);
                   }

                   100% {
                       transform: translateY(0%);
                   }
               }

               @-webkit-keyframes slide-bottom-in {
                   0% {
                       transform: translateY(100%);
                   }

                   100% {
                       -webkit-transform: translateY(0%);
                   }
               }

               @keyframes slide-bottom-out {
                   0% {
                       transform: translateY(0%);
                   }

                   100% {
                       transform: translateY(100%);
                   }
               }

               @-webkit-keyframes slide-bottom-out {
                   0% {
                       -webkit-transform: translateY(0%);
                   }

                   100% {
                       -webkit-transform: translateY(100%);
                   }
               }


               @supports (-webkit-overflow-scrolling: touch) {
                   .app .options input:checked:before {
                       top: -12px;
                   }
               }

               @-webkit-keyframes spin {
                   from {
                       -webkit-transform: rotate(0deg);
                   }

                   to {
                       -webkit-transform: rotate(360deg);
                   }
               }

               @keyframes spin {
                   from {
                       transform: rotate(0deg);
                   }

                   to {
                       transform: rotate(360deg);
                   }
               }

               .unselectable {
                   -webkit-touch-callout: none;
                   -webkit-user-select: none;
                   -khtml-user-select: none;
                   -moz-user-select: none;
                   -ms-user-select: none;
                   user-select: none;
               }

               /**
        * Date & Datetime picker v1.0.1
        * Author: paul.hodel@gmail.com
        * https://github.com/paulhodel/jtools
        */

               .jcalendar {
                   position: relative;
                   z-index: 9000;
                   display: none;
                   box-sizing: border-box;
                   -webkit-touch-callout: none;
                   -webkit-user-select: none;
                   -khtml-user-select: none;
                   -moz-user-select: none;
                   -ms-user-select: none;
                   user-select: none;
                   -webkit-tap-highlight-color: rgba(0,0,0,0);
                   -webkit-tap-highlight-color: transparent;
                   min-width: 280px;
               }

               .jcalendar-focus {
                   display: block;
               }

               .jcalendar-backdrop {
                   position: fixed;
                   top: 0px;
                   left: 0px;
                   z-index: 9000;
                   min-width: 100%;
                   min-height: 100%;
                   background-color: rgba(0,0,0,0.5);
                   border: 0px;
                   padding: 0px;
                   display: none;
               }

               .jcalendar-container {
                   position: relative;
                   box-sizing: border-box;
               }

               .jcalendar-content {
                   position: absolute;
                   z-index: 9001;
                   -webkit-box-shadow: 1px 1px 5px 0px rgba(0,0,0,0.39);
                   -moz-box-shadow: 1px 1px 5px 0px rgba(0,0,0,0.39);
                   box-shadow: 1px 1px 5px 0px rgba(0,0,0,0.39);
                   background-color: #fff;
               }

                   .jcalendar-content > table {
                       width: 100%;
                       background-color: #fff;
                       border-top: 1px solid #ddd;
                   }

                       .jcalendar-content > table > tbody td {
                           box-sizing: border-box;
                           cursor: pointer;
                           padding: 9px;
                           font-size: 0.9em;
                       }

                       .jcalendar-content > table > thead {
                           cursor: pointer;
                       }

               .jcalendar-header {
                   text-align: center;
               }

                   .jcalendar-header span {
                       margin-right: 4px;
                       font-size: 1.2em;
                       font-weight: bold;
                   }

               .jcalendar-prev {
                   cursor: pointer;
                   background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z' fill='%23000' /%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3C/svg%3E");
                   background-position: center;
                   background-repeat: no-repeat;
               }

               .jcalendar-next {
                   cursor: pointer;
                   background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z' fill='%23000' /%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3C/svg%3E");
                   background-position: center;
                   background-repeat: no-repeat;
               }

               .jcalendar-weekday {
                   font-weight: 550;
                   background-color: #fcfcfc;
                   padding: 14px;
               }

               .jcalendar thead td {
                   padding: 10px;
                   height: 40px;
               }

               .jcalendar tfoot td {
                   padding: 10px;
               }

               .jcalendar-months td, .jcalendar-years td {
                   height: 24px;
               }

               .jcalendar-input {
                   padding-right: 18px;
                   background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24'%3E%3Cpath d='M20 3h-1V1h-2v2H7V1H5v2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 18H4V8h16v13z'/%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3C/svg%3E");
                   background-position: right;
                   background-repeat: no-repeat;
                   box-sizing: border-box;
               }

               .jcalendar-done {
                   -webkit-box-shadow: 1px 1px 5px 0px rgba(0,0,0,0.39);
                   -moz-box-shadow: 1px 1px 5px 0px rgba(0,0,0,0.39);
                   box-shadow: 1px 1px 5px 0px rgba(0,0,0,0.39);
                   background-color: #fff;
               }

               .jcalendar-update {
                   border: 1px solid #ccc;
                   background-color: #fff;
                   border-radius: 4px;
                   padding: 5px;
                   width: 100%;
               }

               .jcalendar select {
                   width: 55px;
                   display: inline-block;
                   border: 0px;
                   padding: 4px;
                   text-align: center;
                   font-size: 1.1em;
                   user-select: none;
                   margin-right: 10px;
               }

                   .jcalendar select:first-child {
                       margin-right: 2px;
                   }

               .jcalendar-selected {
                   background-color: #eee;
               }

               .jcalendar-reset, .jcalendar-confirm {
                   text-transform: uppercase;
                   cursor: pointer;
               }

               .jcalendar-controls {
                   padding: 15px;
                   -webkit-box-sizing: border-box;
                   box-sizing: border-box;
                   vertical-align: middle;
                   display: -webkit-box;
                   display: -moz-box;
                   display: -ms-flexbox;
                   display: -webkit-flex;
                   display: flex;
                   -webkit-flex-flow: row wrap;
                   justify-content: space-between;
                   align-items: center;
               }

                   .jcalendar-controls div {
                       font-weight: bold;
                   }

               .jcalendar-fullsize {
                   position: fixed;
                   width: 100%;
                   top: 0px;
                   left: 0px;
               }

                   .jcalendar-fullsize .jcalendar-content {
                       position: fixed;
                       width: 100%;
                       left: 0px;
                       bottom: 0px;
                   }

                   .jcalendar-fullsize .jcalendar-backdrop {
                       display: block;
                   }


               /**
        * Color Picker v1.0.1
        * Author: paul.hodel@gmail.com
        * https://github.com/paulhodel/jtools
        */

               .jcolor {
                   position: relative;
                   display: none;
                   outline: none;
               }

               .jcolor-content {
                   position: absolute;
                   z-index: 9000;
                   user-select: none;
                   -webkit-font-smoothing: antialiased;
                   font-size: .875rem;
                   letter-spacing: .2px;
                   -webkit-border-radius: 4px;
                   border-radius: 4px;
                   -webkit-box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.2);
                   box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.2);
                   padding: 10px;
                   background-color: #fff;
               }

               .jcolor-focus {
                   display: block;
               }

               .jcolor td {
                   border: 2px solid #fff;
               }

               .jcolor-selected {
                   border: 2px solid #000 !important;
                   background-repeat: no-repeat;
                   background-size: cover;
                   background-position: 0 0;
                   background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z' fill='white'/%3E%3C/svg%3E");
               }

               /**
        * Contextmenu v1.0.1
        * Author: paul.hodel@gmail.com
        * https://github.com/paulhodel/jsuites
        */

               .jcontextmenu {
                   position: fixed;
                   z-index: 10000;
                   background: #fff;
                   color: #555;
                   font-family: sans-serif;
                   font-size: 11px;
                   -webkit-user-select: none;
                   -moz-user-select: none;
                   user-select: none;
                   -webkit-box-shadow: 2px 2px 2px 0px rgba(143, 144, 145, 1);
                   -moz-box-shadow: 2px 2px 2px 0px rgba(143, 144, 145, 1);
                   box-shadow: 2px 2px 2px 0px rgba(143, 144, 145, 1);
                   border: 1px solid #C6C6C6;
                   padding: 0px;
                   padding-top: 4px;
                   padding-bottom: 4px;
                   margin: 0px;
                   outline: none;
                   display: none;
               }

                   .jcontextmenu.jcontextmenu-focus {
                       display: inline-block;
                   }

                   .jcontextmenu li {
                       box-sizing: border-box;
                       display: block;
                       padding: 8px 8px 8px 30px;
                       width: 250px;
                       position: relative;
                       cursor: default;
                   }

                       .jcontextmenu li a {
                           color: #555;
                           text-decoration: none;
                       }

                       .jcontextmenu li span {
                           float: right;
                           margin-right: 10px;
                       }

                   .jcontextmenu .contextmenu-disabled {
                       color: #a1a192;
                   }

                   .jcontextmenu li:not(.contextmenu-line):hover {
                       background: #ebebeb;
                   }

                   .jcontextmenu li.contextmenu-line {
                       border-top: 1px solid #e9e9e9;
                       margin-top: 5px;
                       padding: 2px;
                   }

                   .jcontextmenu hr {
                       border: 1px solid #e9e9e9;
                       border-bottom: 0;
                       margin-top: 5px;
                       margin-bottom: 5px;
                   }

               /**
        * (c) 2013 jDropdown
        * http://www.github.com/paulhodel/jdropdown
        *
        * @author: Paul Hodel <paul.hodel@gmail.com>
        * @description: Custom dropdowns
        */

               .jdropdown {
                   cursor: pointer;
                   -webkit-touch-callout: none;
                   -webkit-user-select: none;
                   -khtml-user-select: none;
                   -moz-user-select: none;
                   -ms-user-select: none;
                   user-select: none;
                   box-sizing: border-box;
                   background: #fff;
                   -webkit-tap-highlight-color: transparent;
               }

               .jdropdown-header::placeholder {
                   color: #000;
               }

               .jdropdown-backdrop {
                   position: fixed;
                   top: 0px;
                   left: 0px;
                   min-width: 100%;
                   min-height: 100%;
                   background-color: rgba(0,0,0,0.5);
                   border: 0px;
                   padding: 0px;
                   z-index: 8000;
                   display: none;
               }

               .jdropdown-focus {
                   position: relative;
               }

                   .jdropdown-focus .jdropdown-container {
                       display: block;
                   }

                   .jdropdown-focus .jdropdown-header {
                       outline: auto 5px -webkit-focus-ring-color;
                   }

               .jdropdown-container-header {
                   padding: 0px;
                   margin: 0px;
               }

               .jdropdown-header {
                   width: 100%;
                   appearance: none;
                   background-repeat: no-repeat;
                   background-position: top 50% right 5px;
                   background-image: url("data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath d='M7 10l5 5 5-5H7z' fill='gray'/%3E%3C/svg%3E");
                   text-overflow: ellipsis;
                   cursor: pointer;
                   box-sizing: border-box;
                   -webkit-appearance: none;
                   -moz-appearance: none;
               }

               .jdropdown-container {
                   display: none;
               }

               .jdropdown-close {
                   display: none;
                   font-size: 1em;
                   color: #1f93ff;
                   text-transform: uppercase;
                   text-align: right;
                   padding: 10px;
                   padding-right: 15px;
               }

               .jdropdown-content {
                   min-width: inherit;
                   margin: 0px;
                   box-sizing: border-box;
               }

                   .jdropdown-content:empty {
                   }

               .jdropdown-item {
                   white-space: nowrap;
                   text-align: left;
                   text-overflow: ellipsis;
                   overflow-x: hidden;
                   color: #000;
                   display: flex;
                   align-items: center;
               }

               .jdropdown-image {
                   margin-right: 10px;
                   width: 40px;
                   height: 40px;
                   border-radius: 20px;
               }

               .jdropdown-image-small {
                   width: 24px;
                   height: 24px;
               }

               .jdropdown-title {
                   font-size: 0.7em;
                   color: #aaa;
                   text-overflow: ellipsis;
                   overflow-x: hidden;
                   display: block;
               }

               /** Default visual **/

               .jdropdown-default .jdropdown-header {
                   border: 1px solid #ccc;
                   padding: 5px;
                   padding-left: 10px;
                   padding-right: 16px;
               }

               .jdropdown-default .jdropdown-container {
                   position: absolute;
                   z-index: 9001;
                   background-color: #fff;
               }

               .jdropdown-default .jdropdown-content {
                   min-width: inherit;
                   border: 1px solid #8fb1e3;
                   margin: 0px;
                   background-color: #fff;
                   box-sizing: border-box;
                   min-height: 10px;
                   max-height: 215px;
                   overflow-y: auto;
               }

               .jdropdown-default .jdropdown-item {
                   padding: 4px;
                   padding-left: 8px;
                   padding-right: 40px;
               }

                   .jdropdown-default .jdropdown-item:hover {
                       background-color: #1f93ff;
                       color: #fff;
                   }

               .jdropdown-default .jdropdown-cursor {
                   background-color: #1f93ff;
                   color: #fff;
               }

               .jdropdown-default .jdropdown-selected {
                   background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiAvPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiIGZpbGw9IndoaXRlIiAvPjwvc3ZnPgo=');
                   background-repeat: no-repeat;
                   background-position: top 50% right 5px;
                   background-color: #1f93ff;
                   color: #fff;
               }

               .jdropdown-default .jdropdown-group {
                   margin-top: 5px;
               }

                   .jdropdown-default .jdropdown-group .jdropdown-item {
                       padding-left: 16px;
                   }

               .jdropdown-default .jdropdown-group-name {
                   padding-left: 8px;
                   font-weight: bold;
               }


               /** Default render for mobile **/

               .jdropdown-picker {
                   width: 100% !important;
                   border-top: 1px solid #e6e6e8;
                   border-bottom: 1px solid #e6e6e8;
                   padding-top: 10px;
                   padding-bottom: 10px;
                   box-sizing: border-box;
               }

                   .jdropdown-picker.jdropdown-focus .jdropdown-backdrop {
                       display: block;
                   }

                   .jdropdown-picker .jdropdown-header {
                       border: 0px;
                       padding: 0px;
                       margin: 0px;
                       outline: none;
                       text-transform: uppercase;
                       font-size: 1em;
                       padding-right: 24px;
                   }

                   .jdropdown-picker .jdropdown-container {
                       position: fixed;
                       bottom: 0px;
                       left: 0px;
                       border-bottom: 1px solid #e6e6e8;
                       width: 100%;
                       background-color: #fff;
                       box-sizing: border-box;
                       z-index: 9000;
                   }

                   .jdropdown-picker .jdropdown-close {
                       -webkit-box-shadow: 0px -1px 5px 0px rgba(0,0,0,0.39);
                       -moz-box-shadow: 0px -1px 5px 0px rgba(0,0,0,0.39);
                       box-shadow: 0px -1px 5px 0px rgba(0,0,0,0.39);
                       background-color: #fff;
                       display: block;
                   }

                   .jdropdown-picker .jdropdown-content {
                       overflow-y: scroll;
                       height: 280px;
                       background-color: #fafafa;
                       border-top: 1px solid #e6e6e8;
                   }

                   .jdropdown-picker .jdropdown-group-name {
                       font-size: 1em;
                       text-transform: uppercase;
                       padding-top: 10px;
                       padding-bottom: 10px;
                       display: block;
                       border-bottom: 1px solid #e6e6e8;
                       padding-left: 20px;
                       padding-right: 20px;
                       text-align: center;
                       font-weight: bold;
                   }

                   .jdropdown-picker .jdropdown-item {
                       font-size: 1em;
                       text-transform: uppercase;
                       padding-top: 10px;
                       padding-bottom: 10px;
                       display: block;
                       border-bottom: 1px solid #e6e6e8;
                       padding-left: 20px;
                       padding-right: 20px;
                   }

                   .jdropdown-picker .jdropdown-selected {
                       background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiAvPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiIGZpbGw9IndoaXRlIiAvPjwvc3ZnPgo=');
                       background-repeat: no-repeat;
                       background-position: top 50% right 15px;
                       background-color: #1f93ff;
                       color: #fff;
                   }

                   .jdropdown-picker .jdropdown-cursor {
                       background-color: #1f93ff;
                       color: #fff;
                   }

               /** Default render for mobile searchbar **/

               .jdropdown-searchbar {
                   width: 100%;
                   border-top: 1px solid #e6e6e8;
                   border-bottom: 1px solid #e6e6e8;
                   padding-top: 10px;
                   padding-bottom: 10px;
               }

                   .jdropdown-searchbar.jdropdown-focus {
                       position: absolute;
                       top: 0px;
                       left: 0px;
                       min-height: 100%;
                       background-color: #fafafa;
                       padding: 0px;
                       padding-top: 40px;
                       z-index: 9001;
                   }

                       .jdropdown-searchbar.jdropdown-focus .jdropdown-container-header {
                           padding: 10px;
                           background-color: #fff;
                           box-shadow: 0 1px 2px rgba(0,0,0,.1);
                           position: fixed;
                           top: 0px;
                           left: 0px;
                           width: 100%;
                       }

                       .jdropdown-searchbar.jdropdown-focus .jdropdown-header {
                           background-repeat: no-repeat;
                           background-position-x: 0%;
                           background-position-y: 40%;
                           background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTUuNSAxNGgtLjc5bC0uMjgtLjI3QzE1LjQxIDEyLjU5IDE2IDExLjExIDE2IDkuNSAxNiA1LjkxIDEzLjA5IDMgOS41IDNTMyA1LjkxIDMgOS41IDUuOTEgMTYgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHoiIGZpbGw9IiNlNmU2ZTgiLz48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PC9zdmc+);
                           padding-left: 30px !important;
                           padding-right: 60px !important;
                       }

                       .jdropdown-searchbar.jdropdown-focus .jdropdown-close {
                           font-weight: bold;
                           display: block;
                       }

                   .jdropdown-searchbar .jdropdown-header {
                       border: 0px;
                       padding: 0px;
                       margin: 0px;
                       outline: none;
                       text-transform: uppercase;
                       font-size: 1em;
                       padding-right: 30px;
                   }

                   .jdropdown-searchbar .jdropdown-close {
                       position: fixed;
                       top: 0px;
                       right: 0px;
                   }

                   .jdropdown-searchbar .jdropdown-content {
                       margin-top: 10px;
                   }

                   .jdropdown-searchbar .jdropdown-group {
                       margin-top: 10px;
                       margin-bottom: 15px;
                       background-color: #fff;
                   }

                   .jdropdown-searchbar .jdropdown-group-name {
                       border-top: 1px solid #e6e6e8;
                       border-bottom: 1px solid #e6e6e8;
                       padding: 10px;
                       padding-left: 12px;
                       font-weight: bold;
                   }

                   .jdropdown-searchbar .jdropdown-group-arrow {
                       float: right;
                       width: 24px;
                       height: 24px;
                       background-repeat: no-repeat;
                   }

                   .jdropdown-searchbar .jdropdown-group-arrow-down {
                       background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNy40MSA4LjU5TDEyIDEzLjE3bDQuNTktNC41OEwxOCAxMGwtNiA2LTYtNiAxLjQxLTEuNDF6Ii8+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgyNHYyNEgwVjB6Ii8+PC9zdmc+);
                   }

                   .jdropdown-searchbar .jdropdown-group-arrow-up {
                       background-image: url(data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTcuNDEgMTUuNDFMMTIgMTAuODNsNC41OSA0LjU4TDE4IDE0bC02LTYtNiA2eiIvPjxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=);
                   }

                   .jdropdown-searchbar .jdropdown-item {
                       padding-top: 10px;
                       padding-bottom: 10px;
                       border-bottom: 1px solid #e6e6e8;
                       padding-left: 15px;
                       padding-right: 40px;
                       background-color: #fff;
                       font-size: 0.9em;
                   }

                   .jdropdown-searchbar .jdropdown-description {
                       text-overflow: ellipsis;
                       overflow: hidden;
                       max-width: calc(100%-20px);
                   }

                   .jdropdown-searchbar .jdropdown-content > .jdropdown-item:first-child {
                       border-top: 1px solid #e6e6e8;
                   }

                   .jdropdown-searchbar .jdropdown-selected {
                       background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTYuMTdMNC44MyAxMmwtMS40MiAxLjQxTDkgMTkgMjEgN2wtMS40MS0xLjQxeiIgZmlsbD0iIzAwN2FmZiIvPjwvc3ZnPg==');
                       background-repeat: no-repeat;
                       background-position: top 50% right 15px;
                   }

               /** List render **/

               .jdropdown-list {
               }

                   .jdropdown-list .jdropdown-container {
                       display: block;
                   }

                   .jdropdown-list .jdropdown-header {
                       display: none;
                   }

                   .jdropdown-list .jdropdown-group {
                       background-color: #fff;
                   }

                   .jdropdown-list .jdropdown-group-name {
                       border-bottom: 1px solid #e6e6e8;
                       padding-top: 10px;
                       padding-bottom: 10px;
                       font-weight: bold;
                   }

                   .jdropdown-list .jdropdown-item {
                       padding-top: 10px;
                       padding-bottom: 10px;
                       border-bottom: 1px solid #e6e6e8;
                       padding-left: 10px;
                       padding-right: 40px;
                       background-color: #fff;
                   }

                   .jdropdown-list .jdropdown-selected {
                       background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTYuMTdMNC44MyAxMmwtMS40MiAxLjQxTDkgMTkgMjEgN2wtMS40MS0xLjQxeiIgZmlsbD0iIzAwN2FmZiIvPjwvc3ZnPg==');
                       background-repeat: no-repeat;
                       background-position: top 50% right 10px;
                   }

               @media only screen and (max-device-width : 800px) {
                   .jdropdown-list {
                       width: 100% !important;
                       border: 0px;
                       padding: 0px;
                   }

                       .jdropdown-list .jdropdown-container {
                           min-width: 100%;
                       }
               }

               /**
        * (c) jLoading
        * https://github.com/paulhodel/jtools
        *
        * @author: Paul Hodel <paul.hodel@gmail.com>
        * @description: Page loading spin
        */

               .jloading {
                   position: fixed;
                   z-index: 10001;
                   width: 100%;
                   left: 0;
                   right: 0;
                   top: 0;
                   bottom: 0;
                   background-color: rgba(0,0,0,0.7);
               }

                   .jloading::after {
                       content: '';
                       display: block;
                       margin: 0 auto;
                       margin-top: 50vh;
                       width: 40px;
                       height: 40px;
                       border-style: solid;
                       border-color: white;
                       border-top-color: transparent;
                       border-width: 4px;
                       border-radius: 50%;
                       -webkit-animation: spin .8s linear infinite;
                       animation: spin .8s linear infinite;
                   }

                   .jloading.spin {
                       background-color: transparent;
                   }

                       .jloading.spin::after {
                           margin: 0 auto;
                           margin-top: 80px;
                           border-color: #aaa;
                           border-top-color: transparent;
                       }


               /**
        * (c) jTools Modal page
        * https://github.com/paulhodel/jtools
        *
        * @author: Paul Hodel <paul.hodel@gmail.com>
        * @description: Modal page
        */

               .jmodal {
                   position: fixed;
                   top: 50%;
                   left: 50%;
                   width: 60%;
                   height: 60%;
                   -webkit-box-shadow: 0 2px 10px rgba(0,0,0,.2);
                   -moz-box-shadow: 0 2px 10px rgba(0,0,0,.2);
                   border: 1px solid #ccc;
                   background-color: #fff;
                   transform: translate(-50%, -50%);
                   box-sizing: border-box;
                   padding-top: 50px;
                   z-index: 9002;
                   display: none;
                   border-radius: 5px;
               }

                   .jmodal:before {
                       position: absolute;
                       top: 0;
                       left: 0;
                       width: 100%;
                       content: attr(title);
                       padding: 15px;
                       box-sizing: border-box;
                       background: #e3e3e3;
                       filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ededed', endColorstr='#e3e3e3');
                       background: -webkit-gradient(linear, left top, left bottom, from(#ededed), to(#e3e3e3));
                       background: -moz-linear-gradient(top, #ededed, #e3e3e3);
                       font-size: 1.2em;
                   }

                   .jmodal > div {
                       padding: 20px;
                       overflow-y: auto;
                       max-height: 100%;
                   }

                   .jmodal.no-title {
                       padding-top: 0px;
                   }

                       .jmodal.no-title:before {
                           display: none;
                       }

                   .jmodal:after {
                       content: '';
                       background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z'/%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3C/svg%3E");
                       position: absolute;
                       top: 0;
                       right: 0;
                       margin: 14px;
                       font-size: 24px;
                       width: 24px;
                       height: 24px;
                       cursor: pointer;
                       text-shadow: 0px 0px 5px #fff;
                   }
    </style>
    <style>
                /**
         * (c) jExcel v3.4.1
         *
         * Author: Paul Hodel <paul.hodel@gmail.com>
         * Website: https://bossanova.uk/jexcel/
         * Description: Create amazing web based spreadsheets.
         *
         * This software is distribute under MIT License
         */
                :root {
                    --jexcel-border-color: #000;
                }

                .jexcel_container {
                    display: inline-block;
                    padding-right: 2px;
                    box-sizing: border-box;
                    overscroll-behavior: contain;
                }

                    .jexcel_container.fullscreen {
                        position: fixed;
                        top: 0px;
                        left: 0px;
                        width: 100%;
                        height: 100%;
                        z-index: 2001;
                    }

                        .jexcel_container.fullscreen .jexcel_content {
                            overflow: auto;
                            width: 100%;
                            height: 100%;
                            background-color: #ffffff;
                        }

                        .jexcel_container.fullscreen.with-toolbar {
                            height: calc(100% - 46px);
                        }

                .jexcel_content {
                    display: inline-block;
                    box-sizing: border-box;
                    padding-right: 2px;
                    position: relative;
                }

                .jexcel {
                    border-collapse: separate;
                    table-layout: fixed;
                    white-space: nowrap;
                    empty-cells: show;
                    border: 0px;
                    background-color: #fff;
                    width: 0;
                    border-top: 1px solid transparent;
                    border-left: 1px solid transparent;
                    border-right: 1px solid #ccc;
                    border-bottom: 1px solid #ccc;
                }

                    .jexcel > thead > tr > td {
                        border-top: 1px solid #ccc;
                        border-left: 1px solid #ccc;
                        border-right: 1px solid transparent;
                        border-bottom: 1px solid transparent;
                        background-color: #f3f3f3;
                        padding: 2px;
                        cursor: pointer;
                        box-sizing: border-box;
                        overflow: hidden;
                        position: sticky;
                        top: 0;
                        z-index: 2000;
                    }

                    .jexcel > thead.draggable > tr > td::before {
                        content: '\00a0';
                        width: 100%;
                        height: 3px;
                        position: absolute;
                        bottom: 0px;
                        left: 0px;
                        cursor: move;
                    }

                    .jexcel > thead.resizable > tr > td::after {
                        content: '\00a0';
                        width: 3px;
                        height: 100%;
                        position: absolute;
                        top: 0px;
                        right: 0px;
                        cursor: col-resize;
                    }

                    .jexcel > thead > tr > td.dragging {
                        background-color: #fff;
                        opacity: 0.5;
                    }

                    .jexcel > thead > tr > td:first-child:after,
                    .jexcel > thead > tr.jexcel_nested > td::before,
                    .jexcel > thead > tr.jexcel_nested > td::after {
                        cursor: default;
                    }

                    .jexcel > thead > tr > td.selected {
                        background-color: #dcdcdc;
                    }

                    .jexcel > thead > tr > td.arrow-up {
                        background-repeat: no-repeat;
                        background-position: center right 5px;
                        background-image: url("data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath d='M7 14l5-5 5 5H7z' fill='gray'/%3E%3C/svg%3E");
                        text-decoration: underline;
                    }

                    .jexcel > thead > tr > td.arrow-down {
                        background-repeat: no-repeat;
                        background-position: center right 5px;
                        background-image: url("data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath d='M7 10l5 5 5-5H7z' fill='gray'/%3E%3C/svg%3E");
                        text-decoration: underline;
                    }

                    .jexcel > tbody > tr > td:first-child {
                        position: relative;
                        background-color: #f3f3f3;
                        text-align: center;
                    }

                    .jexcel > tbody.resizable > tr > td:first-child::before {
                        content: '\00a0';
                        width: 100%;
                        height: 3px;
                        position: absolute;
                        bottom: 0px;
                        left: 0px;
                        cursor: row-resize;
                    }

                    .jexcel > tbody.draggable > tr > td:first-child::after {
                        content: '\00a0';
                        width: 3px;
                        height: 100%;
                        position: absolute;
                        top: 0px;
                        right: 0px;
                        cursor: move;
                    }

                    .jexcel > tbody > tr.dragging > td {
                        background-color: #eee;
                        opacity: 0.5;
                    }

                    .jexcel > tbody > tr > td {
                        border-top: 1px solid #ccc;
                        border-left: 1px solid #ccc;
                        border-right: 1px solid transparent;
                        border-bottom: 1px solid transparent;
                        padding: 4px;
                        white-space: nowrap;
                        box-sizing: border-box;
                        line-height: 1em;
                    }

                        .jexcel > tbody > tr > td:last-child {
                            overflow: hidden;
                        }

                        .jexcel > tbody > tr > td > img {
                            display: inline-block;
                            max-width: 100px;
                        }

                        .jexcel > tbody > tr > td.readonly {
                            color: rgba(0,0,0,0.3)
                        }

                    .jexcel > tbody > tr.selected > td:first-child {
                        background-color: #dcdcdc;
                    }

                    .jexcel > tbody > tr > td > select,
                    .jexcel > tbody > tr > td > input,
                    .jexcel > tbody > tr > td > textarea {
                        border: 0px;
                        border-radius: 0px;
                        outline: 0px;
                        width: 100%;
                        margin: 0px;
                        padding: 0px;
                        background-color: transparent;
                        box-sizing: border-box;
                    }

                    .jexcel > tbody > tr > td > textarea {
                        resize: none;
                        padding-top: 6px !important;
                    }

                    .jexcel > tbody > tr > td > input[type=checkbox] {
                        width: 12px;
                        margin-top: 2px;
                    }

                    .jexcel > tbody > tr > td > input[type=radio] {
                        width: 12px;
                        margin-top: 2px;
                    }

                    .jexcel > tbody > tr > td > select {
                        -webkit-appearance: none;
                        -moz-appearance: none;
                        appearance: none;
                        background-repeat: no-repeat;
                        background-position-x: 100%;
                        background-position-y: 40%;
                        background-image: url(data:image/svg+xml;base64,PHN2ZyBmaWxsPSdibGFjaycgaGVpZ2h0PScyNCcgdmlld0JveD0nMCAwIDI0IDI0JyB3aWR0aD0nMjQnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTTcgMTBsNSA1IDUtNXonLz48cGF0aCBkPSdNMCAwaDI0djI0SDB6JyBmaWxsPSdub25lJy8+PC9zdmc+);
                    }

                    .jexcel > tbody > tr > td.dropdown {
                        background-repeat: no-repeat;
                        background-position: top 50% right 5px;
                        background-image: url("data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath d='M7 10l5 5 5-5H7z' fill='lightgray'/%3E%3C/svg%3E");
                        text-overflow: ellipsis;
                        overflow-x: hidden;
                    }

                        .jexcel > tbody > tr > td.dropdown.jexcel_comments {
                            background: url("data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath d='M7 10l5 5 5-5H7z' fill='lightgray'/%3E%3C/svg%3E") top 50% right 5px no-repeat, url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE5LTAxLTMxVDE4OjU1OjA4WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0wMS0zMVQxODo1NTowOFoiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTAxLTMxVDE4OjU1OjA4WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDphMTlhZDJmOC1kMDI2LTI1NDItODhjOS1iZTRkYjkyMmQ0MmQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpkOGI5NDUyMS00ZjEwLWQ5NDktYjUwNC0wZmU1N2I3Nzk1MDEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMzdjYmE1ZS1hYTMwLWNkNDUtYTAyNS1lOWYxZjk2MzUzOGUiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDplMzdjYmE1ZS1hYTMwLWNkNDUtYTAyNS1lOWYxZjk2MzUzOGUiIHN0RXZ0OndoZW49IjIwMTktMDEtMzFUMTg6NTU6MDhaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmExOWFkMmY4LWQwMjYtMjU0Mi04OGM5LWJlNGRiOTIyZDQyZCIgc3RFdnQ6d2hlbj0iMjAxOS0wMS0zMVQxODo1NTowOFoiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4En6MDAAAAX0lEQVQYlX3KOw6AIBBAwS32RpJADXfx0pTET+ERZJ8F8RODFtONsG0QAoh0CSDM82dqodaBdQXnfoLZQM7gPai+wjNNE8R4pTuAYNZSKZASqL7CMy0LxNgJp30fKYUDi3+vIqb/+rUAAAAASUVORK5CYII=') top right no-repeat;
                        }

                    .jexcel > tbody > tr > td > .color {
                        width: 90%;
                        height: 10px;
                        margin: auto;
                    }

                    .jexcel .highlight {
                        background-color: rgba(0,0,0,0.05);
                    }

                    .jexcel .highlight-top {
                        border-top: 1px solid #000; /* var(--jexcel-border-color);*/
                        box-shadow: 0px -1px #ccc;
                    }

                    .jexcel .highlight-left {
                        border-left: 1px solid #000; /* var(--jexcel-border-color);*/
                        box-shadow: -1px 0px #ccc;
                    }

                    .jexcel .highlight-right {
                        border-right: 1px solid #000; /* var(--jexcel-border-color);*/
                    }

                    .jexcel .highlight-bottom {
                        border-bottom: 1px solid #000; /* var(--jexcel-border-color);*/
                    }

                    .jexcel .highlight-top.highlight-left {
                        box-shadow: -1px -1px #ccc;
                        -webkit-box-shadow: -1px -1px #ccc;
                        -moz-box-shadow: -1px -1px #ccc;
                    }

                    .jexcel .highlight-selected {
                        background-color: rgba(0,0,0,0.0);
                    }

                    .jexcel .selection {
                        background-color: rgba(0,0,0,0.05);
                    }

                    .jexcel .selection-left {
                        border-left: 1px dotted #000;
                    }

                    .jexcel .selection-right {
                        border-right: 1px dotted #000;
                    }

                    .jexcel .selection-top {
                        border-top: 1px dotted #000;
                    }

                    .jexcel .selection-bottom {
                        border-bottom: 1px dotted #000;
                    }

                .jexcel_corner {
                    position: absolute;
                    background-color: rgb(0, 0, 0);
                    height: 1px;
                    width: 1px;
                    border: 1px solid rgb(255, 255, 255);
                    top: -2000px;
                    left: -2000px;
                    cursor: crosshair;
                    box-sizing: initial;
                    z-index: 7000;
                    padding: 2px;
                }

                .jexcel .editor {
                    outline: 0px solid transparent;
                    overflow: visible;
                    white-space: nowrap;
                    text-align: left;
                    padding: 0px;
                    box-sizing: border-box;
                    overflow: visible !important;
                }

                    .jexcel .editor > input {
                        padding-left: 4px;
                    }

                    .jexcel .editor .jupload {
                        position: fixed;
                        top: 100%;
                        z-index: 8000;
                        user-select: none;
                        -webkit-font-smoothing: antialiased;
                        font-size: .875rem;
                        letter-spacing: .2px;
                        -webkit-border-radius: 4px;
                        border-radius: 4px;
                        -webkit-box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.2);
                        box-shadow: 0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.2);
                        padding: 10px;
                        background-color: #fff;
                        width: 300px;
                        min-height: 225px;
                        margin-top: 2px;
                    }

                        .jexcel .editor .jupload img {
                            width: 100%;
                            height: auto;
                        }

                    .jexcel .editor .jclose:after {
                        position: absolute;
                        top: 0;
                        right: 0;
                        margin: 10px;
                        content: 'close';
                        font-family: 'Material icons';
                        font-size: 24px;
                        width: 24px;
                        height: 24px;
                        line-height: 24px;
                        cursor: pointer;
                        text-shadow: 0px 0px 5px #fff;
                    }

                .jexcel, .jexcel td, .jexcel_corner {
                    -webkit-touch-callout: none;
                    -webkit-user-select: none;
                    -khtml-user-select: none;
                    -moz-user-select: none;
                    -ms-user-select: none;
                    user-select: none;
                    -webkit-user-drag: none;
                    -khtml-user-drag: none;
                    -moz-user-drag: none;
                    -o-user-drag: none;
                    user-drag: none;
                }

                .jexcel_textarea {
                    position: absolute;
                    top: -999px;
                    left: -999px;
                    width: 1px;
                    height: 1px;
                }

                .jexcel .dragline {
                    position: absolute;
                }

                    .jexcel .dragline div {
                        position: relative;
                        top: -6px;
                        height: 5px;
                        width: 22px;
                    }

                        .jexcel .dragline div:hover {
                            cursor: move;
                        }

                .jexcel .onDrag {
                    background-color: rgba(0,0,0,0.6);
                }

                .jexcel .error {
                    border: 1px solid red;
                }

                .jexcel thead td.resizing {
                    border-right-style: dotted !important;
                    border-right-color: red !important;
                }

                .jexcel tbody tr.resizing > td {
                    border-bottom-style: dotted !important;
                    border-bottom-color: red !important;
                }

                .jexcel tbody td.resizing {
                    border-right-style: dotted !important;
                    border-right-color: red !important;
                }

                .jexcel .jdropdown-header {
                    border: 0px !important;
                    outline: none !important;
                    width: 100% !important;
                    height: 100% !important;
                    padding: 0px !important;
                    padding-left: 8px !important;
                }

                .jexcel .jdropdown-container {
                    margin-top: 1px;
                }

                .jexcel .jdropdown-container-header {
                    padding: 0px;
                    margin: 0px;
                    height: inherit;
                }

                .jexcel .jdropdown-picker {
                    border: 0px !important;
                    padding: 0px !important;
                    width: inherit;
                    height: inherit;
                }

                .jexcel .jexcel_comments {
                    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE5LTAxLTMxVDE4OjU1OjA4WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0wMS0zMVQxODo1NTowOFoiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTAxLTMxVDE4OjU1OjA4WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDphMTlhZDJmOC1kMDI2LTI1NDItODhjOS1iZTRkYjkyMmQ0MmQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpkOGI5NDUyMS00ZjEwLWQ5NDktYjUwNC0wZmU1N2I3Nzk1MDEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplMzdjYmE1ZS1hYTMwLWNkNDUtYTAyNS1lOWYxZjk2MzUzOGUiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDplMzdjYmE1ZS1hYTMwLWNkNDUtYTAyNS1lOWYxZjk2MzUzOGUiIHN0RXZ0OndoZW49IjIwMTktMDEtMzFUMTg6NTU6MDhaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmExOWFkMmY4LWQwMjYtMjU0Mi04OGM5LWJlNGRiOTIyZDQyZCIgc3RFdnQ6d2hlbj0iMjAxOS0wMS0zMVQxODo1NTowOFoiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4En6MDAAAAX0lEQVQYlX3KOw6AIBBAwS32RpJADXfx0pTET+ERZJ8F8RODFtONsG0QAoh0CSDM82dqodaBdQXnfoLZQM7gPai+wjNNE8R4pTuAYNZSKZASqL7CMy0LxNgJp30fKYUDi3+vIqb/+rUAAAAASUVORK5CYII=');
                    background-repeat: no-repeat;
                    background-position: top right;
                }

                .jexcel .sp-replacer {
                    margin: 2px;
                    border: 0px;
                }

                .jexcel > thead > tr.jexcel_filter > td > input {
                    border: 0px;
                    width: 100%;
                    outline: none;
                }

                .jexcel_about {
                    text-transform: uppercase;
                    display: none;
                    float: right;
                    font-size: 0.7em;
                    padding: 2px;
                }

                .jexcel_filter {
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                }

                    .jexcel_filter > div {
                        padding: 8px;
                        align-items: center;
                    }

                .jexcel_pagination {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                    .jexcel_pagination > div {
                        display: flex;
                        padding: 10px;
                    }

                        .jexcel_pagination > div:last-child {
                            padding-right: 10px;
                            padding-top: 10px;
                        }

                        .jexcel_pagination > div > div {
                            text-align: center;
                            width: 36px;
                            height: 36px;
                            line-height: 34px;
                            border: 1px solid #ccc;
                            box-sizing: border-box;
                            margin-left: 2px;
                            cursor: pointer;
                        }

                .jexcel_page_selected {
                    font-weight: bold;
                    background-color: #f3f3f3;
                }

                .jexcel_toolbar {
                    display: flex;
                    background-color: #f3f3f3;
                    border: 1px solid #ccc;
                    padding: 4px;
                    margin-bottom: 4px;
                }

                    .jexcel_toolbar:empty {
                        display: none;
                    }

                    .jexcel_toolbar i.jexcel_toolbar_item {
                        width: 24px;
                        height: 24px;
                        padding: 4px;
                        cursor: pointer;
                        display: inline-block;
                    }

                        .jexcel_toolbar i.jexcel_toolbar_item:hover {
                            background-color: #ddd;
                        }

                    .jexcel_toolbar select.jexcel_toolbar_item {
                        margin-left: 2px;
                        margin-right: 2px;
                        display: inline-block;
                        border: 0px;
                        background-color: transparent;
                        padding-right: 10px;
                    }

                .jexcel .dragging-left {
                    background-repeat: no-repeat;
                    background-position: top 50% left 0px;
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M14 7l-5 5 5 5V7z'/%3E%3Cpath fill='none' d='M24 0v24H0V0h24z'/%3E%3C/svg%3E");
                }

                .jexcel .dragging-right {
                    background-repeat: no-repeat;
                    background-position: top 50% right 0px;
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath d='M10 17l5-5-5-5v10z'/%3E%3Cpath fill='none' d='M0 24V0h24v24H0z'/%3E%3C/svg%3E");
                }

                .jexcel_tabs > .jexcel_tab {
                    display: none;
                }

                .jexcel_tabs > .jexcel_tab_link {
                    display: inline-block;
                    padding: 10px;
                    padding-left: 20px;
                    padding-right: 20px;
                    margin-right: 5px;
                    margin-bottom: 5px;
                    background-color: #f3f3f3;
                    cursor: pointer;
                }

                    .jexcel_tabs > .jexcel_tab_link.selected {
                        background-color: #ddd;
                    }

                /*.copying
        {
            border-top:1px solid #ccc !important;
            border-left:1px solid #ccc !important;
            border-right:1px solid #fff !important;
            border-bottom:1px solid #fff !important;
        }

        .copying-top
        {
            border-top:1px solid transparent !important;
        }

        .copying-bottom
        {
            border-bottom:1px solid transparent !important;
        }

        .copying-left
        {
            border-left:1px solid transparent !important;
        }

        .copying-right
        {
            border-right:1px solid transparent !important;
        }

        .copying
        {
            background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, black 0, black 25%, transparent 0, transparent 50%) 0 / .6em .6em !important;
            animation: ants 12s linear infinite;
        }

        @keyframes ants
        {
            to
            {
                background-position: 50% 50%
            }
        }*/
    </style>

    <!-- Lightpick date picker -->
    <script>
        //! moment.js

        ; (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                    global.moment = factory()
        }(this, (function () {
            'use strict';

            var hookCallback;

            function hooks() {
                return hookCallback.apply(null, arguments);
            }

            // This is done to register the method called with moment()
            // without creating circular dependencies.
            function setHookCallback(callback) {
                hookCallback = callback;
            }

            function isArray(input) {
                return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
            }

            function isObject(input) {
                // IE8 will treat undefined and null as object if it wasn't for
                // input != null
                return input != null && Object.prototype.toString.call(input) === '[object Object]';
            }

            function isObjectEmpty(obj) {
                if (Object.getOwnPropertyNames) {
                    return (Object.getOwnPropertyNames(obj).length === 0);
                } else {
                    var k;
                    for (k in obj) {
                        if (obj.hasOwnProperty(k)) {
                            return false;
                        }
                    }
                    return true;
                }
            }

            function isUndefined(input) {
                return input === void 0;
            }

            function isNumber(input) {
                return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
            }

            function isDate(input) {
                return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
            }

            function map(arr, fn) {
                var res = [], i;
                for (i = 0; i < arr.length; ++i) {
                    res.push(fn(arr[i], i));
                }
                return res;
            }

            function hasOwnProp(a, b) {
                return Object.prototype.hasOwnProperty.call(a, b);
            }

            function extend(a, b) {
                for (var i in b) {
                    if (hasOwnProp(b, i)) {
                        a[i] = b[i];
                    }
                }

                if (hasOwnProp(b, 'toString')) {
                    a.toString = b.toString;
                }

                if (hasOwnProp(b, 'valueOf')) {
                    a.valueOf = b.valueOf;
                }

                return a;
            }

            function createUTC(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, true).utc();
            }

            function defaultParsingFlags() {
                // We need to deep clone this object.
                return {
                    empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false,
                    parsedDateParts: [],
                    meridiem: null,
                    rfc2822: false,
                    weekdayMismatch: false
                };
            }

            function getParsingFlags(m) {
                if (m._pf == null) {
                    m._pf = defaultParsingFlags();
                }
                return m._pf;
            }

            var some;
            if (Array.prototype.some) {
                some = Array.prototype.some;
            } else {
                some = function (fun) {
                    var t = Object(this);
                    var len = t.length >>> 0;

                    for (var i = 0; i < len; i++) {
                        if (i in t && fun.call(this, t[i], i, t)) {
                            return true;
                        }
                    }

                    return false;
                };
            }

            function isValid(m) {
                if (m._isValid == null) {
                    var flags = getParsingFlags(m);
                    var parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    });
                    var isNowValid = !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                    if (m._strict) {
                        isNowValid = isNowValid &&
                            flags.charsLeftOver === 0 &&
                            flags.unusedTokens.length === 0 &&
                            flags.bigHour === undefined;
                    }

                    if (Object.isFrozen == null || !Object.isFrozen(m)) {
                        m._isValid = isNowValid;
                    }
                    else {
                        return isNowValid;
                    }
                }
                return m._isValid;
            }

            function createInvalid(flags) {
                var m = createUTC(NaN);
                if (flags != null) {
                    extend(getParsingFlags(m), flags);
                }
                else {
                    getParsingFlags(m).userInvalidated = true;
                }

                return m;
            }

            // Plugins that add properties should also add the key here (null value),
            // so we can properly clone ourselves.
            var momentProperties = hooks.momentProperties = [];

            function copyConfig(to, from) {
                var i, prop, val;

                if (!isUndefined(from._isAMomentObject)) {
                    to._isAMomentObject = from._isAMomentObject;
                }
                if (!isUndefined(from._i)) {
                    to._i = from._i;
                }
                if (!isUndefined(from._f)) {
                    to._f = from._f;
                }
                if (!isUndefined(from._l)) {
                    to._l = from._l;
                }
                if (!isUndefined(from._strict)) {
                    to._strict = from._strict;
                }
                if (!isUndefined(from._tzm)) {
                    to._tzm = from._tzm;
                }
                if (!isUndefined(from._isUTC)) {
                    to._isUTC = from._isUTC;
                }
                if (!isUndefined(from._offset)) {
                    to._offset = from._offset;
                }
                if (!isUndefined(from._pf)) {
                    to._pf = getParsingFlags(from);
                }
                if (!isUndefined(from._locale)) {
                    to._locale = from._locale;
                }

                if (momentProperties.length > 0) {
                    for (i = 0; i < momentProperties.length; i++) {
                        prop = momentProperties[i];
                        val = from[prop];
                        if (!isUndefined(val)) {
                            to[prop] = val;
                        }
                    }
                }

                return to;
            }

            var updateInProgress = false;

            // Moment prototype object
            function Moment(config) {
                copyConfig(this, config);
                this._d = new Date(config._d != null ? config._d.getTime() : NaN);
                if (!this.isValid()) {
                    this._d = new Date(NaN);
                }
                // Prevent infinite loop in case updateOffset creates new moment
                // objects.
                if (updateInProgress === false) {
                    updateInProgress = true;
                    hooks.updateOffset(this);
                    updateInProgress = false;
                }
            }

            function isMoment(obj) {
                return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
            }

            function absFloor(number) {
                if (number < 0) {
                    // -0 -> 0
                    return Math.ceil(number) || 0;
                } else {
                    return Math.floor(number);
                }
            }

            function toInt(argumentForCoercion) {
                var coercedNumber = +argumentForCoercion,
                    value = 0;

                if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                    value = absFloor(coercedNumber);
                }

                return value;
            }

            // compare two arrays, return the number of differences
            function compareArrays(array1, array2, dontConvert) {
                var len = Math.min(array1.length, array2.length),
                    lengthDiff = Math.abs(array1.length - array2.length),
                    diffs = 0,
                    i;
                for (i = 0; i < len; i++) {
                    if ((dontConvert && array1[i] !== array2[i]) ||
                        (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                        diffs++;
                    }
                }
                return diffs + lengthDiff;
            }

            function warn(msg) {
                if (hooks.suppressDeprecationWarnings === false &&
                    (typeof console !== 'undefined') && console.warn) {
                    console.warn('Deprecation warning: ' + msg);
                }
            }

            function deprecate(msg, fn) {
                var firstTime = true;

                return extend(function () {
                    if (hooks.deprecationHandler != null) {
                        hooks.deprecationHandler(null, msg);
                    }
                    if (firstTime) {
                        var args = [];
                        var arg;
                        for (var i = 0; i < arguments.length; i++) {
                            arg = '';
                            if (typeof arguments[i] === 'object') {
                                arg += '\n[' + i + '] ';
                                for (var key in arguments[0]) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                                arg = arg.slice(0, -2); // Remove trailing comma and space
                            } else {
                                arg = arguments[i];
                            }
                            args.push(arg);
                        }
                        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                        firstTime = false;
                    }
                    return fn.apply(this, arguments);
                }, fn);
            }

            var deprecations = {};

            function deprecateSimple(name, msg) {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(name, msg);
                }
                if (!deprecations[name]) {
                    warn(msg);
                    deprecations[name] = true;
                }
            }

            hooks.suppressDeprecationWarnings = false;
            hooks.deprecationHandler = null;

            function isFunction(input) {
                return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
            }

            function set(config) {
                var prop, i;
                for (i in config) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
                this._config = config;
                // Lenient ordinal parsing accepts just a number in addition to
                // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
                // TODO: Remove "ordinalParse" fallback in next major release.
                this._dayOfMonthOrdinalParseLenient = new RegExp(
                    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                    '|' + (/\d{1,2}/).source);
            }

            function mergeConfigs(parentConfig, childConfig) {
                var res = extend({}, parentConfig), prop;
                for (prop in childConfig) {
                    if (hasOwnProp(childConfig, prop)) {
                        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                            res[prop] = {};
                            extend(res[prop], parentConfig[prop]);
                            extend(res[prop], childConfig[prop]);
                        } else if (childConfig[prop] != null) {
                            res[prop] = childConfig[prop];
                        } else {
                            delete res[prop];
                        }
                    }
                }
                for (prop in parentConfig) {
                    if (hasOwnProp(parentConfig, prop) &&
                        !hasOwnProp(childConfig, prop) &&
                        isObject(parentConfig[prop])) {
                        // make sure changes to properties don't modify parent config
                        res[prop] = extend({}, res[prop]);
                    }
                }
                return res;
            }

            function Locale(config) {
                if (config != null) {
                    this.set(config);
                }
            }

            var keys;

            if (Object.keys) {
                keys = Object.keys;
            } else {
                keys = function (obj) {
                    var i, res = [];
                    for (i in obj) {
                        if (hasOwnProp(obj, i)) {
                            res.push(i);
                        }
                    }
                    return res;
                };
            }

            var defaultCalendar = {
                sameDay: '[Today at] LT',
                nextDay: '[Tomorrow at] LT',
                nextWeek: 'dddd [at] LT',
                lastDay: '[Yesterday at] LT',
                lastWeek: '[Last] dddd [at] LT',
                sameElse: 'L'
            };

            function calendar(key, mom, now) {
                var output = this._calendar[key] || this._calendar['sameElse'];
                return isFunction(output) ? output.call(mom, now) : output;
            }

            var defaultLongDateFormat = {
                LTS: 'h:mm:ss A',
                LT: 'h:mm A',
                L: 'MM/DD/YYYY',
                LL: 'MMMM D, YYYY',
                LLL: 'MMMM D, YYYY h:mm A',
                LLLL: 'dddd, MMMM D, YYYY h:mm A'
            };

            function longDateFormat(key) {
                var format = this._longDateFormat[key],
                    formatUpper = this._longDateFormat[key.toUpperCase()];

                if (format || !formatUpper) {
                    return format;
                }

                this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });

                return this._longDateFormat[key];
            }

            var defaultInvalidDate = 'Invalid date';

            function invalidDate() {
                return this._invalidDate;
            }

            var defaultOrdinal = '%d';
            var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

            function ordinal(number) {
                return this._ordinal.replace('%d', number);
            }

            var defaultRelativeTime = {
                future: 'in %s',
                past: '%s ago',
                s: 'a few seconds',
                ss: '%d seconds',
                m: 'a minute',
                mm: '%d minutes',
                h: 'an hour',
                hh: '%d hours',
                d: 'a day',
                dd: '%d days',
                M: 'a month',
                MM: '%d months',
                y: 'a year',
                yy: '%d years'
            };

            function relativeTime(number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return (isFunction(output)) ?
                    output(number, withoutSuffix, string, isFuture) :
                    output.replace(/%d/i, number);
            }

            function pastFuture(diff, output) {
                var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
                return isFunction(format) ? format(output) : format.replace(/%s/i, output);
            }

            var aliases = {};

            function addUnitAlias(unit, shorthand) {
                var lowerCase = unit.toLowerCase();
                aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
            }

            function normalizeUnits(units) {
                return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
            }

            function normalizeObjectUnits(inputObject) {
                var normalizedInput = {},
                    normalizedProp,
                    prop;

                for (prop in inputObject) {
                    if (hasOwnProp(inputObject, prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) {
                            normalizedInput[normalizedProp] = inputObject[prop];
                        }
                    }
                }

                return normalizedInput;
            }

            var priorities = {};

            function addUnitPriority(unit, priority) {
                priorities[unit] = priority;
            }

            function getPrioritizedUnits(unitsObj) {
                var units = [];
                for (var u in unitsObj) {
                    units.push({ unit: u, priority: priorities[u] });
                }
                units.sort(function (a, b) {
                    return a.priority - b.priority;
                });
                return units;
            }

            function zeroFill(number, targetLength, forceSign) {
                var absNumber = '' + Math.abs(number),
                    zerosToFill = targetLength - absNumber.length,
                    sign = number >= 0;
                return (sign ? (forceSign ? '+' : '') : '-') +
                    Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
            }

            var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

            var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

            var formatFunctions = {};

            var formatTokenFunctions = {};

            // token:    'M'
            // padded:   ['MM', 2]
            // ordinal:  'Mo'
            // callback: function () { this.month() + 1 }
            function addFormatToken(token, padded, ordinal, callback) {
                var func = callback;
                if (typeof callback === 'string') {
                    func = function () {
                        return this[callback]();
                    };
                }
                if (token) {
                    formatTokenFunctions[token] = func;
                }
                if (padded) {
                    formatTokenFunctions[padded[0]] = function () {
                        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                }
                if (ordinal) {
                    formatTokenFunctions[ordinal] = function () {
                        return this.localeData().ordinal(func.apply(this, arguments), token);
                    };
                }
            }

            function removeFormattingTokens(input) {
                if (input.match(/\[[\s\S]/)) {
                    return input.replace(/^\[|\]$/g, '');
                }
                return input.replace(/\\/g, '');
            }

            function makeFormatFunction(format) {
                var array = format.match(formattingTokens), i, length;

                for (i = 0, length = array.length; i < length; i++) {
                    if (formatTokenFunctions[array[i]]) {
                        array[i] = formatTokenFunctions[array[i]];
                    } else {
                        array[i] = removeFormattingTokens(array[i]);
                    }
                }

                return function (mom) {
                    var output = '', i;
                    for (i = 0; i < length; i++) {
                        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                    }
                    return output;
                };
            }

            // format date using native date object
            function formatMoment(m, format) {
                if (!m.isValid()) {
                    return m.localeData().invalidDate();
                }

                format = expandFormat(format, m.localeData());
                formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

                return formatFunctions[format](m);
            }

            function expandFormat(format, locale) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return locale.longDateFormat(input) || input;
                }

                localFormattingTokens.lastIndex = 0;
                while (i >= 0 && localFormattingTokens.test(format)) {
                    format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                    localFormattingTokens.lastIndex = 0;
                    i -= 1;
                }

                return format;
            }

            var match1 = /\d/;            //       0 - 9
            var match2 = /\d\d/;          //      00 - 99
            var match3 = /\d{3}/;         //     000 - 999
            var match4 = /\d{4}/;         //    0000 - 9999
            var match6 = /[+-]?\d{6}/;    // -999999 - 999999
            var match1to2 = /\d\d?/;         //       0 - 99
            var match3to4 = /\d\d\d\d?/;     //     999 - 9999
            var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
            var match1to3 = /\d{1,3}/;       //       0 - 999
            var match1to4 = /\d{1,4}/;       //       0 - 9999
            var match1to6 = /[+-]?\d{1,6}/;  // -999999 - 999999

            var matchUnsigned = /\d+/;           //       0 - inf
            var matchSigned = /[+-]?\d+/;      //    -inf - inf

            var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
            var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

            var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

            var regexes = {};

            function addRegexToken(token, regex, strictRegex) {
                regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
                    return (isStrict && strictRegex) ? strictRegex : regex;
                };
            }

            function getParseRegexForToken(token, config) {
                if (!hasOwnProp(regexes, token)) {
                    return new RegExp(unescapeFormat(token));
                }

                return regexes[token](config._strict, config._locale);
            }

            // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
            function unescapeFormat(s) {
                return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4;
                }));
            }

            function regexEscape(s) {
                return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            }

            var tokens = {};

            function addParseToken(token, callback) {
                var i, func = callback;
                if (typeof token === 'string') {
                    token = [token];
                }
                if (isNumber(callback)) {
                    func = function (input, array) {
                        array[callback] = toInt(input);
                    };
                }
                for (i = 0; i < token.length; i++) {
                    tokens[token[i]] = func;
                }
            }

            function addWeekParseToken(token, callback) {
                addParseToken(token, function (input, array, config, token) {
                    config._w = config._w || {};
                    callback(input, config._w, config, token);
                });
            }

            function addTimeToArrayFromToken(token, input, config) {
                if (input != null && hasOwnProp(tokens, token)) {
                    tokens[token](input, config._a, config, token);
                }
            }

            var YEAR = 0;
            var MONTH = 1;
            var DATE = 2;
            var HOUR = 3;
            var MINUTE = 4;
            var SECOND = 5;
            var MILLISECOND = 6;
            var WEEK = 7;
            var WEEKDAY = 8;

            // FORMATTING

            addFormatToken('Y', 0, 0, function () {
                var y = this.year();
                return y <= 9999 ? '' + y : '+' + y;
            });

            addFormatToken(0, ['YY', 2], 0, function () {
                return this.year() % 100;
            });

            addFormatToken(0, ['YYYY', 4], 0, 'year');
            addFormatToken(0, ['YYYYY', 5], 0, 'year');
            addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

            // ALIASES

            addUnitAlias('year', 'y');

            // PRIORITIES

            addUnitPriority('year', 1);

            // PARSING

            addRegexToken('Y', matchSigned);
            addRegexToken('YY', match1to2, match2);
            addRegexToken('YYYY', match1to4, match4);
            addRegexToken('YYYYY', match1to6, match6);
            addRegexToken('YYYYYY', match1to6, match6);

            addParseToken(['YYYYY', 'YYYYYY'], YEAR);
            addParseToken('YYYY', function (input, array) {
                array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
            });
            addParseToken('YY', function (input, array) {
                array[YEAR] = hooks.parseTwoDigitYear(input);
            });
            addParseToken('Y', function (input, array) {
                array[YEAR] = parseInt(input, 10);
            });

            // HELPERS

            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365;
            }

            function isLeapYear(year) {
                return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
            }

            // HOOKS

            hooks.parseTwoDigitYear = function (input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
            };

            // MOMENTS

            var getSetYear = makeGetSet('FullYear', true);

            function getIsLeapYear() {
                return isLeapYear(this.year());
            }

            function makeGetSet(unit, keepTime) {
                return function (value) {
                    if (value != null) {
                        set$1(this, unit, value);
                        hooks.updateOffset(this, keepTime);
                        return this;
                    } else {
                        return get(this, unit);
                    }
                };
            }

            function get(mom, unit) {
                return mom.isValid() ?
                    mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
            }

            function set$1(mom, unit, value) {
                if (mom.isValid() && !isNaN(value)) {
                    if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
                    }
                    else {
                        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                    }
                }
            }

            // MOMENTS

            function stringGet(units) {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units]();
                }
                return this;
            }


            function stringSet(units, value) {
                if (typeof units === 'object') {
                    units = normalizeObjectUnits(units);
                    var prioritized = getPrioritizedUnits(units);
                    for (var i = 0; i < prioritized.length; i++) {
                        this[prioritized[i].unit](units[prioritized[i].unit]);
                    }
                } else {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) {
                        return this[units](value);
                    }
                }
                return this;
            }

            function mod(n, x) {
                return ((n % x) + x) % x;
            }

            var indexOf;

            if (Array.prototype.indexOf) {
                indexOf = Array.prototype.indexOf;
            } else {
                indexOf = function (o) {
                    // I know
                    var i;
                    for (i = 0; i < this.length; ++i) {
                        if (this[i] === o) {
                            return i;
                        }
                    }
                    return -1;
                };
            }

            function daysInMonth(year, month) {
                if (isNaN(year) || isNaN(month)) {
                    return NaN;
                }
                var modMonth = mod(month, 12);
                year += (month - modMonth) / 12;
                return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
            }

            // FORMATTING

            addFormatToken('M', ['MM', 2], 'Mo', function () {
                return this.month() + 1;
            });

            addFormatToken('MMM', 0, 0, function (format) {
                return this.localeData().monthsShort(this, format);
            });

            addFormatToken('MMMM', 0, 0, function (format) {
                return this.localeData().months(this, format);
            });

            // ALIASES

            addUnitAlias('month', 'M');

            // PRIORITY

            addUnitPriority('month', 8);

            // PARSING

            addRegexToken('M', match1to2);
            addRegexToken('MM', match1to2, match2);
            addRegexToken('MMM', function (isStrict, locale) {
                return locale.monthsShortRegex(isStrict);
            });
            addRegexToken('MMMM', function (isStrict, locale) {
                return locale.monthsRegex(isStrict);
            });

            addParseToken(['M', 'MM'], function (input, array) {
                array[MONTH] = toInt(input) - 1;
            });

            addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
                var month = config._locale.monthsParse(input, token, config._strict);
                // if we didn't find a month name, mark the date as invalid.
                if (month != null) {
                    array[MONTH] = month;
                } else {
                    getParsingFlags(config).invalidMonth = input;
                }
            });

            // LOCALES

            var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
            var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
            function localeMonths(m, format) {
                if (!m) {
                    return isArray(this._months) ? this._months :
                        this._months['standalone'];
                }
                return isArray(this._months) ? this._months[m.month()] :
                    this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
            }

            var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
            function localeMonthsShort(m, format) {
                if (!m) {
                    return isArray(this._monthsShort) ? this._monthsShort :
                        this._monthsShort['standalone'];
                }
                return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
                    this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
            }

            function handleStrictParse(monthName, format, strict) {
                var i, ii, mom, llc = monthName.toLocaleLowerCase();
                if (!this._monthsParse) {
                    // this is not used
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                    for (i = 0; i < 12; ++i) {
                        mom = createUTC([2000, i]);
                        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                    }
                }

                if (strict) {
                    if (format === 'MMM') {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format === 'MMM') {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }

            function localeMonthsParse(monthName, format, strict) {
                var i, mom, regex;

                if (this._monthsParseExact) {
                    return handleStrictParse.call(this, monthName, format, strict);
                }

                if (!this._monthsParse) {
                    this._monthsParse = [];
                    this._longMonthsParse = [];
                    this._shortMonthsParse = [];
                }

                // TODO: add sorting
                // Sorting makes sure if one month (or abbr) is a prefix of another
                // see sorting in computeMonthsParse
                for (i = 0; i < 12; i++) {
                    // make the regex if we don't have it already
                    mom = createUTC([2000, i]);
                    if (strict && !this._longMonthsParse[i]) {
                        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                    }
                    if (!strict && !this._monthsParse[i]) {
                        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                    }
                    // test the regex
                    if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                        return i;
                    } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                        return i;
                    } else if (!strict && this._monthsParse[i].test(monthName)) {
                        return i;
                    }
                }
            }

            // MOMENTS

            function setMonth(mom, value) {
                var dayOfMonth;

                if (!mom.isValid()) {
                    // No op
                    return mom;
                }

                if (typeof value === 'string') {
                    if (/^\d+$/.test(value)) {
                        value = toInt(value);
                    } else {
                        value = mom.localeData().monthsParse(value);
                        // TODO: Another silent failure?
                        if (!isNumber(value)) {
                            return mom;
                        }
                    }
                }

                dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
                return mom;
            }

            function getSetMonth(value) {
                if (value != null) {
                    setMonth(this, value);
                    hooks.updateOffset(this, true);
                    return this;
                } else {
                    return get(this, 'Month');
                }
            }

            function getDaysInMonth() {
                return daysInMonth(this.year(), this.month());
            }

            var defaultMonthsShortRegex = matchWord;
            function monthsShortRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsShortStrictRegex;
                    } else {
                        return this._monthsShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_monthsShortRegex')) {
                        this._monthsShortRegex = defaultMonthsShortRegex;
                    }
                    return this._monthsShortStrictRegex && isStrict ?
                        this._monthsShortStrictRegex : this._monthsShortRegex;
                }
            }

            var defaultMonthsRegex = matchWord;
            function monthsRegex(isStrict) {
                if (this._monthsParseExact) {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        computeMonthsParse.call(this);
                    }
                    if (isStrict) {
                        return this._monthsStrictRegex;
                    } else {
                        return this._monthsRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_monthsRegex')) {
                        this._monthsRegex = defaultMonthsRegex;
                    }
                    return this._monthsStrictRegex && isStrict ?
                        this._monthsStrictRegex : this._monthsRegex;
                }
            }

            function computeMonthsParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length;
                }

                var shortPieces = [], longPieces = [], mixedPieces = [],
                    i, mom;
                for (i = 0; i < 12; i++) {
                    // make the regex if we don't have it already
                    mom = createUTC([2000, i]);
                    shortPieces.push(this.monthsShort(mom, ''));
                    longPieces.push(this.months(mom, ''));
                    mixedPieces.push(this.months(mom, ''));
                    mixedPieces.push(this.monthsShort(mom, ''));
                }
                // Sorting makes sure if one month (or abbr) is a prefix of another it
                // will match the longer piece.
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                for (i = 0; i < 12; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                }
                for (i = 0; i < 24; i++) {
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                }

                this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                this._monthsShortRegex = this._monthsRegex;
                this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
            }

            function createDate(y, m, d, h, M, s, ms) {
                // can't just apply() to create a date:
                // https://stackoverflow.com/q/181348
                var date = new Date(y, m, d, h, M, s, ms);

                // the date constructor remaps years 0-99 to 1900-1999
                if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
                return date;
            }

            function createUTCDate(y) {
                var date = new Date(Date.UTC.apply(null, arguments));

                // the Date.UTC function remaps years 0-99 to 1900-1999
                if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
                return date;
            }

            // start-of-first-week - start-of-year
            function firstWeekOffset(year, dow, doy) {
                var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                    fwd = 7 + dow - doy,
                    // first-week day local weekday -- which local weekday is fwd
                    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

                return -fwdlw + fwd - 1;
            }

            // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
            function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                var localWeekday = (7 + weekday - dow) % 7,
                    weekOffset = firstWeekOffset(year, dow, doy),
                    dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                    resYear, resDayOfYear;

                if (dayOfYear <= 0) {
                    resYear = year - 1;
                    resDayOfYear = daysInYear(resYear) + dayOfYear;
                } else if (dayOfYear > daysInYear(year)) {
                    resYear = year + 1;
                    resDayOfYear = dayOfYear - daysInYear(year);
                } else {
                    resYear = year;
                    resDayOfYear = dayOfYear;
                }

                return {
                    year: resYear,
                    dayOfYear: resDayOfYear
                };
            }

            function weekOfYear(mom, dow, doy) {
                var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                    week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                    resWeek, resYear;

                if (week < 1) {
                    resYear = mom.year() - 1;
                    resWeek = week + weeksInYear(resYear, dow, doy);
                } else if (week > weeksInYear(mom.year(), dow, doy)) {
                    resWeek = week - weeksInYear(mom.year(), dow, doy);
                    resYear = mom.year() + 1;
                } else {
                    resYear = mom.year();
                    resWeek = week;
                }

                return {
                    week: resWeek,
                    year: resYear
                };
            }

            function weeksInYear(year, dow, doy) {
                var weekOffset = firstWeekOffset(year, dow, doy),
                    weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
            }

            // FORMATTING

            addFormatToken('w', ['ww', 2], 'wo', 'week');
            addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

            // ALIASES

            addUnitAlias('week', 'w');
            addUnitAlias('isoWeek', 'W');

            // PRIORITIES

            addUnitPriority('week', 5);
            addUnitPriority('isoWeek', 5);

            // PARSING

            addRegexToken('w', match1to2);
            addRegexToken('ww', match1to2, match2);
            addRegexToken('W', match1to2);
            addRegexToken('WW', match1to2, match2);

            addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
                week[token.substr(0, 1)] = toInt(input);
            });

            // HELPERS

            // LOCALES

            function localeWeek(mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week;
            }

            var defaultLocaleWeek = {
                dow: 0, // Sunday is the first day of the week.
                doy: 6  // The week that contains Jan 1st is the first week of the year.
            };

            function localeFirstDayOfWeek() {
                return this._week.dow;
            }

            function localeFirstDayOfYear() {
                return this._week.doy;
            }

            // MOMENTS

            function getSetWeek(input) {
                var week = this.localeData().week(this);
                return input == null ? week : this.add((input - week) * 7, 'd');
            }

            function getSetISOWeek(input) {
                var week = weekOfYear(this, 1, 4).week;
                return input == null ? week : this.add((input - week) * 7, 'd');
            }

            // FORMATTING

            addFormatToken('d', 0, 'do', 'day');

            addFormatToken('dd', 0, 0, function (format) {
                return this.localeData().weekdaysMin(this, format);
            });

            addFormatToken('ddd', 0, 0, function (format) {
                return this.localeData().weekdaysShort(this, format);
            });

            addFormatToken('dddd', 0, 0, function (format) {
                return this.localeData().weekdays(this, format);
            });

            addFormatToken('e', 0, 0, 'weekday');
            addFormatToken('E', 0, 0, 'isoWeekday');

            // ALIASES

            addUnitAlias('day', 'd');
            addUnitAlias('weekday', 'e');
            addUnitAlias('isoWeekday', 'E');

            // PRIORITY
            addUnitPriority('day', 11);
            addUnitPriority('weekday', 11);
            addUnitPriority('isoWeekday', 11);

            // PARSING

            addRegexToken('d', match1to2);
            addRegexToken('e', match1to2);
            addRegexToken('E', match1to2);
            addRegexToken('dd', function (isStrict, locale) {
                return locale.weekdaysMinRegex(isStrict);
            });
            addRegexToken('ddd', function (isStrict, locale) {
                return locale.weekdaysShortRegex(isStrict);
            });
            addRegexToken('dddd', function (isStrict, locale) {
                return locale.weekdaysRegex(isStrict);
            });

            addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
                var weekday = config._locale.weekdaysParse(input, token, config._strict);
                // if we didn't get a weekday name, mark the date as invalid
                if (weekday != null) {
                    week.d = weekday;
                } else {
                    getParsingFlags(config).invalidWeekday = input;
                }
            });

            addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
                week[token] = toInt(input);
            });

            // HELPERS

            function parseWeekday(input, locale) {
                if (typeof input !== 'string') {
                    return input;
                }

                if (!isNaN(input)) {
                    return parseInt(input, 10);
                }

                input = locale.weekdaysParse(input);
                if (typeof input === 'number') {
                    return input;
                }

                return null;
            }

            function parseIsoWeekday(input, locale) {
                if (typeof input === 'string') {
                    return locale.weekdaysParse(input) % 7 || 7;
                }
                return isNaN(input) ? null : input;
            }

            // LOCALES

            var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
            function localeWeekdays(m, format) {
                if (!m) {
                    return isArray(this._weekdays) ? this._weekdays :
                        this._weekdays['standalone'];
                }
                return isArray(this._weekdays) ? this._weekdays[m.day()] :
                    this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
            }

            var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
            function localeWeekdaysShort(m) {
                return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
            }

            var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
            function localeWeekdaysMin(m) {
                return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
            }

            function handleStrictParse$1(weekdayName, format, strict) {
                var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._minWeekdaysParse = [];

                    for (i = 0; i < 7; ++i) {
                        mom = createUTC([2000, 1]).day(i);
                        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                    }
                }

                if (strict) {
                    if (format === 'dddd') {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format === 'ddd') {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                } else {
                    if (format === 'dddd') {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else if (format === 'ddd') {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (ii !== -1) {
                            return ii;
                        }
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return ii !== -1 ? ii : null;
                    }
                }
            }

            function localeWeekdaysParse(weekdayName, format, strict) {
                var i, mom, regex;

                if (this._weekdaysParseExact) {
                    return handleStrictParse$1.call(this, weekdayName, format, strict);
                }

                if (!this._weekdaysParse) {
                    this._weekdaysParse = [];
                    this._minWeekdaysParse = [];
                    this._shortWeekdaysParse = [];
                    this._fullWeekdaysParse = [];
                }

                for (i = 0; i < 7; i++) {
                    // make the regex if we don't have it already

                    mom = createUTC([2000, 1]).day(i);
                    if (strict && !this._fullWeekdaysParse[i]) {
                        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
                    }
                    if (!this._weekdaysParse[i]) {
                        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                    }
                    // test the regex
                    if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                        return i;
                    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                        return i;
                    }
                }
            }

            // MOMENTS

            function getSetDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                if (input != null) {
                    input = parseWeekday(input, this.localeData());
                    return this.add(input - day, 'd');
                } else {
                    return day;
                }
            }

            function getSetLocaleDayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return input == null ? weekday : this.add(input - weekday, 'd');
            }

            function getSetISODayOfWeek(input) {
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }

                // behaves the same as moment#day except
                // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
                // as a setter, sunday should belong to the previous week.

                if (input != null) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7);
                } else {
                    return this.day() || 7;
                }
            }

            var defaultWeekdaysRegex = matchWord;
            function weekdaysRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysStrictRegex;
                    } else {
                        return this._weekdaysRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        this._weekdaysRegex = defaultWeekdaysRegex;
                    }
                    return this._weekdaysStrictRegex && isStrict ?
                        this._weekdaysStrictRegex : this._weekdaysRegex;
                }
            }

            var defaultWeekdaysShortRegex = matchWord;
            function weekdaysShortRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysShortStrictRegex;
                    } else {
                        return this._weekdaysShortRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                    }
                    return this._weekdaysShortStrictRegex && isStrict ?
                        this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                }
            }

            var defaultWeekdaysMinRegex = matchWord;
            function weekdaysMinRegex(isStrict) {
                if (this._weekdaysParseExact) {
                    if (!hasOwnProp(this, '_weekdaysRegex')) {
                        computeWeekdaysParse.call(this);
                    }
                    if (isStrict) {
                        return this._weekdaysMinStrictRegex;
                    } else {
                        return this._weekdaysMinRegex;
                    }
                } else {
                    if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                    }
                    return this._weekdaysMinStrictRegex && isStrict ?
                        this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                }
            }


            function computeWeekdaysParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length;
                }

                var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
                    i, mom, minp, shortp, longp;
                for (i = 0; i < 7; i++) {
                    // make the regex if we don't have it already
                    mom = createUTC([2000, 1]).day(i);
                    minp = this.weekdaysMin(mom, '');
                    shortp = this.weekdaysShort(mom, '');
                    longp = this.weekdays(mom, '');
                    minPieces.push(minp);
                    shortPieces.push(shortp);
                    longPieces.push(longp);
                    mixedPieces.push(minp);
                    mixedPieces.push(shortp);
                    mixedPieces.push(longp);
                }
                // Sorting makes sure if one weekday (or abbr) is a prefix of another it
                // will match the longer piece.
                minPieces.sort(cmpLenRev);
                shortPieces.sort(cmpLenRev);
                longPieces.sort(cmpLenRev);
                mixedPieces.sort(cmpLenRev);
                for (i = 0; i < 7; i++) {
                    shortPieces[i] = regexEscape(shortPieces[i]);
                    longPieces[i] = regexEscape(longPieces[i]);
                    mixedPieces[i] = regexEscape(mixedPieces[i]);
                }

                this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
                this._weekdaysShortRegex = this._weekdaysRegex;
                this._weekdaysMinRegex = this._weekdaysRegex;

                this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
                this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
                this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
            }

            // FORMATTING

            function hFormat() {
                return this.hours() % 12 || 12;
            }

            function kFormat() {
                return this.hours() || 24;
            }

            addFormatToken('H', ['HH', 2], 0, 'hour');
            addFormatToken('h', ['hh', 2], 0, hFormat);
            addFormatToken('k', ['kk', 2], 0, kFormat);

            addFormatToken('hmm', 0, 0, function () {
                return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
            });

            addFormatToken('hmmss', 0, 0, function () {
                return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
                    zeroFill(this.seconds(), 2);
            });

            addFormatToken('Hmm', 0, 0, function () {
                return '' + this.hours() + zeroFill(this.minutes(), 2);
            });

            addFormatToken('Hmmss', 0, 0, function () {
                return '' + this.hours() + zeroFill(this.minutes(), 2) +
                    zeroFill(this.seconds(), 2);
            });

            function meridiem(token, lowercase) {
                addFormatToken(token, 0, 0, function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                });
            }

            meridiem('a', true);
            meridiem('A', false);

            // ALIASES

            addUnitAlias('hour', 'h');

            // PRIORITY
            addUnitPriority('hour', 13);

            // PARSING

            function matchMeridiem(isStrict, locale) {
                return locale._meridiemParse;
            }

            addRegexToken('a', matchMeridiem);
            addRegexToken('A', matchMeridiem);
            addRegexToken('H', match1to2);
            addRegexToken('h', match1to2);
            addRegexToken('k', match1to2);
            addRegexToken('HH', match1to2, match2);
            addRegexToken('hh', match1to2, match2);
            addRegexToken('kk', match1to2, match2);

            addRegexToken('hmm', match3to4);
            addRegexToken('hmmss', match5to6);
            addRegexToken('Hmm', match3to4);
            addRegexToken('Hmmss', match5to6);

            addParseToken(['H', 'HH'], HOUR);
            addParseToken(['k', 'kk'], function (input, array, config) {
                var kInput = toInt(input);
                array[HOUR] = kInput === 24 ? 0 : kInput;
            });
            addParseToken(['a', 'A'], function (input, array, config) {
                config._isPm = config._locale.isPM(input);
                config._meridiem = input;
            });
            addParseToken(['h', 'hh'], function (input, array, config) {
                array[HOUR] = toInt(input);
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('hmm', function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('hmmss', function (input, array, config) {
                var pos1 = input.length - 4;
                var pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
                getParsingFlags(config).bigHour = true;
            });
            addParseToken('Hmm', function (input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos));
                array[MINUTE] = toInt(input.substr(pos));
            });
            addParseToken('Hmmss', function (input, array, config) {
                var pos1 = input.length - 4;
                var pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1));
                array[MINUTE] = toInt(input.substr(pos1, 2));
                array[SECOND] = toInt(input.substr(pos2));
            });

            // LOCALES

            function localeIsPM(input) {
                // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
                // Using charAt should be more compatible.
                return ((input + '').toLowerCase().charAt(0) === 'p');
            }

            var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
            function localeMeridiem(hours, minutes, isLower) {
                if (hours > 11) {
                    return isLower ? 'pm' : 'PM';
                } else {
                    return isLower ? 'am' : 'AM';
                }
            }


            // MOMENTS

            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            var getSetHour = makeGetSet('Hours', true);

            var baseConfig = {
                calendar: defaultCalendar,
                longDateFormat: defaultLongDateFormat,
                invalidDate: defaultInvalidDate,
                ordinal: defaultOrdinal,
                dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                relativeTime: defaultRelativeTime,

                months: defaultLocaleMonths,
                monthsShort: defaultLocaleMonthsShort,

                week: defaultLocaleWeek,

                weekdays: defaultLocaleWeekdays,
                weekdaysMin: defaultLocaleWeekdaysMin,
                weekdaysShort: defaultLocaleWeekdaysShort,

                meridiemParse: defaultLocaleMeridiemParse
            };

            // internal storage for locale config files
            var locales = {};
            var localeFamilies = {};
            var globalLocale;

            function normalizeLocale(key) {
                return key ? key.toLowerCase().replace('_', '-') : key;
            }

            // pick the locale from the array
            // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
            // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
            function chooseLocale(names) {
                var i = 0, j, next, locale, split;

                while (i < names.length) {
                    split = normalizeLocale(names[i]).split('-');
                    j = split.length;
                    next = normalizeLocale(names[i + 1]);
                    next = next ? next.split('-') : null;
                    while (j > 0) {
                        locale = loadLocale(split.slice(0, j).join('-'));
                        if (locale) {
                            return locale;
                        }
                        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                            //the next array item is better than a shallower substring of this one
                            break;
                        }
                        j--;
                    }
                    i++;
                }
                return globalLocale;
            }

            function loadLocale(name) {
                var oldLocale = null;
                // TODO: Find a better way to register and load all the locales in Node
                if (!locales[name] && (typeof module !== 'undefined') &&
                    module && module.exports) {
                    try {
                        oldLocale = globalLocale._abbr;
                        var aliasedRequire = require;
                        aliasedRequire('./locale/' + name);
                        getSetGlobalLocale(oldLocale);
                    } catch (e) { }
                }
                return locales[name];
            }

            // This function will load locale and then set the global locale.  If
            // no arguments are passed in, it will simply return the current global
            // locale key.
            function getSetGlobalLocale(key, values) {
                var data;
                if (key) {
                    if (isUndefined(values)) {
                        data = getLocale(key);
                    }
                    else {
                        data = defineLocale(key, values);
                    }

                    if (data) {
                        // moment.duration._locale = moment._locale = data;
                        globalLocale = data;
                    }
                    else {
                        if ((typeof console !== 'undefined') && console.warn) {
                            //warn user if arguments are passed but the locale could not be set
                            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                        }
                    }
                }

                return globalLocale._abbr;
            }

            function defineLocale(name, config) {
                if (config !== null) {
                    var locale, parentConfig = baseConfig;
                    config.abbr = name;
                    if (locales[name] != null) {
                        deprecateSimple('defineLocaleOverride',
                            'use moment.updateLocale(localeName, config) to change ' +
                            'an existing locale. moment.defineLocale(localeName, ' +
                            'config) should only be used for creating a new locale ' +
                            'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                        parentConfig = locales[name]._config;
                    } else if (config.parentLocale != null) {
                        if (locales[config.parentLocale] != null) {
                            parentConfig = locales[config.parentLocale]._config;
                        } else {
                            locale = loadLocale(config.parentLocale);
                            if (locale != null) {
                                parentConfig = locale._config;
                            } else {
                                if (!localeFamilies[config.parentLocale]) {
                                    localeFamilies[config.parentLocale] = [];
                                }
                                localeFamilies[config.parentLocale].push({
                                    name: name,
                                    config: config
                                });
                                return null;
                            }
                        }
                    }
                    locales[name] = new Locale(mergeConfigs(parentConfig, config));

                    if (localeFamilies[name]) {
                        localeFamilies[name].forEach(function (x) {
                            defineLocale(x.name, x.config);
                        });
                    }

                    // backwards compat for now: also set the locale
                    // make sure we set the locale AFTER all child locales have been
                    // created, so we won't end up with the child locale set.
                    getSetGlobalLocale(name);


                    return locales[name];
                } else {
                    // useful for testing
                    delete locales[name];
                    return null;
                }
            }

            function updateLocale(name, config) {
                if (config != null) {
                    var locale, tmpLocale, parentConfig = baseConfig;
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;

                    // backwards compat for now: also set the locale
                    getSetGlobalLocale(name);
                } else {
                    // pass null for config to unupdate, useful for tests
                    if (locales[name] != null) {
                        if (locales[name].parentLocale != null) {
                            locales[name] = locales[name].parentLocale;
                        } else if (locales[name] != null) {
                            delete locales[name];
                        }
                    }
                }
                return locales[name];
            }

            // returns locale data
            function getLocale(key) {
                var locale;

                if (key && key._locale && key._locale._abbr) {
                    key = key._locale._abbr;
                }

                if (!key) {
                    return globalLocale;
                }

                if (!isArray(key)) {
                    //short-circuit everything else
                    locale = loadLocale(key);
                    if (locale) {
                        return locale;
                    }
                    key = [key];
                }

                return chooseLocale(key);
            }

            function listLocales() {
                return keys(locales);
            }

            function checkOverflow(m) {
                var overflow;
                var a = m._a;

                if (a && getParsingFlags(m).overflow === -2) {
                    overflow =
                        a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                            a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                                a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                                    a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                                        a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                                            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                                                -1;

                    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                        overflow = DATE;
                    }
                    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                        overflow = WEEK;
                    }
                    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                        overflow = WEEKDAY;
                    }

                    getParsingFlags(m).overflow = overflow;
                }

                return m;
            }

            // Pick the first defined of two or three arguments.
            function defaults(a, b, c) {
                if (a != null) {
                    return a;
                }
                if (b != null) {
                    return b;
                }
                return c;
            }

            function currentDateArray(config) {
                // hooks is actually the exported moment object
                var nowValue = new Date(hooks.now());
                if (config._useUTC) {
                    return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
                }
                return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
            }

            // convert an array to a date.
            // the array should mirror the parameters below
            // note: all values past the year are optional and will default to the lowest possible value.
            // [year, month, day , hour, minute, second, millisecond]
            function configFromArray(config) {
                var i, date, input = [], currentDate, expectedWeekday, yearToUse;

                if (config._d) {
                    return;
                }

                currentDate = currentDateArray(config);

                //compute day of the year from weeks and weekdays
                if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                    dayOfYearFromWeekInfo(config);
                }

                //if the day of the year is set, figure out what it is
                if (config._dayOfYear != null) {
                    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                        getParsingFlags(config)._overflowDayOfYear = true;
                    }

                    date = createUTCDate(yearToUse, 0, config._dayOfYear);
                    config._a[MONTH] = date.getUTCMonth();
                    config._a[DATE] = date.getUTCDate();
                }

                // Default to current date.
                // * if no year, month, day of month are given, default to today
                // * if day of month is given, default month and year
                // * if month is given, default only year
                // * if year is given, don't default anything
                for (i = 0; i < 3 && config._a[i] == null; ++i) {
                    config._a[i] = input[i] = currentDate[i];
                }

                // Zero out whatever was not defaulted, including time
                for (; i < 7; i++) {
                    config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
                }

                // Check for 24:00:00.000
                if (config._a[HOUR] === 24 &&
                    config._a[MINUTE] === 0 &&
                    config._a[SECOND] === 0 &&
                    config._a[MILLISECOND] === 0) {
                    config._nextDay = true;
                    config._a[HOUR] = 0;
                }

                config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

                // Apply timezone offset from input. The actual utcOffset can be changed
                // with parseZone.
                if (config._tzm != null) {
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                }

                if (config._nextDay) {
                    config._a[HOUR] = 24;
                }

                // check for mismatching day of week
                if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
                    getParsingFlags(config).weekdayMismatch = true;
                }
            }

            function dayOfYearFromWeekInfo(config) {
                var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

                w = config._w;
                if (w.GG != null || w.W != null || w.E != null) {
                    dow = 1;
                    doy = 4;

                    // TODO: We need to take the current isoWeekYear, but that depends on
                    // how we interpret now (local, utc, fixed offset). So create
                    // a now version of current config (take local/utc/offset flags, and
                    // create now).
                    weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                    week = defaults(w.W, 1);
                    weekday = defaults(w.E, 1);
                    if (weekday < 1 || weekday > 7) {
                        weekdayOverflow = true;
                    }
                } else {
                    dow = config._locale._week.dow;
                    doy = config._locale._week.doy;

                    var curWeek = weekOfYear(createLocal(), dow, doy);

                    weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                    // Default to current week.
                    week = defaults(w.w, curWeek.week);

                    if (w.d != null) {
                        // weekday -- low day numbers are considered next week
                        weekday = w.d;
                        if (weekday < 0 || weekday > 6) {
                            weekdayOverflow = true;
                        }
                    } else if (w.e != null) {
                        // local weekday -- counting starts from begining of week
                        weekday = w.e + dow;
                        if (w.e < 0 || w.e > 6) {
                            weekdayOverflow = true;
                        }
                    } else {
                        // default to begining of week
                        weekday = dow;
                    }
                }
                if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                    getParsingFlags(config)._overflowWeeks = true;
                } else if (weekdayOverflow != null) {
                    getParsingFlags(config)._overflowWeekday = true;
                } else {
                    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                    config._a[YEAR] = temp.year;
                    config._dayOfYear = temp.dayOfYear;
                }
            }

            // iso 8601 regex
            // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
            var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
            var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

            var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

            var isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                // YYYYMM is NOT allowed by the standard
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/]
            ];

            // iso time formats and regexes
            var isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/]
            ];

            var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

            // date from iso format
            function configFromISO(config) {
                var i, l,
                    string = config._i,
                    match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                    allowTime, dateFormat, timeFormat, tzFormat;

                if (match) {
                    getParsingFlags(config).iso = true;

                    for (i = 0, l = isoDates.length; i < l; i++) {
                        if (isoDates[i][1].exec(match[1])) {
                            dateFormat = isoDates[i][0];
                            allowTime = isoDates[i][2] !== false;
                            break;
                        }
                    }
                    if (dateFormat == null) {
                        config._isValid = false;
                        return;
                    }
                    if (match[3]) {
                        for (i = 0, l = isoTimes.length; i < l; i++) {
                            if (isoTimes[i][1].exec(match[3])) {
                                // match[2] should be 'T' or space
                                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                                break;
                            }
                        }
                        if (timeFormat == null) {
                            config._isValid = false;
                            return;
                        }
                    }
                    if (!allowTime && timeFormat != null) {
                        config._isValid = false;
                        return;
                    }
                    if (match[4]) {
                        if (tzRegex.exec(match[4])) {
                            tzFormat = 'Z';
                        } else {
                            config._isValid = false;
                            return;
                        }
                    }
                    config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                    configFromStringAndFormat(config);
                } else {
                    config._isValid = false;
                }
            }

            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

            function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                var result = [
                    untruncateYear(yearStr),
                    defaultLocaleMonthsShort.indexOf(monthStr),
                    parseInt(dayStr, 10),
                    parseInt(hourStr, 10),
                    parseInt(minuteStr, 10)
                ];

                if (secondStr) {
                    result.push(parseInt(secondStr, 10));
                }

                return result;
            }

            function untruncateYear(yearStr) {
                var year = parseInt(yearStr, 10);
                if (year <= 49) {
                    return 2000 + year;
                } else if (year <= 999) {
                    return 1900 + year;
                }
                return year;
            }

            function preprocessRFC2822(s) {
                // Remove comments and folding whitespace and replace multiple-spaces with a single space
                return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            }

            function checkWeekday(weekdayStr, parsedInput, config) {
                if (weekdayStr) {
                    // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
                    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                        weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                    if (weekdayProvided !== weekdayActual) {
                        getParsingFlags(config).weekdayMismatch = true;
                        config._isValid = false;
                        return false;
                    }
                }
                return true;
            }

            var obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60
            };

            function calculateOffset(obsOffset, militaryOffset, numOffset) {
                if (obsOffset) {
                    return obsOffsets[obsOffset];
                } else if (militaryOffset) {
                    // the only allowed military tz is Z
                    return 0;
                } else {
                    var hm = parseInt(numOffset, 10);
                    var m = hm % 100, h = (hm - m) / 100;
                    return h * 60 + m;
                }
            }

            // date and time from ref 2822 format
            function configFromRFC2822(config) {
                var match = rfc2822.exec(preprocessRFC2822(config._i));
                if (match) {
                    var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                    if (!checkWeekday(match[1], parsedArray, config)) {
                        return;
                    }

                    config._a = parsedArray;
                    config._tzm = calculateOffset(match[8], match[9], match[10]);

                    config._d = createUTCDate.apply(null, config._a);
                    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                    getParsingFlags(config).rfc2822 = true;
                } else {
                    config._isValid = false;
                }
            }

            // date from iso format or fallback
            function configFromString(config) {
                var matched = aspNetJsonRegex.exec(config._i);

                if (matched !== null) {
                    config._d = new Date(+matched[1]);
                    return;
                }

                configFromISO(config);
                if (config._isValid === false) {
                    delete config._isValid;
                } else {
                    return;
                }

                configFromRFC2822(config);
                if (config._isValid === false) {
                    delete config._isValid;
                } else {
                    return;
                }

                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }

            hooks.createFromInputFallback = deprecate(
                'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                'discouraged and will be removed in an upcoming major release. Please refer to ' +
                'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
                function (config) {
                    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
                }
            );

            // constant that refers to the ISO standard
            hooks.ISO_8601 = function () { };

            // constant that refers to the RFC 2822 form
            hooks.RFC_2822 = function () { };

            // date from string and format string
            function configFromStringAndFormat(config) {
                // TODO: Move this to another part of the creation flow to prevent circular deps
                if (config._f === hooks.ISO_8601) {
                    configFromISO(config);
                    return;
                }
                if (config._f === hooks.RFC_2822) {
                    configFromRFC2822(config);
                    return;
                }
                config._a = [];
                getParsingFlags(config).empty = true;

                // This array is used to make a Date, either with `new Date` or `Date.UTC`
                var string = '' + config._i,
                    i, parsedInput, tokens, token, skipped,
                    stringLength = string.length,
                    totalParsedInputLength = 0;

                tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

                for (i = 0; i < tokens.length; i++) {
                    token = tokens[i];
                    parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                    // console.log('token', token, 'parsedInput', parsedInput,
                    //         'regex', getParseRegexForToken(token, config));
                    if (parsedInput) {
                        skipped = string.substr(0, string.indexOf(parsedInput));
                        if (skipped.length > 0) {
                            getParsingFlags(config).unusedInput.push(skipped);
                        }
                        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                        totalParsedInputLength += parsedInput.length;
                    }
                    // don't parse if it's not a known token
                    if (formatTokenFunctions[token]) {
                        if (parsedInput) {
                            getParsingFlags(config).empty = false;
                        }
                        else {
                            getParsingFlags(config).unusedTokens.push(token);
                        }
                        addTimeToArrayFromToken(token, parsedInput, config);
                    }
                    else if (config._strict && !parsedInput) {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                }

                // add remaining unparsed input length to the string
                getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                if (string.length > 0) {
                    getParsingFlags(config).unusedInput.push(string);
                }

                // clear _12h flag if hour is <= 12
                if (config._a[HOUR] <= 12 &&
                    getParsingFlags(config).bigHour === true &&
                    config._a[HOUR] > 0) {
                    getParsingFlags(config).bigHour = undefined;
                }

                getParsingFlags(config).parsedDateParts = config._a.slice(0);
                getParsingFlags(config).meridiem = config._meridiem;
                // handle meridiem
                config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

                configFromArray(config);
                checkOverflow(config);
            }


            function meridiemFixWrap(locale, hour, meridiem) {
                var isPm;

                if (meridiem == null) {
                    // nothing to do
                    return hour;
                }
                if (locale.meridiemHour != null) {
                    return locale.meridiemHour(hour, meridiem);
                } else if (locale.isPM != null) {
                    // Fallback
                    isPm = locale.isPM(meridiem);
                    if (isPm && hour < 12) {
                        hour += 12;
                    }
                    if (!isPm && hour === 12) {
                        hour = 0;
                    }
                    return hour;
                } else {
                    // this is not supposed to happen
                    return hour;
                }
            }

            // date from string and array of format strings
            function configFromStringAndArray(config) {
                var tempConfig,
                    bestMoment,

                    scoreToBeat,
                    i,
                    currentScore;

                if (config._f.length === 0) {
                    getParsingFlags(config).invalidFormat = true;
                    config._d = new Date(NaN);
                    return;
                }

                for (i = 0; i < config._f.length; i++) {
                    currentScore = 0;
                    tempConfig = copyConfig({}, config);
                    if (config._useUTC != null) {
                        tempConfig._useUTC = config._useUTC;
                    }
                    tempConfig._f = config._f[i];
                    configFromStringAndFormat(tempConfig);

                    if (!isValid(tempConfig)) {
                        continue;
                    }

                    // if there is any input that was not parsed add a penalty for that format
                    currentScore += getParsingFlags(tempConfig).charsLeftOver;

                    //or tokens
                    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                    getParsingFlags(tempConfig).score = currentScore;

                    if (scoreToBeat == null || currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }

                extend(config, bestMoment || tempConfig);
            }

            function configFromObject(config) {
                if (config._d) {
                    return;
                }

                var i = normalizeObjectUnits(config._i);
                config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                    return obj && parseInt(obj, 10);
                });

                configFromArray(config);
            }

            function createFromConfig(config) {
                var res = new Moment(checkOverflow(prepareConfig(config)));
                if (res._nextDay) {
                    // Adding is smart enough around DST
                    res.add(1, 'd');
                    res._nextDay = undefined;
                }

                return res;
            }

            function prepareConfig(config) {
                var input = config._i,
                    format = config._f;

                config._locale = config._locale || getLocale(config._l);

                if (input === null || (format === undefined && input === '')) {
                    return createInvalid({ nullInput: true });
                }

                if (typeof input === 'string') {
                    config._i = input = config._locale.preparse(input);
                }

                if (isMoment(input)) {
                    return new Moment(checkOverflow(input));
                } else if (isDate(input)) {
                    config._d = input;
                } else if (isArray(format)) {
                    configFromStringAndArray(config);
                } else if (format) {
                    configFromStringAndFormat(config);
                } else {
                    configFromInput(config);
                }

                if (!isValid(config)) {
                    config._d = null;
                }

                return config;
            }

            function configFromInput(config) {
                var input = config._i;
                if (isUndefined(input)) {
                    config._d = new Date(hooks.now());
                } else if (isDate(input)) {
                    config._d = new Date(input.valueOf());
                } else if (typeof input === 'string') {
                    configFromString(config);
                } else if (isArray(input)) {
                    config._a = map(input.slice(0), function (obj) {
                        return parseInt(obj, 10);
                    });
                    configFromArray(config);
                } else if (isObject(input)) {
                    configFromObject(config);
                } else if (isNumber(input)) {
                    // from milliseconds
                    config._d = new Date(input);
                } else {
                    hooks.createFromInputFallback(config);
                }
            }

            function createLocalOrUTC(input, format, locale, strict, isUTC) {
                var c = {};

                if (locale === true || locale === false) {
                    strict = locale;
                    locale = undefined;
                }

                if ((isObject(input) && isObjectEmpty(input)) ||
                    (isArray(input) && input.length === 0)) {
                    input = undefined;
                }
                // object construction must be done this way.
                // https://github.com/moment/moment/issues/1423
                c._isAMomentObject = true;
                c._useUTC = c._isUTC = isUTC;
                c._l = locale;
                c._i = input;
                c._f = format;
                c._strict = strict;

                return createFromConfig(c);
            }

            function createLocal(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, false);
            }

            var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

            var prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

            // Pick a moment m from moments so that m[fn](other) is true for all
            // other. This relies on the function fn to be transitive.
            //
            // moments should either be an array of moment objects or an array, whose
            // first element is an array of moment objects.
            function pickBy(fn, moments) {
                var res, i;
                if (moments.length === 1 && isArray(moments[0])) {
                    moments = moments[0];
                }
                if (!moments.length) {
                    return createLocal();
                }
                res = moments[0];
                for (i = 1; i < moments.length; ++i) {
                    if (!moments[i].isValid() || moments[i][fn](res)) {
                        res = moments[i];
                    }
                }
                return res;
            }

            // TODO: Use [].sort instead?
            function min() {
                var args = [].slice.call(arguments, 0);

                return pickBy('isBefore', args);
            }

            function max() {
                var args = [].slice.call(arguments, 0);

                return pickBy('isAfter', args);
            }

            var now = function () {
                return Date.now ? Date.now() : +(new Date());
            };

            var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

            function isDurationValid(m) {
                for (var key in m) {
                    if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                        return false;
                    }
                }

                var unitHasDecimal = false;
                for (var i = 0; i < ordering.length; ++i) {
                    if (m[ordering[i]]) {
                        if (unitHasDecimal) {
                            return false; // only allow non-integers for smallest unit
                        }
                        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                            unitHasDecimal = true;
                        }
                    }
                }

                return true;
            }

            function isValid$1() {
                return this._isValid;
            }

            function createInvalid$1() {
                return createDuration(NaN);
            }

            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration),
                    years = normalizedInput.year || 0,
                    quarters = normalizedInput.quarter || 0,
                    months = normalizedInput.month || 0,
                    weeks = normalizedInput.week || 0,
                    days = normalizedInput.day || 0,
                    hours = normalizedInput.hour || 0,
                    minutes = normalizedInput.minute || 0,
                    seconds = normalizedInput.second || 0,
                    milliseconds = normalizedInput.millisecond || 0;

                this._isValid = isDurationValid(normalizedInput);

                // representation for dateAddRemove
                this._milliseconds = +milliseconds +
                    seconds * 1e3 + // 1000
                    minutes * 6e4 + // 1000 * 60
                    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
                // Because of dateAddRemove treats 24 hours as different from a
                // day when working around DST, we need to store them separately
                this._days = +days +
                    weeks * 7;
                // It is impossible to translate months into days without knowing
                // which months you are are talking about, so we have to store
                // it separately.
                this._months = +months +
                    quarters * 3 +
                    years * 12;

                this._data = {};

                this._locale = getLocale();

                this._bubble();
            }

            function isDuration(obj) {
                return obj instanceof Duration;
            }

            function absRound(number) {
                if (number < 0) {
                    return Math.round(-1 * number) * -1;
                } else {
                    return Math.round(number);
                }
            }

            // FORMATTING

            function offset(token, separator) {
                addFormatToken(token, 0, 0, function () {
                    var offset = this.utcOffset();
                    var sign = '+';
                    if (offset < 0) {
                        offset = -offset;
                        sign = '-';
                    }
                    return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
                });
            }

            offset('Z', ':');
            offset('ZZ', '');

            // PARSING

            addRegexToken('Z', matchShortOffset);
            addRegexToken('ZZ', matchShortOffset);
            addParseToken(['Z', 'ZZ'], function (input, array, config) {
                config._useUTC = true;
                config._tzm = offsetFromString(matchShortOffset, input);
            });

            // HELPERS

            // timezone chunker
            // '+10:00' > ['10',  '00']
            // '-1530'  > ['-15', '30']
            var chunkOffset = /([\+\-]|\d\d)/gi;

            function offsetFromString(matcher, string) {
                var matches = (string || '').match(matcher);

                if (matches === null) {
                    return null;
                }

                var chunk = matches[matches.length - 1] || [];
                var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
                var minutes = +(parts[1] * 60) + toInt(parts[2]);

                return minutes === 0 ?
                    0 :
                    parts[0] === '+' ? minutes : -minutes;
            }

            // Return a moment from input, that is local/utc/zone equivalent to model.
            function cloneWithOffset(input, model) {
                var res, diff;
                if (model._isUTC) {
                    res = model.clone();
                    diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                    // Use low-level api, because this fn is low-level api.
                    res._d.setTime(res._d.valueOf() + diff);
                    hooks.updateOffset(res, false);
                    return res;
                } else {
                    return createLocal(input).local();
                }
            }

            function getDateOffset(m) {
                // On Firefox.24 Date#getTimezoneOffset returns a floating point.
                // https://github.com/moment/moment/pull/1871
                return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
            }

            // HOOKS

            // This function will be called whenever a moment is mutated.
            // It is intended to keep the offset in sync with the timezone.
            hooks.updateOffset = function () { };

            // MOMENTS

            // keepLocalTime = true means only change the timezone, without
            // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
            // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
            // +0200, so we adjust the time as needed, to be valid.
            //
            // Keeping the time actually adds/subtracts (one hour)
            // from the actual represented time. That is why we call updateOffset
            // a second time. In case it wants us to change the offset again
            // _changeInProgress == true case, then we have to adjust, because
            // there is no such time in the given timezone.
            function getSetOffset(input, keepLocalTime, keepMinutes) {
                var offset = this._offset || 0,
                    localAdjust;
                if (!this.isValid()) {
                    return input != null ? this : NaN;
                }
                if (input != null) {
                    if (typeof input === 'string') {
                        input = offsetFromString(matchShortOffset, input);
                        if (input === null) {
                            return this;
                        }
                    } else if (Math.abs(input) < 16 && !keepMinutes) {
                        input = input * 60;
                    }
                    if (!this._isUTC && keepLocalTime) {
                        localAdjust = getDateOffset(this);
                    }
                    this._offset = input;
                    this._isUTC = true;
                    if (localAdjust != null) {
                        this.add(localAdjust, 'm');
                    }
                    if (offset !== input) {
                        if (!keepLocalTime || this._changeInProgress) {
                            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                        } else if (!this._changeInProgress) {
                            this._changeInProgress = true;
                            hooks.updateOffset(this, true);
                            this._changeInProgress = null;
                        }
                    }
                    return this;
                } else {
                    return this._isUTC ? offset : getDateOffset(this);
                }
            }

            function getSetZone(input, keepLocalTime) {
                if (input != null) {
                    if (typeof input !== 'string') {
                        input = -input;
                    }

                    this.utcOffset(input, keepLocalTime);

                    return this;
                } else {
                    return -this.utcOffset();
                }
            }

            function setOffsetToUTC(keepLocalTime) {
                return this.utcOffset(0, keepLocalTime);
            }

            function setOffsetToLocal(keepLocalTime) {
                if (this._isUTC) {
                    this.utcOffset(0, keepLocalTime);
                    this._isUTC = false;

                    if (keepLocalTime) {
                        this.subtract(getDateOffset(this), 'm');
                    }
                }
                return this;
            }

            function setOffsetToParsedOffset() {
                if (this._tzm != null) {
                    this.utcOffset(this._tzm, false, true);
                } else if (typeof this._i === 'string') {
                    var tZone = offsetFromString(matchOffset, this._i);
                    if (tZone != null) {
                        this.utcOffset(tZone);
                    }
                    else {
                        this.utcOffset(0, true);
                    }
                }
                return this;
            }

            function hasAlignedHourOffset(input) {
                if (!this.isValid()) {
                    return false;
                }
                input = input ? createLocal(input).utcOffset() : 0;

                return (this.utcOffset() - input) % 60 === 0;
            }

            function isDaylightSavingTime() {
                return (
                    this.utcOffset() > this.clone().month(0).utcOffset() ||
                    this.utcOffset() > this.clone().month(5).utcOffset()
                );
            }

            function isDaylightSavingTimeShifted() {
                if (!isUndefined(this._isDSTShifted)) {
                    return this._isDSTShifted;
                }

                var c = {};

                copyConfig(c, this);
                c = prepareConfig(c);

                if (c._a) {
                    var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                    this._isDSTShifted = this.isValid() &&
                        compareArrays(c._a, other.toArray()) > 0;
                } else {
                    this._isDSTShifted = false;
                }

                return this._isDSTShifted;
            }

            function isLocal() {
                return this.isValid() ? !this._isUTC : false;
            }

            function isUtcOffset() {
                return this.isValid() ? this._isUTC : false;
            }

            function isUtc() {
                return this.isValid() ? this._isUTC && this._offset === 0 : false;
            }

            // ASP.NET json date format regex
            var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

            function createDuration(input, key) {
                var duration = input,
                    // matching against regexp is expensive, do it on demand
                    match = null,
                    sign,
                    ret,
                    diffRes;

                if (isDuration(input)) {
                    duration = {
                        ms: input._milliseconds,
                        d: input._days,
                        M: input._months
                    };
                } else if (isNumber(input)) {
                    duration = {};
                    if (key) {
                        duration[key] = input;
                    } else {
                        duration.milliseconds = input;
                    }
                } else if (!!(match = aspNetRegex.exec(input))) {
                    sign = (match[1] === '-') ? -1 : 1;
                    duration = {
                        y: 0,
                        d: toInt(match[DATE]) * sign,
                        h: toInt(match[HOUR]) * sign,
                        m: toInt(match[MINUTE]) * sign,
                        s: toInt(match[SECOND]) * sign,
                        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
                    };
                } else if (!!(match = isoRegex.exec(input))) {
                    sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
                    duration = {
                        y: parseIso(match[2], sign),
                        M: parseIso(match[3], sign),
                        w: parseIso(match[4], sign),
                        d: parseIso(match[5], sign),
                        h: parseIso(match[6], sign),
                        m: parseIso(match[7], sign),
                        s: parseIso(match[8], sign)
                    };
                } else if (duration == null) {// checks for null or undefined
                    duration = {};
                } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                    diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

                    duration = {};
                    duration.ms = diffRes.milliseconds;
                    duration.M = diffRes.months;
                }

                ret = new Duration(duration);

                if (isDuration(input) && hasOwnProp(input, '_locale')) {
                    ret._locale = input._locale;
                }

                return ret;
            }

            createDuration.fn = Duration.prototype;
            createDuration.invalid = createInvalid$1;

            function parseIso(inp, sign) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            }

            function positiveMomentsDifference(base, other) {
                var res = { milliseconds: 0, months: 0 };

                res.months = other.month() - base.month() +
                    (other.year() - base.year()) * 12;
                if (base.clone().add(res.months, 'M').isAfter(other)) {
                    --res.months;
                }

                res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

                return res;
            }

            function momentsDifference(base, other) {
                var res;
                if (!(base.isValid() && other.isValid())) {
                    return { milliseconds: 0, months: 0 };
                }

                other = cloneWithOffset(other, base);
                if (base.isBefore(other)) {
                    res = positiveMomentsDifference(base, other);
                } else {
                    res = positiveMomentsDifference(other, base);
                    res.milliseconds = -res.milliseconds;
                    res.months = -res.months;
                }

                return res;
            }

            // TODO: remove 'name' arg after deprecation is removed
            function createAdder(direction, name) {
                return function (val, period) {
                    var dur, tmp;
                    //invert the arguments, but complain about it
                    if (period !== null && !isNaN(+period)) {
                        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                        tmp = val; val = period; period = tmp;
                    }

                    val = typeof val === 'string' ? +val : val;
                    dur = createDuration(val, period);
                    addSubtract(this, dur, direction);
                    return this;
                };
            }

            function addSubtract(mom, duration, isAdding, updateOffset) {
                var milliseconds = duration._milliseconds,
                    days = absRound(duration._days),
                    months = absRound(duration._months);

                if (!mom.isValid()) {
                    // No op
                    return;
                }

                updateOffset = updateOffset == null ? true : updateOffset;

                if (months) {
                    setMonth(mom, get(mom, 'Month') + months * isAdding);
                }
                if (days) {
                    set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
                }
                if (milliseconds) {
                    mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                }
                if (updateOffset) {
                    hooks.updateOffset(mom, days || months);
                }
            }

            var add = createAdder(1, 'add');
            var subtract = createAdder(-1, 'subtract');

            function getCalendarFormat(myMoment, now) {
                var diff = myMoment.diff(now, 'days', true);
                return diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                        diff < 0 ? 'lastDay' :
                            diff < 1 ? 'sameDay' :
                                diff < 2 ? 'nextDay' :
                                    diff < 7 ? 'nextWeek' : 'sameElse';
            }

            function calendar$1(time, formats) {
                // We want to compare the start of today, vs this.
                // Getting start-of-today depends on whether we're local/utc/offset or not.
                var now = time || createLocal(),
                    sod = cloneWithOffset(now, this).startOf('day'),
                    format = hooks.calendarFormat(this, sod) || 'sameElse';

                var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

                return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
            }

            function clone() {
                return new Moment(this);
            }

            function isAfter(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() > localInput.valueOf();
                } else {
                    return localInput.valueOf() < this.clone().startOf(units).valueOf();
                }
            }

            function isBefore(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input);
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() < localInput.valueOf();
                } else {
                    return this.clone().endOf(units).valueOf() < localInput.valueOf();
                }
            }

            function isBetween(from, to, units, inclusivity) {
                inclusivity = inclusivity || '()';
                return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
                    (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
            }

            function isSame(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input),
                    inputMs;
                if (!(this.isValid() && localInput.isValid())) {
                    return false;
                }
                units = normalizeUnits(units || 'millisecond');
                if (units === 'millisecond') {
                    return this.valueOf() === localInput.valueOf();
                } else {
                    inputMs = localInput.valueOf();
                    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                }
            }

            function isSameOrAfter(input, units) {
                return this.isSame(input, units) || this.isAfter(input, units);
            }

            function isSameOrBefore(input, units) {
                return this.isSame(input, units) || this.isBefore(input, units);
            }

            function diff(input, units, asFloat) {
                var that,
                    zoneDelta,
                    output;

                if (!this.isValid()) {
                    return NaN;
                }

                that = cloneWithOffset(input, this);

                if (!that.isValid()) {
                    return NaN;
                }

                zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

                units = normalizeUnits(units);

                switch (units) {
                    case 'year': output = monthDiff(this, that) / 12; break;
                    case 'month': output = monthDiff(this, that); break;
                    case 'quarter': output = monthDiff(this, that) / 3; break;
                    case 'second': output = (this - that) / 1e3; break; // 1000
                    case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
                    case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
                    case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
                    case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
                    default: output = this - that;
                }

                return asFloat ? output : absFloor(output);
            }

            function monthDiff(a, b) {
                // difference in months
                var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
                    // b is in (anchor - 1 month, anchor + 1 month)
                    anchor = a.clone().add(wholeMonthDiff, 'months'),
                    anchor2, adjust;

                if (b - anchor < 0) {
                    anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                    // linear across the month
                    adjust = (b - anchor) / (anchor - anchor2);
                } else {
                    anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                    // linear across the month
                    adjust = (b - anchor) / (anchor2 - anchor);
                }

                //check for negative zero, return zero if negative zero
                return -(wholeMonthDiff + adjust) || 0;
            }

            hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
            hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

            function toString() {
                return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
            }

            function toISOString(keepOffset) {
                if (!this.isValid()) {
                    return null;
                }
                var utc = keepOffset !== true;
                var m = utc ? this.clone().utc() : this;
                if (m.year() < 0 || m.year() > 9999) {
                    return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
                }
                if (isFunction(Date.prototype.toISOString)) {
                    // native implementation is ~50x faster, use it when we can
                    if (utc) {
                        return this.toDate().toISOString();
                    } else {
                        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
                    }
                }
                return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
            }

            /**
             * Return a human readable representation of a moment that can
             * also be evaluated to get a new moment which is the same
             *
             * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
             */
            function inspect() {
                if (!this.isValid()) {
                    return 'moment.invalid(/* ' + this._i + ' */)';
                }
                var func = 'moment';
                var zone = '';
                if (!this.isLocal()) {
                    func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                    zone = 'Z';
                }
                var prefix = '[' + func + '("]';
                var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
                var datetime = '-MM-DD[T]HH:mm:ss.SSS';
                var suffix = zone + '[")]';

                return this.format(prefix + year + datetime + suffix);
            }

            function format(inputString) {
                if (!inputString) {
                    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                }
                var output = formatMoment(this, inputString);
                return this.localeData().postformat(output);
            }

            function from(time, withoutSuffix) {
                if (this.isValid() &&
                    ((isMoment(time) && time.isValid()) ||
                        createLocal(time).isValid())) {
                    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }

            function fromNow(withoutSuffix) {
                return this.from(createLocal(), withoutSuffix);
            }

            function to(time, withoutSuffix) {
                if (this.isValid() &&
                    ((isMoment(time) && time.isValid()) ||
                        createLocal(time).isValid())) {
                    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
                } else {
                    return this.localeData().invalidDate();
                }
            }

            function toNow(withoutSuffix) {
                return this.to(createLocal(), withoutSuffix);
            }

            // If passed a locale key, it will set the locale for this
            // instance.  Otherwise, it will return the locale configuration
            // variables for this instance.
            function locale(key) {
                var newLocaleData;

                if (key === undefined) {
                    return this._locale._abbr;
                } else {
                    newLocaleData = getLocale(key);
                    if (newLocaleData != null) {
                        this._locale = newLocaleData;
                    }
                    return this;
                }
            }

            var lang = deprecate(
                'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
                function (key) {
                    if (key === undefined) {
                        return this.localeData();
                    } else {
                        return this.locale(key);
                    }
                }
            );

            function localeData() {
                return this._locale;
            }

            function startOf(units) {
                units = normalizeUnits(units);
                // the following switch intentionally omits break keywords
                // to utilize falling through the cases.
                switch (units) {
                    case 'year':
                        this.month(0);
                    /* falls through */
                    case 'quarter':
                    case 'month':
                        this.date(1);
                    /* falls through */
                    case 'week':
                    case 'isoWeek':
                    case 'day':
                    case 'date':
                        this.hours(0);
                    /* falls through */
                    case 'hour':
                        this.minutes(0);
                    /* falls through */
                    case 'minute':
                        this.seconds(0);
                    /* falls through */
                    case 'second':
                        this.milliseconds(0);
                }

                // weeks are a special case
                if (units === 'week') {
                    this.weekday(0);
                }
                if (units === 'isoWeek') {
                    this.isoWeekday(1);
                }

                // quarters are also special
                if (units === 'quarter') {
                    this.month(Math.floor(this.month() / 3) * 3);
                }

                return this;
            }

            function endOf(units) {
                units = normalizeUnits(units);
                if (units === undefined || units === 'millisecond') {
                    return this;
                }

                // 'date' is an alias for 'day', so it should be considered as such.
                if (units === 'date') {
                    units = 'day';
                }

                return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
            }

            function valueOf() {
                return this._d.valueOf() - ((this._offset || 0) * 60000);
            }

            function unix() {
                return Math.floor(this.valueOf() / 1000);
            }

            function toDate() {
                return new Date(this.valueOf());
            }

            function toArray() {
                var m = this;
                return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
            }

            function toObject() {
                var m = this;
                return {
                    years: m.year(),
                    months: m.month(),
                    date: m.date(),
                    hours: m.hours(),
                    minutes: m.minutes(),
                    seconds: m.seconds(),
                    milliseconds: m.milliseconds()
                };
            }

            function toJSON() {
                // new Date(NaN).toJSON() === null
                return this.isValid() ? this.toISOString() : null;
            }

            function isValid$2() {
                return isValid(this);
            }

            function parsingFlags() {
                return extend({}, getParsingFlags(this));
            }

            function invalidAt() {
                return getParsingFlags(this).overflow;
            }

            function creationData() {
                return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict
                };
            }

            // FORMATTING

            addFormatToken(0, ['gg', 2], 0, function () {
                return this.weekYear() % 100;
            });

            addFormatToken(0, ['GG', 2], 0, function () {
                return this.isoWeekYear() % 100;
            });

            function addWeekYearFormatToken(token, getter) {
                addFormatToken(0, [token, token.length], 0, getter);
            }

            addWeekYearFormatToken('gggg', 'weekYear');
            addWeekYearFormatToken('ggggg', 'weekYear');
            addWeekYearFormatToken('GGGG', 'isoWeekYear');
            addWeekYearFormatToken('GGGGG', 'isoWeekYear');

            // ALIASES

            addUnitAlias('weekYear', 'gg');
            addUnitAlias('isoWeekYear', 'GG');

            // PRIORITY

            addUnitPriority('weekYear', 1);
            addUnitPriority('isoWeekYear', 1);


            // PARSING

            addRegexToken('G', matchSigned);
            addRegexToken('g', matchSigned);
            addRegexToken('GG', match1to2, match2);
            addRegexToken('gg', match1to2, match2);
            addRegexToken('GGGG', match1to4, match4);
            addRegexToken('gggg', match1to4, match4);
            addRegexToken('GGGGG', match1to6, match6);
            addRegexToken('ggggg', match1to6, match6);

            addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
                week[token.substr(0, 2)] = toInt(input);
            });

            addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
                week[token] = hooks.parseTwoDigitYear(input);
            });

            // MOMENTS

            function getSetWeekYear(input) {
                return getSetWeekYearHelper.call(this,
                    input,
                    this.week(),
                    this.weekday(),
                    this.localeData()._week.dow,
                    this.localeData()._week.doy);
            }

            function getSetISOWeekYear(input) {
                return getSetWeekYearHelper.call(this,
                    input, this.isoWeek(), this.isoWeekday(), 1, 4);
            }

            function getISOWeeksInYear() {
                return weeksInYear(this.year(), 1, 4);
            }

            function getWeeksInYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
            }

            function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                var weeksTarget;
                if (input == null) {
                    return weekOfYear(this, dow, doy).year;
                } else {
                    weeksTarget = weeksInYear(input, dow, doy);
                    if (week > weeksTarget) {
                        week = weeksTarget;
                    }
                    return setWeekAll.call(this, input, week, weekday, dow, doy);
                }
            }

            function setWeekAll(weekYear, week, weekday, dow, doy) {
                var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                    date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

                this.year(date.getUTCFullYear());
                this.month(date.getUTCMonth());
                this.date(date.getUTCDate());
                return this;
            }

            // FORMATTING

            addFormatToken('Q', 0, 'Qo', 'quarter');

            // ALIASES

            addUnitAlias('quarter', 'Q');

            // PRIORITY

            addUnitPriority('quarter', 7);

            // PARSING

            addRegexToken('Q', match1);
            addParseToken('Q', function (input, array) {
                array[MONTH] = (toInt(input) - 1) * 3;
            });

            // MOMENTS

            function getSetQuarter(input) {
                return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
            }

            // FORMATTING

            addFormatToken('D', ['DD', 2], 'Do', 'date');

            // ALIASES

            addUnitAlias('date', 'D');

            // PRIORITY
            addUnitPriority('date', 9);

            // PARSING

            addRegexToken('D', match1to2);
            addRegexToken('DD', match1to2, match2);
            addRegexToken('Do', function (isStrict, locale) {
                // TODO: Remove "ordinalParse" fallback in next major release.
                return isStrict ?
                    (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
                    locale._dayOfMonthOrdinalParseLenient;
            });

            addParseToken(['D', 'DD'], DATE);
            addParseToken('Do', function (input, array) {
                array[DATE] = toInt(input.match(match1to2)[0]);
            });

            // MOMENTS

            var getSetDayOfMonth = makeGetSet('Date', true);

            // FORMATTING

            addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

            // ALIASES

            addUnitAlias('dayOfYear', 'DDD');

            // PRIORITY
            addUnitPriority('dayOfYear', 4);

            // PARSING

            addRegexToken('DDD', match1to3);
            addRegexToken('DDDD', match3);
            addParseToken(['DDD', 'DDDD'], function (input, array, config) {
                config._dayOfYear = toInt(input);
            });

            // HELPERS

            // MOMENTS

            function getSetDayOfYear(input) {
                var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
                return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
            }

            // FORMATTING

            addFormatToken('m', ['mm', 2], 0, 'minute');

            // ALIASES

            addUnitAlias('minute', 'm');

            // PRIORITY

            addUnitPriority('minute', 14);

            // PARSING

            addRegexToken('m', match1to2);
            addRegexToken('mm', match1to2, match2);
            addParseToken(['m', 'mm'], MINUTE);

            // MOMENTS

            var getSetMinute = makeGetSet('Minutes', false);

            // FORMATTING

            addFormatToken('s', ['ss', 2], 0, 'second');

            // ALIASES

            addUnitAlias('second', 's');

            // PRIORITY

            addUnitPriority('second', 15);

            // PARSING

            addRegexToken('s', match1to2);
            addRegexToken('ss', match1to2, match2);
            addParseToken(['s', 'ss'], SECOND);

            // MOMENTS

            var getSetSecond = makeGetSet('Seconds', false);

            // FORMATTING

            addFormatToken('S', 0, 0, function () {
                return ~~(this.millisecond() / 100);
            });

            addFormatToken(0, ['SS', 2], 0, function () {
                return ~~(this.millisecond() / 10);
            });

            addFormatToken(0, ['SSS', 3], 0, 'millisecond');
            addFormatToken(0, ['SSSS', 4], 0, function () {
                return this.millisecond() * 10;
            });
            addFormatToken(0, ['SSSSS', 5], 0, function () {
                return this.millisecond() * 100;
            });
            addFormatToken(0, ['SSSSSS', 6], 0, function () {
                return this.millisecond() * 1000;
            });
            addFormatToken(0, ['SSSSSSS', 7], 0, function () {
                return this.millisecond() * 10000;
            });
            addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
                return this.millisecond() * 100000;
            });
            addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
                return this.millisecond() * 1000000;
            });


            // ALIASES

            addUnitAlias('millisecond', 'ms');

            // PRIORITY

            addUnitPriority('millisecond', 16);

            // PARSING

            addRegexToken('S', match1to3, match1);
            addRegexToken('SS', match1to3, match2);
            addRegexToken('SSS', match1to3, match3);

            var token;
            for (token = 'SSSS'; token.length <= 9; token += 'S') {
                addRegexToken(token, matchUnsigned);
            }

            function parseMs(input, array) {
                array[MILLISECOND] = toInt(('0.' + input) * 1000);
            }

            for (token = 'S'; token.length <= 9; token += 'S') {
                addParseToken(token, parseMs);
            }
            // MOMENTS

            var getSetMillisecond = makeGetSet('Milliseconds', false);

            // FORMATTING

            addFormatToken('z', 0, 0, 'zoneAbbr');
            addFormatToken('zz', 0, 0, 'zoneName');

            // MOMENTS

            function getZoneAbbr() {
                return this._isUTC ? 'UTC' : '';
            }

            function getZoneName() {
                return this._isUTC ? 'Coordinated Universal Time' : '';
            }

            var proto = Moment.prototype;

            proto.add = add;
            proto.calendar = calendar$1;
            proto.clone = clone;
            proto.diff = diff;
            proto.endOf = endOf;
            proto.format = format;
            proto.from = from;
            proto.fromNow = fromNow;
            proto.to = to;
            proto.toNow = toNow;
            proto.get = stringGet;
            proto.invalidAt = invalidAt;
            proto.isAfter = isAfter;
            proto.isBefore = isBefore;
            proto.isBetween = isBetween;
            proto.isSame = isSame;
            proto.isSameOrAfter = isSameOrAfter;
            proto.isSameOrBefore = isSameOrBefore;
            proto.isValid = isValid$2;
            proto.lang = lang;
            proto.locale = locale;
            proto.localeData = localeData;
            proto.max = prototypeMax;
            proto.min = prototypeMin;
            proto.parsingFlags = parsingFlags;
            proto.set = stringSet;
            proto.startOf = startOf;
            proto.subtract = subtract;
            proto.toArray = toArray;
            proto.toObject = toObject;
            proto.toDate = toDate;
            proto.toISOString = toISOString;
            proto.inspect = inspect;
            proto.toJSON = toJSON;
            proto.toString = toString;
            proto.unix = unix;
            proto.valueOf = valueOf;
            proto.creationData = creationData;
            proto.year = getSetYear;
            proto.isLeapYear = getIsLeapYear;
            proto.weekYear = getSetWeekYear;
            proto.isoWeekYear = getSetISOWeekYear;
            proto.quarter = proto.quarters = getSetQuarter;
            proto.month = getSetMonth;
            proto.daysInMonth = getDaysInMonth;
            proto.week = proto.weeks = getSetWeek;
            proto.isoWeek = proto.isoWeeks = getSetISOWeek;
            proto.weeksInYear = getWeeksInYear;
            proto.isoWeeksInYear = getISOWeeksInYear;
            proto.date = getSetDayOfMonth;
            proto.day = proto.days = getSetDayOfWeek;
            proto.weekday = getSetLocaleDayOfWeek;
            proto.isoWeekday = getSetISODayOfWeek;
            proto.dayOfYear = getSetDayOfYear;
            proto.hour = proto.hours = getSetHour;
            proto.minute = proto.minutes = getSetMinute;
            proto.second = proto.seconds = getSetSecond;
            proto.millisecond = proto.milliseconds = getSetMillisecond;
            proto.utcOffset = getSetOffset;
            proto.utc = setOffsetToUTC;
            proto.local = setOffsetToLocal;
            proto.parseZone = setOffsetToParsedOffset;
            proto.hasAlignedHourOffset = hasAlignedHourOffset;
            proto.isDST = isDaylightSavingTime;
            proto.isLocal = isLocal;
            proto.isUtcOffset = isUtcOffset;
            proto.isUtc = isUtc;
            proto.isUTC = isUtc;
            proto.zoneAbbr = getZoneAbbr;
            proto.zoneName = getZoneName;
            proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
            proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
            proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
            proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
            proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

            function createUnix(input) {
                return createLocal(input * 1000);
            }

            function createInZone() {
                return createLocal.apply(null, arguments).parseZone();
            }

            function preParsePostFormat(string) {
                return string;
            }

            var proto$1 = Locale.prototype;

            proto$1.calendar = calendar;
            proto$1.longDateFormat = longDateFormat;
            proto$1.invalidDate = invalidDate;
            proto$1.ordinal = ordinal;
            proto$1.preparse = preParsePostFormat;
            proto$1.postformat = preParsePostFormat;
            proto$1.relativeTime = relativeTime;
            proto$1.pastFuture = pastFuture;
            proto$1.set = set;

            proto$1.months = localeMonths;
            proto$1.monthsShort = localeMonthsShort;
            proto$1.monthsParse = localeMonthsParse;
            proto$1.monthsRegex = monthsRegex;
            proto$1.monthsShortRegex = monthsShortRegex;
            proto$1.week = localeWeek;
            proto$1.firstDayOfYear = localeFirstDayOfYear;
            proto$1.firstDayOfWeek = localeFirstDayOfWeek;

            proto$1.weekdays = localeWeekdays;
            proto$1.weekdaysMin = localeWeekdaysMin;
            proto$1.weekdaysShort = localeWeekdaysShort;
            proto$1.weekdaysParse = localeWeekdaysParse;

            proto$1.weekdaysRegex = weekdaysRegex;
            proto$1.weekdaysShortRegex = weekdaysShortRegex;
            proto$1.weekdaysMinRegex = weekdaysMinRegex;

            proto$1.isPM = localeIsPM;
            proto$1.meridiem = localeMeridiem;

            function get$1(format, index, field, setter) {
                var locale = getLocale();
                var utc = createUTC().set(setter, index);
                return locale[field](utc, format);
            }

            function listMonthsImpl(format, index, field) {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';

                if (index != null) {
                    return get$1(format, index, field, 'month');
                }

                var i;
                var out = [];
                for (i = 0; i < 12; i++) {
                    out[i] = get$1(format, i, field, 'month');
                }
                return out;
            }

            // ()
            // (5)
            // (fmt, 5)
            // (fmt)
            // (true)
            // (true, 5)
            // (true, fmt, 5)
            // (true, fmt)
            function listWeekdaysImpl(localeSorted, format, index, field) {
                if (typeof localeSorted === 'boolean') {
                    if (isNumber(format)) {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';
                } else {
                    format = localeSorted;
                    index = format;
                    localeSorted = false;

                    if (isNumber(format)) {
                        index = format;
                        format = undefined;
                    }

                    format = format || '';
                }

                var locale = getLocale(),
                    shift = localeSorted ? locale._week.dow : 0;

                if (index != null) {
                    return get$1(format, (index + shift) % 7, field, 'day');
                }

                var i;
                var out = [];
                for (i = 0; i < 7; i++) {
                    out[i] = get$1(format, (i + shift) % 7, field, 'day');
                }
                return out;
            }

            function listMonths(format, index) {
                return listMonthsImpl(format, index, 'months');
            }

            function listMonthsShort(format, index) {
                return listMonthsImpl(format, index, 'monthsShort');
            }

            function listWeekdays(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
            }

            function listWeekdaysShort(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
            }

            function listWeekdaysMin(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
            }

            getSetGlobalLocale('en', {
                dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (number) {
                    var b = number % 10,
                        output = (toInt(number % 100 / 10) === 1) ? 'th' :
                            (b === 1) ? 'st' :
                                (b === 2) ? 'nd' :
                                    (b === 3) ? 'rd' : 'th';
                    return number + output;
                }
            });

            // Side effect imports

            hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
            hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

            var mathAbs = Math.abs;

            function abs() {
                var data = this._data;

                this._milliseconds = mathAbs(this._milliseconds);
                this._days = mathAbs(this._days);
                this._months = mathAbs(this._months);

                data.milliseconds = mathAbs(data.milliseconds);
                data.seconds = mathAbs(data.seconds);
                data.minutes = mathAbs(data.minutes);
                data.hours = mathAbs(data.hours);
                data.months = mathAbs(data.months);
                data.years = mathAbs(data.years);

                return this;
            }

            function addSubtract$1(duration, input, value, direction) {
                var other = createDuration(input, value);

                duration._milliseconds += direction * other._milliseconds;
                duration._days += direction * other._days;
                duration._months += direction * other._months;

                return duration._bubble();
            }

            // supports only 2.0-style add(1, 's') or add(duration)
            function add$1(input, value) {
                return addSubtract$1(this, input, value, 1);
            }

            // supports only 2.0-style subtract(1, 's') or subtract(duration)
            function subtract$1(input, value) {
                return addSubtract$1(this, input, value, -1);
            }

            function absCeil(number) {
                if (number < 0) {
                    return Math.floor(number);
                } else {
                    return Math.ceil(number);
                }
            }

            function bubble() {
                var milliseconds = this._milliseconds;
                var days = this._days;
                var months = this._months;
                var data = this._data;
                var seconds, minutes, hours, years, monthsFromDays;

                // if we have a mix of positive and negative values, bubble down first
                // check: https://github.com/moment/moment/issues/2166
                if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0))) {
                    milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                    days = 0;
                    months = 0;
                }

                // The following code bubbles up values, see the tests for
                // examples of what that means.
                data.milliseconds = milliseconds % 1000;

                seconds = absFloor(milliseconds / 1000);
                data.seconds = seconds % 60;

                minutes = absFloor(seconds / 60);
                data.minutes = minutes % 60;

                hours = absFloor(minutes / 60);
                data.hours = hours % 24;

                days += absFloor(hours / 24);

                // convert days to months
                monthsFromDays = absFloor(daysToMonths(days));
                months += monthsFromDays;
                days -= absCeil(monthsToDays(monthsFromDays));

                // 12 months -> 1 year
                years = absFloor(months / 12);
                months %= 12;

                data.days = days;
                data.months = months;
                data.years = years;

                return this;
            }

            function daysToMonths(days) {
                // 400 years have 146097 days (taking into account leap year rules)
                // 400 years have 12 months === 4800
                return days * 4800 / 146097;
            }

            function monthsToDays(months) {
                // the reverse of daysToMonths
                return months * 146097 / 4800;
            }

            function as(units) {
                if (!this.isValid()) {
                    return NaN;
                }
                var days;
                var months;
                var milliseconds = this._milliseconds;

                units = normalizeUnits(units);

                if (units === 'month' || units === 'year') {
                    days = this._days + milliseconds / 864e5;
                    months = this._months + daysToMonths(days);
                    return units === 'month' ? months : months / 12;
                } else {
                    // handle milliseconds separately because of floating point math errors (issue #1867)
                    days = this._days + Math.round(monthsToDays(this._months));
                    switch (units) {
                        case 'week': return days / 7 + milliseconds / 6048e5;
                        case 'day': return days + milliseconds / 864e5;
                        case 'hour': return days * 24 + milliseconds / 36e5;
                        case 'minute': return days * 1440 + milliseconds / 6e4;
                        case 'second': return days * 86400 + milliseconds / 1000;
                        // Math.floor prevents floating point math errors here
                        case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                        default: throw new Error('Unknown unit ' + units);
                    }
                }
            }

            // TODO: Use this.as('ms')?
            function valueOf$1() {
                if (!this.isValid()) {
                    return NaN;
                }
                return (
                    this._milliseconds +
                    this._days * 864e5 +
                    (this._months % 12) * 2592e6 +
                    toInt(this._months / 12) * 31536e6
                );
            }

            function makeAs(alias) {
                return function () {
                    return this.as(alias);
                };
            }

            var asMilliseconds = makeAs('ms');
            var asSeconds = makeAs('s');
            var asMinutes = makeAs('m');
            var asHours = makeAs('h');
            var asDays = makeAs('d');
            var asWeeks = makeAs('w');
            var asMonths = makeAs('M');
            var asYears = makeAs('y');

            function clone$1() {
                return createDuration(this);
            }

            function get$2(units) {
                units = normalizeUnits(units);
                return this.isValid() ? this[units + 's']() : NaN;
            }

            function makeGetter(name) {
                return function () {
                    return this.isValid() ? this._data[name] : NaN;
                };
            }

            var milliseconds = makeGetter('milliseconds');
            var seconds = makeGetter('seconds');
            var minutes = makeGetter('minutes');
            var hours = makeGetter('hours');
            var days = makeGetter('days');
            var months = makeGetter('months');
            var years = makeGetter('years');

            function weeks() {
                return absFloor(this.days() / 7);
            }

            var round = Math.round;
            var thresholds = {
                ss: 44,         // a few seconds to seconds
                s: 45,         // seconds to minute
                m: 45,         // minutes to hour
                h: 22,         // hours to day
                d: 26,         // days to month
                M: 11          // months to year
            };

            // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
            function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
            }

            function relativeTime$1(posNegDuration, withoutSuffix, locale) {
                var duration = createDuration(posNegDuration).abs();
                var seconds = round(duration.as('s'));
                var minutes = round(duration.as('m'));
                var hours = round(duration.as('h'));
                var days = round(duration.as('d'));
                var months = round(duration.as('M'));
                var years = round(duration.as('y'));

                var a = seconds <= thresholds.ss && ['s', seconds] ||
                    seconds < thresholds.s && ['ss', seconds] ||
                    minutes <= 1 && ['m'] ||
                    minutes < thresholds.m && ['mm', minutes] ||
                    hours <= 1 && ['h'] ||
                    hours < thresholds.h && ['hh', hours] ||
                    days <= 1 && ['d'] ||
                    days < thresholds.d && ['dd', days] ||
                    months <= 1 && ['M'] ||
                    months < thresholds.M && ['MM', months] ||
                    years <= 1 && ['y'] || ['yy', years];

                a[2] = withoutSuffix;
                a[3] = +posNegDuration > 0;
                a[4] = locale;
                return substituteTimeAgo.apply(null, a);
            }

            // This function allows you to set the rounding function for relative time strings
            function getSetRelativeTimeRounding(roundingFunction) {
                if (roundingFunction === undefined) {
                    return round;
                }
                if (typeof (roundingFunction) === 'function') {
                    round = roundingFunction;
                    return true;
                }
                return false;
            }

            // This function allows you to set a threshold for relative time strings
            function getSetRelativeTimeThreshold(threshold, limit) {
                if (thresholds[threshold] === undefined) {
                    return false;
                }
                if (limit === undefined) {
                    return thresholds[threshold];
                }
                thresholds[threshold] = limit;
                if (threshold === 's') {
                    thresholds.ss = limit - 1;
                }
                return true;
            }

            function humanize(withSuffix) {
                if (!this.isValid()) {
                    return this.localeData().invalidDate();
                }

                var locale = this.localeData();
                var output = relativeTime$1(this, !withSuffix, locale);

                if (withSuffix) {
                    output = locale.pastFuture(+this, output);
                }

                return locale.postformat(output);
            }

            var abs$1 = Math.abs;

            function sign(x) {
                return ((x > 0) - (x < 0)) || +x;
            }

            function toISOString$1() {
                // for ISO strings we do not use the normal bubbling rules:
                //  * milliseconds bubble up until they become hours
                //  * days do not bubble at all
                //  * months bubble up until they become years
                // This is because there is no context-free conversion between hours and days
                // (think of clock changes)
                // and also not between days and months (28-31 days per month)
                if (!this.isValid()) {
                    return this.localeData().invalidDate();
                }

                var seconds = abs$1(this._milliseconds) / 1000;
                var days = abs$1(this._days);
                var months = abs$1(this._months);
                var minutes, hours, years;

                // 3600 seconds -> 60 minutes -> 1 hour
                minutes = absFloor(seconds / 60);
                hours = absFloor(minutes / 60);
                seconds %= 60;
                minutes %= 60;

                // 12 months -> 1 year
                years = absFloor(months / 12);
                months %= 12;


                // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
                var Y = years;
                var M = months;
                var D = days;
                var h = hours;
                var m = minutes;
                var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
                var total = this.asSeconds();

                if (!total) {
                    // this is the same as C#'s (Noda) and python (isodate)...
                    // but not other JS (goog.date)
                    return 'P0D';
                }

                var totalSign = total < 0 ? '-' : '';
                var ymSign = sign(this._months) !== sign(total) ? '-' : '';
                var daysSign = sign(this._days) !== sign(total) ? '-' : '';
                var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

                return totalSign + 'P' +
                    (Y ? ymSign + Y + 'Y' : '') +
                    (M ? ymSign + M + 'M' : '') +
                    (D ? daysSign + D + 'D' : '') +
                    ((h || m || s) ? 'T' : '') +
                    (h ? hmsSign + h + 'H' : '') +
                    (m ? hmsSign + m + 'M' : '') +
                    (s ? hmsSign + s + 'S' : '');
            }

            var proto$2 = Duration.prototype;

            proto$2.isValid = isValid$1;
            proto$2.abs = abs;
            proto$2.add = add$1;
            proto$2.subtract = subtract$1;
            proto$2.as = as;
            proto$2.asMilliseconds = asMilliseconds;
            proto$2.asSeconds = asSeconds;
            proto$2.asMinutes = asMinutes;
            proto$2.asHours = asHours;
            proto$2.asDays = asDays;
            proto$2.asWeeks = asWeeks;
            proto$2.asMonths = asMonths;
            proto$2.asYears = asYears;
            proto$2.valueOf = valueOf$1;
            proto$2._bubble = bubble;
            proto$2.clone = clone$1;
            proto$2.get = get$2;
            proto$2.milliseconds = milliseconds;
            proto$2.seconds = seconds;
            proto$2.minutes = minutes;
            proto$2.hours = hours;
            proto$2.days = days;
            proto$2.weeks = weeks;
            proto$2.months = months;
            proto$2.years = years;
            proto$2.humanize = humanize;
            proto$2.toISOString = toISOString$1;
            proto$2.toString = toISOString$1;
            proto$2.toJSON = toISOString$1;
            proto$2.locale = locale;
            proto$2.localeData = localeData;

            proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
            proto$2.lang = lang;

            // Side effect imports

            // FORMATTING

            addFormatToken('X', 0, 0, 'unix');
            addFormatToken('x', 0, 0, 'valueOf');

            // PARSING

            addRegexToken('x', matchSigned);
            addRegexToken('X', matchTimestamp);
            addParseToken('X', function (input, array, config) {
                config._d = new Date(parseFloat(input, 10) * 1000);
            });
            addParseToken('x', function (input, array, config) {
                config._d = new Date(toInt(input));
            });

            // Side effect imports


            hooks.version = '2.22.2';

            setHookCallback(createLocal);

            hooks.fn = proto;
            hooks.min = min;
            hooks.max = max;
            hooks.now = now;
            hooks.utc = createUTC;
            hooks.unix = createUnix;
            hooks.months = listMonths;
            hooks.isDate = isDate;
            hooks.locale = getSetGlobalLocale;
            hooks.invalid = createInvalid;
            hooks.duration = createDuration;
            hooks.isMoment = isMoment;
            hooks.weekdays = listWeekdays;
            hooks.parseZone = createInZone;
            hooks.localeData = getLocale;
            hooks.isDuration = isDuration;
            hooks.monthsShort = listMonthsShort;
            hooks.weekdaysMin = listWeekdaysMin;
            hooks.defineLocale = defineLocale;
            hooks.updateLocale = updateLocale;
            hooks.locales = listLocales;
            hooks.weekdaysShort = listWeekdaysShort;
            hooks.normalizeUnits = normalizeUnits;
            hooks.relativeTimeRounding = getSetRelativeTimeRounding;
            hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
            hooks.calendarFormat = getCalendarFormat;
            hooks.prototype = proto;

            // currently HTML5 input type only supports 24-hour formats
            hooks.HTML5_FMT = {
                DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
                DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
                DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
                DATE: 'YYYY-MM-DD',                             // <input type="date" />
                TIME: 'HH:mm',                                  // <input type="time" />
                TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
                TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
                WEEK: 'YYYY-[W]WW',                             // <input type="week" />
                MONTH: 'YYYY-MM'                                // <input type="month" />
            };

            return hooks;

        })));

    </script>
    <script>
        /**
        * @author: Rinat G. http://coding.kz
        * @copyright: Copyright (c) 2019 Rinat G.
        * @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
        */

        // Following the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
        (function (root, factory) {
            if (typeof define === 'function' && define.amd) {
                // AMD. Make globaly available as well
                define(['moment'], function (moment) {
                    return factory(moment);
                });
            } else if (typeof module === 'object' && module.exports) {
                // Node / Browserify
                var moment = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : require('moment');
                module.exports = factory(moment);
            } else {
                // Browser globals
                root.Lightpick = factory(root.moment);
            }
        }(this, function (moment) {
            'use strict';

            var document = window.document,

                defaults = {
                    field: null,
                    secondField: null,
                    firstDay: 1,
                    parentEl: 'body',
                    lang: 'auto',
                    format: 'DD/MM/YYYY',
                    separator: ' - ',
                    numberOfMonths: 1,
                    numberOfColumns: 2,
                    singleDate: true,
                    autoclose: true,
                    repick: false,
                    startDate: null,
                    endDate: null,
                    minDate: null,
                    maxDate: null,
                    disableDates: null,
                    selectForward: false,
                    selectBackward: false,
                    minDays: null,
                    maxDays: null,
                    hoveringTooltip: true,
                    hideOnBodyClick: true,
                    footer: false,
                    disabledDatesInRange: true,
                    tooltipNights: false,
                    orientation: 'auto',
                    disableWeekends: false,
                    inline: false,
                    dropdowns: {
                        years: {
                            min: 1900,
                            max: null,
                        },
                        months: true,
                    },
                    locale: {
                        buttons: {
                            prev: '&leftarrow;',
                            next: '&rightarrow;',
                            close: '&times;',
                            reset: 'Reset',
                            apply: 'Apply',
                        },
                        tooltip: {
                            one: 'day',
                            other: 'days',
                        },
                        tooltipOnDisabled: null,
                        pluralize: function (i, locale) {
                            if (typeof i === "string") i = parseInt(i, 10);

                            if (i === 1 && 'one' in locale) return locale.one;
                            if ('other' in locale) return locale.other;

                            return '';
                        },
                    },

                    onSelect: null,
                    onOpen: null,
                    onClose: null,
                    onError: null,
                },

                renderTopButtons = function (opts) {
                    return '<div class="lightpick__toolbar">'
                        + ''
                        + '<button type="button" class="lightpick__previous-action">' + opts.locale.buttons.prev + '</button>'
                        + '<button type="button" class="lightpick__next-action">' + opts.locale.buttons.next + '</button>'
                        + (!opts.autoclose && !opts.inline ? '<button type="button" class="lightpick__close-action">' + opts.locale.buttons.close + '</button>' : '')
                        + '</div>';
                },

                weekdayName = function (opts, day, short) {
                    return new Date(1970, 0, day).toLocaleString(opts.lang, { weekday: short ? 'short' : 'long' })
                },

                renderDay = function (opts, date, dummy, extraClass) {
                    if (dummy) return '<div></div>';

                    var date = moment(date),
                        prevMonth = moment(date).subtract(1, 'month'),
                        nextMonth = moment(date).add(1, 'month');

                    var day = {
                        time: moment(date).valueOf(),
                        className: ['lightpick__day', 'is-available']
                    };

                    if (extraClass instanceof Array || Object.prototype.toString.call(extraClass) === '[object Array]') {
                        extraClass = extraClass.filter(function (el) {
                            return ['lightpick__day', 'is-available', 'is-previous-month', 'is-next-month'].indexOf(el) >= 0;
                        });
                        day.className = day.className.concat(extraClass);
                    }
                    else {
                        day.className.push(extraClass);
                    }

                    if (opts.disableDates) {
                        for (var i = 0; i < opts.disableDates.length; i++) {
                            if (opts.disableDates[i] instanceof Array || Object.prototype.toString.call(opts.disableDates[i]) === '[object Array]') {
                                var _from = moment(opts.disableDates[i][0]),
                                    _to = moment(opts.disableDates[i][1]);

                                if (_from.isValid() && _to.isValid() && date.isBetween(_from, _to, 'day', '[]')) {
                                    day.className.push('is-disabled');
                                }
                            }
                            else if (moment(opts.disableDates[i]).isValid() && moment(opts.disableDates[i]).isSame(date, 'day')) {
                                day.className.push('is-disabled');
                            }

                            if (day.className.indexOf('is-disabled') >= 0) {

                                if (opts.locale.tooltipOnDisabled && (!opts.startDate || date.isAfter(opts.startDate) || opts.startDate && opts.endDate)) {
                                    day.className.push('disabled-tooltip');
                                }

                                if (day.className.indexOf('is-start-date') >= 0) {
                                    this.setStartDate(null);
                                    this.setEndDate(null);
                                }
                                else if (day.className.indexOf('is-end-date') >= 0) {
                                    this.setEndDate(null);
                                }
                            }
                        }
                    }

                    if (opts.minDays && opts.startDate && !opts.endDate) {
                        if (date.isBetween(moment(opts.startDate).subtract(opts.minDays - 1, 'day'), moment(opts.startDate).add(opts.minDays - 1, 'day'), 'day')) {
                            day.className.push('is-disabled');

                            if (opts.selectForward && date.isSameOrAfter(opts.startDate)) {
                                day.className.push('is-forward-selected');
                                day.className.push('is-in-range');
                            }
                        }
                    }

                    if (opts.maxDays && opts.startDate && !opts.endDate) {
                        if (date.isSameOrBefore(moment(opts.startDate).subtract(opts.maxDays, 'day'), 'day')) {
                            day.className.push('is-disabled');
                        }
                        else if (date.isSameOrAfter(moment(opts.startDate).add(opts.maxDays, 'day'), 'day')) {
                            day.className.push('is-disabled');
                        }
                    }

                    if (opts.repick && (opts.minDays || opts.maxDays) && opts.startDate && opts.endDate) {
                        var tempStartDate = moment(opts.repickTrigger == opts.field ? opts.endDate : opts.startDate);

                        if (opts.minDays) {
                            if (date.isBetween(moment(tempStartDate).subtract(opts.minDays - 1, 'day'), moment(tempStartDate).add(opts.minDays - 1, 'day'), 'day')) {
                                day.className.push('is-disabled');
                            }
                        }

                        if (opts.maxDays) {
                            if (date.isSameOrBefore(moment(tempStartDate).subtract(opts.maxDays, 'day'), 'day')) {
                                day.className.push('is-disabled');
                            }
                            else if (date.isSameOrAfter(moment(tempStartDate).add(opts.maxDays, 'day'), 'day')) {
                                day.className.push('is-disabled');
                            }
                        }
                    }

                    if (date.isSame(new Date(), 'day')) {
                        day.className.push('is-today');
                    }

                    if (date.isSame(opts.startDate, 'day')) {
                        day.className.push('is-start-date');
                    }

                    if (date.isSame(opts.endDate, 'day')) {
                        day.className.push('is-end-date');
                    }

                    if (opts.startDate && opts.endDate && date.isBetween(opts.startDate, opts.endDate, 'day', '[]')) {
                        day.className.push('is-in-range');
                    }

                    if (moment().isSame(date, 'month')) {

                    }
                    else if (prevMonth.isSame(date, 'month')) {
                        day.className.push('is-previous-month');
                    }
                    else if (nextMonth.isSame(date, 'month')) {
                        day.className.push('is-next-month');
                    }

                    if (opts.minDate && date.isBefore(opts.minDate, 'day')) {
                        day.className.push('is-disabled');
                    }

                    if (opts.maxDate && date.isAfter(opts.maxDate, 'day')) {
                        day.className.push('is-disabled');
                    }

                    if (opts.selectForward && !opts.singleDate && opts.startDate && !opts.endDate && date.isBefore(opts.startDate, 'day')) {
                        day.className.push('is-disabled');
                    }

                    if (opts.selectBackward && !opts.singleDate && opts.startDate && !opts.endDate && date.isAfter(opts.startDate, 'day')) {
                        day.className.push('is-disabled');
                    }

                    if (opts.disableWeekends && (date.isoWeekday() == 6 || date.isoWeekday() == 7)) {
                        day.className.push('is-disabled');
                    }

                    day.className = day.className.filter(function (value, index, self) {
                        return self.indexOf(value) === index;
                    });

                    if (day.className.indexOf('is-disabled') >= 0 && day.className.indexOf('is-available') >= 0) {
                        day.className.splice(day.className.indexOf('is-available'), 1);
                    }

                    var div = document.createElement('div');
                    div.className = day.className.join(' ');
                    div.innerHTML = date.get('date');
                    div.setAttribute('data-time', day.time);

                    return div.outerHTML;
                },

                renderMonthsList = function (date, opts) {
                    var d = moment(date),
                        select = document.createElement('select');

                    for (var idx = 0; idx < 12; idx++) {
                        d.set('month', idx);

                        var option = document.createElement('option');
                        option.value = d.toDate().getMonth();
                        option.text = d.toDate().toLocaleString(opts.lang, { month: 'long' });

                        if (idx === date.toDate().getMonth()) {
                            option.setAttribute('selected', 'selected');
                        }

                        select.appendChild(option);
                    }

                    select.className = 'lightpick__select lightpick__select-months';

                    // for text align to right
                    select.dir = 'rtl';

                    if (!opts.dropdowns || !opts.dropdowns.months) {
                        select.disabled = true;
                    }

                    return select.outerHTML;
                },

                renderYearsList = function (date, opts) {
                    var d = moment(date),
                        select = document.createElement('select'),
                        years = opts.dropdowns && opts.dropdowns.years ? opts.dropdowns.years : null,
                        minYear = years && years.min ? years.min : 1900,
                        maxYear = years && years.max ? years.max : Number.parseInt(moment().format('YYYY'));

                    if (Number.parseInt(date.format('YYYY')) < minYear) {
                        minYear = Number.parseInt(date.format('YYYY'));
                    }

                    if (Number.parseInt(date.format('YYYY')) > maxYear) {
                        maxYear = Number.parseInt(date.format('YYYY'));
                    }

                    for (var idx = minYear; idx <= maxYear; idx++) {
                        d.set('year', idx);

                        var option = document.createElement('option');
                        option.value = d.toDate().getFullYear();
                        option.text = d.toDate().getFullYear();

                        if (idx === date.toDate().getFullYear()) {
                            option.setAttribute('selected', 'selected');
                        }

                        select.appendChild(option);
                    }

                    select.className = 'lightpick__select lightpick__select-years';

                    if (!opts.dropdowns || !opts.dropdowns.years) {
                        select.disabled = true;
                    }

                    return select.outerHTML;
                },

                renderCalendar = function (el, opts) {
                    var html = '',
                        monthDate = moment(opts.calendar[0]);

                    for (var i = 0; i < opts.numberOfMonths; i++) {
                        var day = moment(monthDate);

                        html += '<section class="lightpick__month">';
                        html += '<header class="lightpick__month-title-bar">'
                        html += '<div class="lightpick__month-title">'
                            + renderMonthsList(day, opts)
                            + renderYearsList(day, opts)
                            + '</div>';

                        if (opts.numberOfMonths === 1) {
                            html += renderTopButtons(opts, 'days');
                        }

                        html += '</header>'; // lightpick__month-title-bar

                        html += '<div class="lightpick__days-of-the-week">';
                        for (var w = opts.firstDay + 4; w < 7 + opts.firstDay + 4; ++w) {
                            html += '<div class="lightpick__day-of-the-week" title="' + weekdayName(opts, w) + '">' + weekdayName(opts, w, true) + '</div>';
                        }
                        html += '</div>'; // lightpick__days-of-the-week

                        html += '<div class="lightpick__days">';

                        if (day.isoWeekday() !== opts.firstDay) {
                            var prevDays = day.isoWeekday() - opts.firstDay > 0 ? day.isoWeekday() - opts.firstDay : day.isoWeekday(),
                                prevMonth = moment(day).subtract(prevDays, 'day'),
                                daysInMonth = prevMonth.daysInMonth();

                            for (var d = prevMonth.get('date'); d <= daysInMonth; d++) {
                                html += renderDay(opts, prevMonth, i > 0, 'is-previous-month');

                                prevMonth.add(1, 'day');
                            }
                        }

                        var daysInMonth = day.daysInMonth(),
                            today = new Date();

                        for (var d = 0; d < daysInMonth; d++) {
                            html += renderDay(opts, day);

                            day.add(1, 'day');
                        }

                        var nextMonth = moment(day),
                            nextDays = 7 - nextMonth.isoWeekday() + opts.firstDay;

                        if (nextDays < 7) {
                            for (var d = nextMonth.get('date'); d <= nextDays; d++) {
                                html += renderDay(opts, nextMonth, i < opts.numberOfMonths - 1, 'is-next-month');

                                nextMonth.add(1, 'day');
                            }
                        }

                        html += '</div>'; // lightpick__days

                        html += '</section>'; // lightpick__month

                        monthDate.add(1, 'month');
                    }

                    opts.calendar[1] = moment(monthDate);

                    el.querySelector('.lightpick__months').innerHTML = html;
                },

                updateDates = function (el, opts) {
                    var days = el.querySelectorAll('.lightpick__day');
                    [].forEach.call(days, function (day) {
                        day.outerHTML = renderDay(opts, parseInt(day.getAttribute('data-time')), false, day.className.split(' '));
                    });

                    checkDisabledDatesInRange(el, opts);
                },

                checkDisabledDatesInRange = function (el, opts) {
                    if (opts.disabledDatesInRange || !opts.startDate || opts.endDate || !opts.disableDates) return;

                    var days = el.querySelectorAll('.lightpick__day'),
                        disabledArray = opts.disableDates.map(function (entry) {
                            return entry instanceof Array || Object.prototype.toString.call(entry) === '[object Array]' ? entry[0] : entry;
                        }),
                        closestPrev = moment(disabledArray.filter(function (d) {
                            return moment(d).isBefore(opts.startDate);
                        }).sort(function (a, b) {
                            return moment(b).isAfter(moment(a));
                        })[0]),
                        closestNext = moment(disabledArray.filter(function (d) {
                            return moment(d).isAfter(opts.startDate);
                        }).sort(function (a, b) {
                            return moment(a).isAfter(moment(b));
                        })[0]);

                    [].forEach.call(days, function (dayCell) {
                        var day = moment(parseInt(dayCell.getAttribute('data-time')));
                        if (
                            (closestPrev && day.isBefore(closestPrev) && opts.startDate.isAfter(closestPrev))
                            || (closestNext && day.isAfter(closestNext) && closestNext.isAfter(opts.startDate))
                        ) {
                            dayCell.classList.remove('is-available');
                            dayCell.classList.add('is-disabled');
                        }
                    });
                },

                Lightpick = function (options) {
                    var self = this,
                        opts = self.config(options);

                    self.el = document.createElement('section');

                    self.el.className = 'lightpick lightpick--' + opts.numberOfColumns + '-columns is-hidden';

                    if (opts.inline) {
                        self.el.className += ' lightpick--inlined';
                    }

                    var html = '<div class="lightpick__inner">'
                        + (opts.numberOfMonths > 1 ? renderTopButtons(opts, 'days') : '')
                        + '<div class="lightpick__months"></div>'
                        + '<div class="lightpick__tooltip" style="visibility: hidden"></div>';

                    if (opts.footer) {
                        html += '<div class="lightpick__footer">';
                        if (opts.footer === true) {
                            html += '<button type="button" class="lightpick__reset-action">' + opts.locale.buttons.reset + '</button>';
                            html += '<div class="lightpick__footer-message"></div>';
                            html += '<button type="button" class="lightpick__apply-action">' + opts.locale.buttons.apply + '</button>';
                        }
                        else {
                            html += opts.footer;
                        }
                        html += '</div>';
                    }

                    html += '</div>';

                    self.el.innerHTML = html;


                    if (opts.parentEl instanceof Node) {
                        opts.parentEl.appendChild(self.el)
                    }
                    else if (opts.parentEl === 'body' && opts.inline) {
                        opts.field.parentNode.appendChild(self.el);
                    }
                    else {
                        document.querySelector(opts.parentEl).appendChild(self.el);
                    }

                    self._onMouseDown = function (e) {
                        if (!self.isShowing) {
                            return;
                        }

                        e = e || window.event;
                        var target = e.target || e.srcElement;
                        if (!target) {
                            return;
                        }

                        e.stopPropagation();

                        if (!target.classList.contains('lightpick__select')) {
                            e.preventDefault();
                        }

                        var opts = self._opts;

                        if (target.classList.contains('lightpick__day') && target.classList.contains('is-available')) {

                            var day = moment(parseInt(target.getAttribute('data-time')));

                            if (!opts.disabledDatesInRange && opts.disableDates && opts.startDate) {
                                var start = day.isAfter(opts.startDate) ? moment(opts.startDate) : moment(day),
                                    end = day.isAfter(opts.startDate) ? moment(day) : moment(opts.startDate),

                                    isInvalidRange = opts.disableDates.filter(function (d) {
                                        if (d instanceof Array || Object.prototype.toString.call(d) === '[object Array]') {
                                            var _from = moment(d[0]),
                                                _to = moment(d[1]);

                                            return _from.isValid() && _to.isValid() && (_from.isBetween(start, end, 'day', '[]') || _to.isBetween(start, end, 'day', '[]'));
                                        }

                                        return moment(d).isBetween(start, end, 'day', '[]');
                                    });

                                if (isInvalidRange.length) {
                                    self.setStartDate(null);
                                    self.setEndDate(null);

                                    target.dispatchEvent(new Event('mousedown'));
                                    self.el.querySelector('.lightpick__tooltip').style.visibility = 'hidden';

                                    updateDates(self.el, opts);
                                    return;
                                }
                            }

                            if (opts.singleDate || (!opts.startDate && !opts.endDate) || (opts.startDate && opts.endDate)) {
                                if (opts.repick && opts.startDate && opts.endDate) {
                                    if (opts.repickTrigger === opts.field) {
                                        self.setStartDate(day);
                                        target.classList.add('is-start-date');
                                    }
                                    else {
                                        self.setEndDate(day);
                                        target.classList.add('is-end-date');
                                    }

                                    if (opts.startDate.isAfter(opts.endDate)) {
                                        self.swapDate();
                                    }

                                    if (opts.autoclose) {
                                        setTimeout(function () {
                                            self.hide();
                                        }, 100);
                                    }
                                }
                                else {
                                    self.setStartDate(day);
                                    self.setEndDate(null);

                                    target.classList.add('is-start-date');

                                    if (opts.singleDate && opts.autoclose) {
                                        setTimeout(function () {
                                            self.hide();
                                        }, 100);
                                    }
                                    else if (!opts.singleDate || opts.inline) {
                                        updateDates(self.el, opts);
                                    }
                                }
                            }
                            else if (opts.startDate && !opts.endDate) {
                                self.setEndDate(day);

                                if (opts.startDate.isAfter(opts.endDate)) {
                                    self.swapDate();
                                }

                                target.classList.add('is-end-date');


                                if (opts.autoclose) {
                                    setTimeout(function () {
                                        self.hide();
                                    }, 100);
                                }
                                else {
                                    updateDates(self.el, opts);
                                }
                            }

                            if (!opts.disabledDatesInRange) {
                                if (self.el.querySelectorAll('.lightpick__day.is-available').length === 0) {
                                    self.setStartDate(null);
                                    updateDates(self.el, opts);

                                    if (opts.footer) {
                                        if (typeof self._opts.onError === 'function') {
                                            self._opts.onError.call(self, 'Invalid range');
                                        }
                                        else {
                                            var footerMessage = self.el.querySelector('.lightpick__footer-message');

                                            if (footerMessage) {
                                                footerMessage.innerHTML = opts.locale.not_allowed_range;

                                                setTimeout(function () {
                                                    footerMessage.innerHTML = '';
                                                }, 3000);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (target.classList.contains('lightpick__previous-action')) {
                            self.prevMonth();
                        }
                        else if (target.classList.contains('lightpick__next-action')) {
                            self.nextMonth();
                        }
                        else if (target.classList.contains('lightpick__close-action') || target.classList.contains('lightpick__apply-action')) {
                            self.hide();
                        }
                        else if (target.classList.contains('lightpick__reset-action')) {
                            self.reset();
                        }
                    };
                    self._onMouseEnter = function (e) {
                        if (!self.isShowing) {
                            return;
                        }

                        e = e || window.event;
                        var target = e.target || e.srcElement;
                        if (!target) {
                            return;
                        }

                        var opts = self._opts;

                        if (target.classList.contains('lightpick__day') && target.classList.contains('disabled-tooltip') && opts.locale.tooltipOnDisabled) {
                            self.showTooltip(target, opts.locale.tooltipOnDisabled);
                            return;
                        }
                        else {
                            self.hideTooltip();
                        }

                        if (opts.singleDate || (!opts.startDate && !opts.endDate)) {
                            return;
                        }

                        if (!target.classList.contains('lightpick__day') && !target.classList.contains('is-available')) {
                            return;
                        }

                        if ((opts.startDate && !opts.endDate) || opts.repick) {
                            var hoverDate = moment(parseInt(target.getAttribute('data-time')));

                            if (!hoverDate.isValid()) {
                                return;
                            }

                            var startDate = (opts.startDate && !opts.endDate) || (opts.repick && opts.repickTrigger === opts.secondField) ? opts.startDate : opts.endDate;

                            var days = self.el.querySelectorAll('.lightpick__day');
                            [].forEach.call(days, function (day) {
                                var dt = moment(parseInt(day.getAttribute('data-time')));

                                day.classList.remove('is-flipped');

                                if (dt.isValid() && dt.isSameOrAfter(startDate, 'day') && dt.isSameOrBefore(hoverDate, 'day')) {
                                    day.classList.add('is-in-range');

                                    if (opts.repickTrigger === opts.field && dt.isSameOrAfter(opts.endDate)) {
                                        day.classList.add('is-flipped');
                                    }
                                }
                                else if (dt.isValid() && dt.isSameOrAfter(hoverDate, 'day') && dt.isSameOrBefore(startDate, 'day')) {
                                    day.classList.add('is-in-range');

                                    if (((opts.startDate && !opts.endDate) || opts.repickTrigger === opts.secondField) && dt.isSameOrBefore(opts.startDate)) {
                                        day.classList.add('is-flipped');
                                    }
                                }
                                else {
                                    day.classList.remove('is-in-range');
                                }

                                if (opts.startDate && opts.endDate && opts.repick && opts.repickTrigger === opts.field) {
                                    day.classList.remove('is-start-date');
                                }
                                else {
                                    day.classList.remove('is-end-date');
                                }
                            });

                            if (opts.hoveringTooltip) {
                                days = Math.abs(hoverDate.isAfter(startDate) ? hoverDate.diff(startDate, 'day') : startDate.diff(hoverDate, 'day'));

                                if (!opts.tooltipNights) {
                                    days += 1;
                                }

                                var tooltip = self.el.querySelector('.lightpick__tooltip');

                                if (days > 0 && !target.classList.contains('is-disabled')) {

                                    var pluralText = '';
                                    if (typeof opts.locale.pluralize === 'function') {
                                        pluralText = opts.locale.pluralize.call(self, days, opts.locale.tooltip);
                                    }

                                    self.showTooltip(target, days + ' ' + pluralText);
                                }
                                else {
                                    self.hideTooltip();
                                }
                            }

                            if (opts.startDate && opts.endDate && opts.repick && opts.repickTrigger === opts.field) {
                                target.classList.add('is-start-date');
                            }
                            else {
                                target.classList.add('is-end-date');
                            }
                        }
                    };
                    self._onChange = function (e) {
                        e = e || window.event;
                        var target = e.target || e.srcElement;
                        if (!target) {
                            return;
                        }

                        if (target.classList.contains('lightpick__select-months')) {
                            self.gotoMonth(target.value);
                        }
                        else if (target.classList.contains('lightpick__select-years')) {
                            self.gotoYear(target.value);
                        }
                    };

                    self._onInputChange = function (e) {
                        var target = e.target || e.srcElement;

                        if (self._opts.singleDate) {
                            if (!self._opts.autoclose) {
                                self.gotoDate(opts.field.value);
                            }
                        }

                        self.syncFields();

                        if (!self.isShowing) {
                            self.show();
                        }
                    };

                    self._onInputFocus = function (e) {
                        var target = e.target || e.srcElement;

                        self.show(target);
                    };

                    self._onInputClick = function (e) {
                        var target = e.target || e.srcElement;

                        self.show(target);
                    };

                    self._onClick = function (e) {
                        e = e || window.event;
                        var target = e.target || e.srcElement,
                            parentEl = target;

                        if (!target) {
                            return;
                        }

                        do {
                            if ((parentEl.classList && parentEl.classList.contains('lightpick')) || parentEl === opts.field || (opts.secondField && parentEl === opts.secondField)) {
                                return;
                            }
                        }
                        while ((parentEl = parentEl.parentNode));

                        if (self.isShowing && opts.hideOnBodyClick && target !== opts.field && parentEl !== opts.field) {
                            self.hide();
                        }
                    };

                    self.showTooltip = function (target, text) {
                        var tooltip = self.el.querySelector('.lightpick__tooltip');

                        var hasParentEl = self.el.classList.contains('lightpick--inlined'),
                            dayBounding = target.getBoundingClientRect(),
                            pickerBouding = hasParentEl ? self.el.parentNode.getBoundingClientRect() : self.el.getBoundingClientRect(),
                            _left = (dayBounding.left - pickerBouding.left) + (dayBounding.width / 2),
                            _top = dayBounding.top - pickerBouding.top;

                        tooltip.style.visibility = 'visible';
                        tooltip.textContent = text;

                        var tooltipBounding = tooltip.getBoundingClientRect();

                        _top -= tooltipBounding.height;
                        _left -= (tooltipBounding.width / 2);

                        setTimeout(function () {
                            tooltip.style.top = _top + 'px';
                            tooltip.style.left = _left + 'px';
                        }, 10);
                    };

                    self.hideTooltip = function () {
                        var tooltip = self.el.querySelector('.lightpick__tooltip');
                        tooltip.style.visibility = 'hidden';
                    };

                    self.el.addEventListener('mousedown', self._onMouseDown, true);
                    self.el.addEventListener('mouseenter', self._onMouseEnter, true);
                    self.el.addEventListener('touchend', self._onMouseDown, true);
                    self.el.addEventListener('change', self._onChange, true);

                    if (opts.inline) {
                        self.show();
                    }
                    else {
                        self.hide();
                    }

                    opts.field.addEventListener('change', self._onInputChange);
                    opts.field.addEventListener('click', self._onInputClick);
                    opts.field.addEventListener('focus', self._onInputFocus);

                    if (opts.secondField) {
                        opts.secondField.addEventListener('change', self._onInputChange);
                        opts.secondField.addEventListener('click', self._onInputClick);
                        opts.secondField.addEventListener('focus', self._onInputFocus);
                    }
                };

            Lightpick.prototype = {
                config: function (options) {
                    var opts = Object.assign({}, defaults, options);

                    opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

                    opts.calendar = [moment().set('date', 1)];

                    if (opts.numberOfMonths === 1 && opts.numberOfColumns > 1) {
                        opts.numberOfColumns = 1;
                    }

                    opts.minDate = opts.minDate && moment(opts.minDate).isValid() ? moment(opts.minDate) : null;

                    opts.maxDate = opts.maxDate && moment(opts.maxDate).isValid() ? moment(opts.maxDate) : null;

                    if (opts.lang === 'auto') {
                        var browserLang = navigator.language || navigator.userLanguage;
                        if (browserLang) {
                            opts.lang = browserLang;
                        }
                        else {
                            opts.lang = 'en-US';
                        }
                    }

                    if (opts.secondField && opts.singleDate) {
                        opts.singleDate = false;
                    }

                    if (opts.hoveringTooltip && opts.singleDate) {
                        opts.hoveringTooltip = false;
                    }

                    if (Object.prototype.toString.call(options.locale) === '[object Object]') {
                        opts.locale = Object.assign({}, defaults.locale, options.locale);
                    }

                    if (window.innerWidth < 480 && opts.numberOfMonths > 1) {
                        opts.numberOfMonths = 1;
                        opts.numberOfColumns = 1;
                    }

                    if (opts.repick && !opts.secondField) {
                        opts.repick = false;
                    }

                    if (opts.inline) {
                        opts.autoclose = false;
                        opts.hideOnBodyClick = false;
                    }

                    this._opts = Object.assign({}, opts);

                    this.syncFields();

                    this.setStartDate(this._opts.startDate, true);
                    this.setEndDate(this._opts.endDate, true);

                    return this._opts;
                },

                syncFields: function () {
                    if (this._opts.singleDate || this._opts.secondField) {
                        if (moment(this._opts.field.value, this._opts.format).isValid()) {
                            this._opts.startDate = moment(this._opts.field.value, this._opts.format);
                        }

                        if (this._opts.secondField && moment(this._opts.secondField.value, this._opts.format).isValid()) {
                            this._opts.endDate = moment(this._opts.secondField.value, this._opts.format);
                        }
                    }
                    else {
                        var dates = this._opts.field.value.split(this._opts.separator);

                        if (dates.length === 2) {
                            if (moment(dates[0], this._opts.format).isValid()) {
                                this._opts.startDate = moment(dates[0], this._opts.format);
                            }

                            if (moment(dates[1], this._opts.format).isValid()) {
                                this._opts.endDate = moment(dates[1], this._opts.format);
                            }
                        }
                    }
                },

                swapDate: function () {
                    var tmp = moment(this._opts.startDate);
                    this.setDateRange(this._opts.endDate, tmp);
                },

                gotoToday: function () {
                    this.gotoDate(new Date());
                },

                gotoDate: function (date) {
                    var date = moment(date);

                    if (!date.isValid()) {
                        date = moment();
                    }

                    date.set('date', 1);

                    this._opts.calendar = [moment(date)];

                    renderCalendar(this.el, this._opts);
                },

                gotoMonth: function (month) {
                    if (isNaN(month)) {
                        return;
                    }

                    this._opts.calendar[0].set('month', month);

                    renderCalendar(this.el, this._opts);
                },

                gotoYear: function (year) {
                    if (isNaN(year)) {
                        return;
                    }

                    this._opts.calendar[0].set('year', year);

                    renderCalendar(this.el, this._opts);
                },

                prevMonth: function () {
                    this._opts.calendar[0] = moment(this._opts.calendar[0]).subtract(this._opts.numberOfMonths, 'month');

                    renderCalendar(this.el, this._opts);

                    checkDisabledDatesInRange(this.el, this._opts);
                },

                nextMonth: function () {
                    this._opts.calendar[0] = moment(this._opts.calendar[1]);

                    renderCalendar(this.el, this._opts);

                    checkDisabledDatesInRange(this.el, this._opts);
                },

                updatePosition: function () {
                    if (this.el.classList.contains('lightpick--inlined')) return;

                    // remove `is-hidden` class for getBoundingClientRect
                    this.el.classList.remove('is-hidden');

                    var rect = this._opts.field.getBoundingClientRect(),
                        calRect = this.el.getBoundingClientRect(),
                        orientation = this._opts.orientation.split(' '),
                        top = 0,
                        left = 0;

                    if (orientation[0] == 'auto' || !(/top|bottom/.test(orientation[0]))) {
                        if (rect.bottom + calRect.height > window.innerHeight && window.pageYOffset > calRect.height) {
                            top = (rect.top + window.pageYOffset) - calRect.height;
                        }
                        else {
                            top = rect.bottom + window.pageYOffset;
                        }
                    }
                    else {
                        top = rect[orientation[0]] + window.pageYOffset;

                        if (orientation[0] == 'top') {
                            top -= calRect.height;
                        }
                    }

                    if (!(/left|right/.test(orientation[0])) && (!orientation[1] || orientation[1] == 'auto' || !(/left|right/.test(orientation[1])))) {
                        if (rect.left + calRect.width > window.innerWidth) {
                            left = (rect.right + window.pageXOffset) - calRect.width;
                        }
                        else {
                            left = rect.left + window.pageXOffset;
                        }
                    }
                    else {
                        if (/left|right/.test(orientation[0])) {
                            left = rect[orientation[0]] + window.pageXOffset;
                        }
                        else {
                            left = rect[orientation[1]] + window.pageXOffset;
                        }

                        if (orientation[0] == 'right' || orientation[1] == 'right') {
                            left -= calRect.width;
                        }
                    }

                    this.el.classList.add('is-hidden');

                    this.el.style.top = top + 'px';
                    this.el.style.left = left + 'px';
                },

                setStartDate: function (date, preventOnSelect) {
                    var dateISO = moment(date, moment.ISO_8601),
                        dateOptFormat = moment(date, this._opts.format);

                    if (!dateISO.isValid() && !dateOptFormat.isValid()) {
                        this._opts.startDate = null;
                        this._opts.field.value = '';
                        return;
                    }

                    this._opts.startDate = moment(dateISO.isValid() ? dateISO : dateOptFormat);

                    if (this._opts.singleDate || this._opts.secondField) {
                        this._opts.field.value = this._opts.startDate.format(this._opts.format);
                    }
                    else {
                        this._opts.field.value = this._opts.startDate.format(this._opts.format) + this._opts.separator + '...'
                    }

                    if (!preventOnSelect && typeof this._opts.onSelect === 'function') {
                        this._opts.onSelect.call(this, this.getStartDate(), this.getEndDate());
                    }
                },

                setEndDate: function (date, preventOnSelect) {
                    var dateISO = moment(date, moment.ISO_8601),
                        dateOptFormat = moment(date, this._opts.format);

                    if (!dateISO.isValid() && !dateOptFormat.isValid()) {
                        this._opts.endDate = null;

                        if (this._opts.secondField) {
                            this._opts.secondField.value = '';
                        }
                        else if (!this._opts.singleDate && this._opts.startDate) {
                            this._opts.field.value = this._opts.startDate.format(this._opts.format) + this._opts.separator + '...'
                        }
                        return;
                    }

                    this._opts.endDate = moment(dateISO.isValid() ? dateISO : dateOptFormat);

                    if (this._opts.secondField) {
                        this._opts.field.value = this._opts.startDate.format(this._opts.format);
                        this._opts.secondField.value = this._opts.endDate.format(this._opts.format);
                    }
                    else {
                        this._opts.field.value = this._opts.startDate.format(this._opts.format) + this._opts.separator + this._opts.endDate.format(this._opts.format);
                    }

                    if (!preventOnSelect && typeof this._opts.onSelect === 'function') {
                        this._opts.onSelect.call(this, this.getStartDate(), this.getEndDate());
                    }
                },

                setDate: function (date, preventOnSelect) {
                    if (!this._opts.singleDate) {
                        return;
                    }
                    this.setStartDate(date, preventOnSelect);

                    if (this.isShowing) {
                        updateDates(this.el, this._opts);
                    }

                    this.gotoDate(date);
                },

                setDateRange: function (start, end, preventOnSelect) {
                    if (this._opts.singleDate) {
                        return;
                    }
                    this.setStartDate(start, true);
                    this.setEndDate(end, true);

                    if (this.isShowing) {
                        updateDates(this.el, this._opts);
                    }

                    if (!preventOnSelect && typeof this._opts.onSelect === 'function') {
                        this._opts.onSelect.call(this, this.getStartDate(), this.getEndDate());
                    }
                },

                setDisableDates: function (dates) {
                    this._opts.disableDates = dates;

                    if (this.isShowing) {
                        updateDates(this.el, this._opts);
                    }
                },

                getStartDate: function () {
                    return moment(this._opts.startDate).isValid() ? this._opts.startDate : null;
                },

                getEndDate: function () {
                    return moment(this._opts.endDate).isValid() ? this._opts.endDate : null;
                },

                getDate: function () {
                    return moment(this._opts.startDate).isValid() ? this._opts.startDate : null;
                },

                toString: function (format) {
                    if (this._opts.singleDate) {
                        return moment(this._opts.startDate).isValid() ? this._opts.startDate.format(format) : '';
                    }

                    if (moment(this._opts.startDate).isValid() && moment(this._opts.endDate).isValid()) {
                        return this._opts.startDate.format(format) + this._opts.separator + this._opts.endDate.format(format);
                    }

                    if (moment(this._opts.startDate).isValid() && !moment(this._opts.endDate).isValid()) {
                        return this._opts.startDate.format(format) + this._opts.separator + '...';
                    }

                    if (!moment(this._opts.startDate).isValid() && moment(this._opts.endDate).isValid()) {
                        return '...' + this._opts.separator + this._opts.endDate.format(format);
                    }

                    return '';
                },

                show: function (target) {
                    if (!this.isShowing) {
                        this.isShowing = true;

                        if (this._opts.repick) {
                            this._opts.repickTrigger = target;
                        }

                        this.syncFields();

                        if (this._opts.secondField && this._opts.secondField === target && this._opts.endDate) {
                            this.gotoDate(this._opts.endDate);
                        }
                        else {
                            this.gotoDate(this._opts.startDate);
                        }

                        document.addEventListener('click', this._onClick);

                        this.updatePosition();

                        this.el.classList.remove('is-hidden');

                        if (typeof this._opts.onOpen === 'function') {
                            this._opts.onOpen.call(this);
                        }

                        if (document.activeElement && document.activeElement != document.body) {
                            document.activeElement.blur();
                        }
                    }
                },

                hide: function () {
                    if (this.isShowing) {
                        this.isShowing = false;

                        document.removeEventListener('click', this._onClick);

                        this.el.classList.add('is-hidden');

                        this.el.querySelector('.lightpick__tooltip').style.visibility = 'hidden';

                        if (typeof this._opts.onClose === 'function') {
                            this._opts.onClose.call(this);
                        }
                    }
                },

                destroy: function () {
                    var opts = this._opts;

                    this.hide();

                    this.el.removeEventListener('mousedown', self._onMouseDown, true);
                    this.el.removeEventListener('mouseenter', self._onMouseEnter, true);
                    this.el.removeEventListener('touchend', self._onMouseDown, true);
                    this.el.removeEventListener('change', self._onChange, true);

                    opts.field.removeEventListener('change', this._onInputChange);
                    opts.field.removeEventListener('click', this._onInputClick);
                    opts.field.removeEventListener('focus', this._onInputFocus);

                    if (opts.secondField) {
                        opts.secondField.removeEventListener('change', this._onInputChange);
                        opts.secondField.removeEventListener('click', this._onInputClick);
                        opts.secondField.removeEventListener('focus', this._onInputFocus);
                    }

                    if (this.el.parentNode) {
                        this.el.parentNode.removeChild(this.el);
                    }
                },

                reset: function () {
                    this.setStartDate(null, true);
                    this.setEndDate(null, true);

                    updateDates(this.el, this._opts);

                    if (typeof this._opts.onSelect === 'function') {
                        this._opts.onSelect.call(this, this.getStartDate(), this.getEndDate());
                    }

                    this.el.querySelector('.lightpick__tooltip').style.visibility = 'hidden';
                },

                reloadOptions: function (options) {
                    this._opts = Object.assign({}, this._opts, options);
                }

            };

            return Lightpick;
        }));

    </script>
    <style>
        .lightpick {
            position: absolute;
            z-index: 99999;
            padding: 4px;
            border-radius: 4px;
            background-color: #FFF;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
            color: #000;
            font-family: system-ui, Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.125em;
        }

        .lightpick--inlined {
            position: relative;
            display: inline-block;
        }

        .lightpick,
        .lightpick *,
        .lightpick::after,
        .lightpick::before {
            box-sizing: border-box;
        }

            .lightpick.is-hidden {
                display: none;
            }

        .lightpick__months {
            display: grid;
            background-color: #EEE;
            grid-template-columns: auto;
            grid-gap: 1px;
        }

        .lightpick--2-columns .lightpick__months {
            grid-template-columns: auto auto;
        }

        .lightpick--3-columns .lightpick__months {
            grid-template-columns: auto auto auto;
        }

        .lightpick--4-columns .lightpick__months {
            grid-template-columns: auto auto auto auto;
        }

        .lightpick--5-columns .lightpick__months {
            grid-template-columns: auto auto auto auto auto;
        }

        .lightpick__month {
            padding: 4px;
            width: 288px;
            background-color: #FFF;
        }

        .lightpick__month-title-bar {
            display: flex;
            margin-bottom: 4px;
            justify-content: space-between;
            align-items: center;
        }

        .lightpick__month-title {
            margin-top: 4px;
            margin-bottom: 4px;
            margin-left: 4px;
            font-size: 16px;
            font-weight: normal;
            line-height: 24px;
            cursor: default;
            padding: 0 4px;
            border-radius: 4px;
        }

            .lightpick__month-title > .lightpick__select {
                border: none;
                background-color: transparent;
                outline: none;
                -moz-appearance: none;
                -webkit-appearance: none;
                appearance: none;
            }

                .lightpick__month-title > .lightpick__select:disabled {
                    color: #333;
                }

            .lightpick__month-title > .lightpick__select-months {
                font-weight: bold;
                font-size: 1em;
                margin-right: .5em;
            }

        .lightpick__toolbar {
            display: flex;
            text-align: right;
            justify-content: flex-end;
        }

        .lightpick__previous-action,
        .lightpick__next-action,
        .lightpick__close-action {
            display: flex;
            margin-left: 6px;
            width: 32px;
            height: 32px;
            outline: none;
            border: none;
            border-radius: 50%;
            background-color: #DDD;
            justify-content: center;
            align-items: center;
        }

        .lightpick__previous-action,
        .lightpick__next-action {
            font-size: 12px;
        }

        .lightpick__close-action {
            font-size: 18px;
        }

            .lightpick__previous-action:active,
            .lightpick__next-action:active,
            .lightpick__close-action:active {
                color: inherit;
            }

        .lightpick__days-of-the-week {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }

        .lightpick__day-of-the-week {
            display: flex;
            font-size: 11px;
            font-weight: bold;
            justify-content: center;
            align-items: center;
        }

        .lightpick__days {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }

        .lightpick__day {
            display: flex;
            height: 40px;
            background-position: center center;
            background-size: contain;
            background-repeat: no-repeat;
            font-size: 13px;
            justify-content: center;
            align-items: center;
            cursor: default;
        }

            .lightpick__day.is-today {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='rgba(220, 50, 47, .5)' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
                background-size: 18.8% auto;
                background-position: center bottom;
                color: #DC322F;
            }

            .lightpick__day:not(.is-disabled):hover {
                background-size: contain;
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='%23E0E0E0' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
            }

            .lightpick__day.is-disabled {
                opacity: 0.38;
                pointer-events: none;
            }

            .lightpick__day.disabled-tooltip {
                pointer-events: auto;
            }

            .lightpick__day.is-disabled.is-forward-selected {
                opacity: 1;
            }

                .lightpick__day.is-disabled.is-forward-selected:not(.is-start-date) {
                    background-color: rgba(38, 139, 210, 0.1);
                    background-image: none;
                }

            .lightpick__day.is-previous-month,
            .lightpick__day.is-next-month {
                opacity: 0.38;
            }

            .lightpick__day.lightpick__day.is-in-range:not(.is-disabled) {
                opacity: 1;
            }

            .lightpick__day.is-in-range {
                border-radius: 0;
                background-color: rgba(38, 139, 210, 0.1);
                background-image: none;
            }

                .lightpick__day.is-in-range:hover {
                    background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='rgba(38, 139, 210, 0.5)' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
                }

            .lightpick__day.is-start-date.is-in-range,
            .lightpick__day.is-end-date.is-in-range.is-flipped {
                border-top-left-radius: 50%;
                border-top-right-radius: 0;
                border-bottom-right-radius: 0;
                border-bottom-left-radius: 50%;
                background-color: #268BD2;
                background-image: none;
            }

                .lightpick__day.is-end-date.is-in-range,
                .lightpick__day.is-start-date.is-in-range.is-flipped {
                    border-top-left-radius: 0;
                    border-top-right-radius: 50%;
                    border-bottom-right-radius: 50%;
                    border-bottom-left-radius: 0;
                    background-color: #268BD2;
                    background-image: none;
                }

            .lightpick__day.is-start-date.is-end-date {
                background-color: transparent;
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='%23268BD2' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
            }

            .lightpick__day.is-start-date,
            .lightpick__day.is-end-date,
            .lightpick__day.is-start-date:hover,
            .lightpick__day.is-end-date:hover {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='%23268BD2' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
                background-size: auto;
                background-position: center;
                color: #FFF;
                font-weight: bold;
            }

        .lightpick__tooltip {
            position: absolute;
            margin-top: -4px;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #FFF;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
            white-space: nowrap;
            font-size: 11px;
            pointer-events: none;
        }

            .lightpick__tooltip::before {
                position: absolute;
                bottom: -5px;
                left: calc(50% - 5px);
                border-top: 5px solid rgba(0, 0, 0, 0.12);
                border-right: 5px solid transparent;
                border-left: 5px solid transparent;
                content: "";
            }

            .lightpick__tooltip::after {
                position: absolute;
                bottom: -4px;
                left: calc(50% - 4px);
                border-top: 4px solid #FFF;
                border-right: 4px solid transparent;
                border-left: 4px solid transparent;
                content: "";
            }

        .lightpick__footer {
            display: flex;
            justify-content: space-between;
        }

        .lightpick__reset-action,
        .lightpick__apply-action {
            border-radius: 5px;
            font-size: 12px;
            border: none;
        }

        .lightpick__reset-action {
            color: #fff;
            background-color: #aeacad;
        }

        .lightpick__apply-action {
            color: #fff;
            background-color: #2495f3;
        }
    </style>

    <!-- Timecharts -->
    <script>
        (function webpackUniversalModuleDefinition(root, factory) {
            if (typeof exports === 'object' && typeof module === 'object')
                module.exports = factory();
            else if (typeof define === 'function' && define.amd)
                define([], factory);
            else if (typeof exports === 'object')
                exports["TimeCharts"] = factory();
            else
                root["TimeCharts"] = factory();
        })(window, function () {
            return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
                        /******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
                        /******/
};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
                    /******/
}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
                        /******/
}
                    /******/
};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                        /******/
}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
                    /******/
};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
                    /******/
};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
                    /******/
};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
                /******/
})
/************************************************************************/
/******/({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/index.css":
/*!*************************************************************!*\
      !*** ./node_modules/css-loader/dist/cjs.js!./src/index.css ***!
      \*************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                            eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \".time-chart-tooltip {\\r\\n    background-color: black;\\r\\n    color: #fff;\\r\\n    text-align: center;\\r\\n    padding: 8px;\\r\\n    border-radius: 3px;\\r\\n    z-index: 1;\\r\\n    opacity: 0.8;\\r\\n    font-size: 11pt;\\r\\n    font-family: Robot;\\r\\n}\\r\\n\\r\\n.time-chart-tooltip::after {\\r\\n    content: \\\" \\\";\\r\\n    position: absolute;\\r\\n    top: 100%; /* At the bottom of the tooltip */\\r\\n    left: 50%;\\r\\n    margin-left: -5px;\\r\\n    border-width: 5px;\\r\\n    border-style: solid;\\r\\n    border-color: black transparent transparent transparent;\\r\\n    opacity: 0.8;\\r\\n}\", \"\"]);\n\n\n//# sourceURL=webpack://TimeCharts/./src/index.css?./node_modules/css-loader/dist/cjs.js");

                            /***/
}),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
      !*** ./node_modules/css-loader/dist/runtime/api.js ***!
      \*****************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                            "use strict";
                            eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \"{\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\".concat(item[2], \") and (\").concat(mediaQuery, \")\");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot).concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack://TimeCharts/./node_modules/css-loader/dist/runtime/api.js?");

                            /***/
}),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
      !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
      \****************************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                            "use strict";
                            eval("\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};\n\n//# sourceURL=webpack://TimeCharts/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

                            /***/
}),

/***/ "./src/index.css":
/*!***********************!*\
      !*** ./src/index.css ***!
      \***********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

                            eval("var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/index.css\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\n\n//# sourceURL=webpack://TimeCharts/./src/index.css?");

                            /***/
}),

/***/ "./src/index.js":
/*!**********************!*\
      !*** ./src/index.js ***!
      \**********************/
/*! exports provided: Barchart, Timeline */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

                            "use strict";
                            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Barchart\", function() { return Barchart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Timeline\", function() { return Timeline; });\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"./src/index.css\");\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_index_css__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n/**\r\n * A module to visualize time-related data.\r\n * @module TimeCharts\r\n */\n///// PRIVATE HELPERS /////\n\n/**\r\n * Sets multiple attributes for a dom element.\r\n * @private\r\n * @param {Object} obj - the dom element\r\n * @param {Object} params - the attributes to be set\r\n */\n\nfunction setAttributes(obj, params) {\n  for (var _i = 0, _Object$entries = Object.entries(params); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (key === \"class\") {\n      var _obj$classList;\n\n      (_obj$classList = obj.classList).add.apply(_obj$classList, _toConsumableArray(value));\n    } else {\n      obj.setAttribute(key, value);\n    }\n  }\n}\n/**\r\n * Removes all child elements from a DOM element.\r\n * @private\r\n * @param {Object} obj - the dom element\r\n */\n\n\nfunction clear(obj) {\n  while (obj.firstChild) {\n    obj.removeChild(obj.firstChild);\n  }\n}\n/**\r\n * Merges an object into another one.\r\n * @private\r\n * @param {Object} obj - the object into which to merge \r\n * @param {Object} merger - the object to merge \r\n * @param {boolean} [overwrite = false] - whether to overwrite the original value of it exists\r\n */\n\n\nfunction mergeObjects(obj, merger, overwrite) {\n  overwrite = overwrite === true; // defaults to false\n\n  for (var _i2 = 0, _Object$keys = Object.keys(merger); _i2 < _Object$keys.length; _i2++) {\n    var key = _Object$keys[_i2];\n\n    if (!(key in obj)) {\n      obj[key] = merger[key];\n    } else if (_typeof(merger[key]) === \"object\") {\n      mergeObjects(obj[key], merger[key], overwrite);\n    } else if (overwrite) {\n      obj[key] = merger[key];\n    }\n  }\n}\n\nvar Draw =\n/*#__PURE__*/\nfunction () {\n  function Draw() {\n    _classCallCheck(this, Draw);\n  }\n\n  _createClass(Draw, null, [{\n    key: \"svg\",\n\n    /**\r\n     * Creates an svg object.\r\n     * @private\r\n     * @param {number|string} width - width of the svg\r\n     * @param {number|string} height - height of the svg\r\n     * @param {number} vbWidth - width of the viewbox\r\n     * @param {number} vbHeight - height of the viewbox\r\n     * @param {Object} [options] - additional attributes for the svg\r\n     * @returns {Object} - svg object\r\n     */\n    value: function svg(width, height, vbWidth, vbHeight, options) {\n      var svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      setAttributes(svg, {\n        width: width,\n        height: height,\n        viewBox: \"0 0 \" + vbWidth + \" \" + vbHeight,\n        preserveAspectRatio: \"none\"\n      });\n      setAttributes(svg, options || {});\n      return svg;\n    }\n    /**\r\n     * Draws an svg rectangle.\r\n     * @private\r\n     * @param {number} x - x-coordinate\r\n     * @param {number} y - y-coordinate\r\n     * @param {number} width - width of the rectangle\r\n     * @param {number} height - height of the rectangle\r\n     * @param {string} color - the fill color of the rectangle\r\n     * @param {Object} [options] additional attributes for the rectangle\r\n     * @returns {Object} - svg rectangle\r\n     */\n\n  }, {\n    key: \"rect\",\n    value: function rect(x, y, width, height, color, options) {\n      var rect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      setAttributes(rect, {\n        width: width,\n        height: height,\n        x: x,\n        y: y,\n        fill: color\n      });\n      setAttributes(rect, options || {});\n      return rect;\n    }\n    /**\r\n     * Draws an svg line.\r\n     * @private\r\n     * @param {number} x1 - x-coordinate where the line begins\r\n     * @param {number} y1 - y-coordinate where the line begins\r\n     * @param {number} x2 - x-coordinate where the line ends\r\n     * @param {number} y2 - y-coordinate where the line begins\r\n     * @param {string} color - color of the line\r\n     * @param {number} width - width of the line\r\n     * @param {Object} [options] - additional attributes for the line\r\n     * @returns {Object} - svg line\r\n     */\n\n  }, {\n    key: \"line\",\n    value: function line(x1, y1, x2, y2, color, width, options) {\n      var line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n      setAttributes(line, {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        stroke: color,\n        \"stroke-width\": width\n      });\n      setAttributes(line, options || {});\n      return line;\n    }\n    /**\r\n     * Draws an svg path.\r\n     * @private\r\n     * @param {string} shape - the shape of the path \r\n     * @param {string} color - the color of the path\r\n     * @param {Object} [options] - additional attributes for the path\r\n     * @returns {Object} - svg path\r\n     */\n\n  }, {\n    key: \"path\",\n    value: function path(shape, color, options) {\n      var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n      setAttributes(path, {\n        d: shape,\n        fill: color\n      });\n      setAttributes(path, options || {});\n      return path;\n    }\n    /**\r\n     * Draws an svg text.\r\n     * @private\r\n     * @param {number} x - x-coordinate of the top right left corner of the text\r\n     * @param {number} y - y-coordinate of the top right left corner of the text\r\n     * @param {string} content - the text that is displayed\r\n     * @param {string} color - the text color\r\n     * @param {string} [font = 'Roboto'] - the font name\r\n     * @param {Object} [options] - additional attributes for the text\r\n     * @returns {Object} - svg text\r\n     */\n\n  }, {\n    key: \"text\",\n    value: function text(x, y, content, color, font, options) {\n      color = color || \"black\";\n      font = font || 'Roboto';\n      var text = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      setAttributes(text, {\n        x: x,\n        y: y,\n        \"font-size\": \"14px\",\n        fill: color,\n        stroke: \"none\",\n        \"font-family\": font,\n        \"text-anchor\": \"middle\",\n        \"class\": [\"static\"]\n      });\n      setAttributes(text, options || {});\n      text.appendChild(document.createTextNode(content));\n      return text;\n    }\n    /**\r\n     * Creates an svg group.\r\n     * @private\r\n     * @returns {Object} - svg group\r\n     */\n\n  }, {\n    key: \"group\",\n    value: function group() {\n      return document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    }\n  }]);\n\n  return Draw;\n}(); ///// PUBLIC FUNCTIONS /////\n\n/**\r\n * Creates a bar chart\r\n * @class\r\n */\n\n\nvar Barchart =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Constructs a bar chart\r\n   * @constructor\r\n   * @param {string} element - css query selector of the container dom element into which the chart is placed.\r\n   * @param {Object} [params] - options\r\n   * @param {Object} [params.barSize = 25] - the size of a bar in px.\r\n   * @param {array} [params.data] - the data to be displayed.\r\n   * @param {string[]} [params.data.labels] - the labels underneath each bar.\r\n   * @param {Object[]} [params.data.datasets] - each dataset represents one \"block\" of a bar. To create a stacked bar chart have multiple datasets.\r\n   * @param {number[]} params.data.datasets[].values - the values for each \"block\" of a bar. Should be between 0 and 1. \r\n   * @param {string} [params.data.datasets[].title] - the title for the dataset.\r\n   * @param {Object} [params.padding] - padding in all directions of the chart.\r\n   * @param {number|string} [params.padding.top] - top padding for the chart.\r\n   * @param {number|string} [params.padding.right] - right padding for the chart.\r\n   * @param {number|string} [params.padding.bottom] - bottom padding for the chart.\r\n   * @param {number|string} [params.padding.left] - left padding for the chart.\r\n   * @param {string} [params.colors = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc']] - the colors for each bar.\r\n   * @param {'vertical' | 'horizontal'} [params.orientation = 'vertical'] - orientation for the chart.\r\n   * @param {string} [params.font = 'Roboto'] - the font for all writing. Font must be imported separately.\r\n   * @param {boolean} [params.hover = true] - whether the titles should be shown on hover or not.\r\n   * @param {'variable' | number} [params.distance = 'variable'] - whether the distance between timelines should be variable (based on svg size) or a fixed number of px.\r\n   * @param {boolean} [params.adjustSize = false] - whether the size of the container should be adjusted based on the needed space. Only works if params.distance != 'variable'.\r\n   * @throws Will throw an error if the container element is not found.\r\n   */\n  function Barchart(element, params) {\n    var _this = this;\n\n    _classCallCheck(this, Barchart);\n\n    this.container = document.querySelector(element);\n\n    if (this.container == null) {\n      console.error(\"Container for chart does not exist\");\n      return;\n    } // Extract parameters and sets defaults if parameters not available\n\n\n    mergeObjects(params, {\n      data: {\n        labels: [],\n        datasets: []\n      },\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      colors: ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc'],\n      orientation: \"vertical\",\n      font: \"Roboto\",\n      hover: true,\n      barSize: 25,\n      distance: 'variable',\n      adjustSize: false\n    });\n    this.data = params.data;\n    this.padding = params.padding;\n    this.colors = params.colors;\n    this.orientation = params.orientation;\n    this.font = params.font;\n    this.hover = params.hover;\n    this.barSize = params.barSize;\n    this.distance = params.distance;\n    this.adjustSize = this.distance !== 'variable' && params.adjustSize;\n\n    if (this.orientation !== \"horizontal\") {\n      this.drawVertical();\n      window.addEventListener('resize', function () {\n        _this.drawVertical();\n      });\n    } else {\n      this.drawHorizontal();\n      window.addEventListener('resize', function () {\n        _this.drawHorizontal();\n      });\n    }\n  }\n  /**\r\n   * Draws a vertical chart\r\n   * @private\r\n   */\n\n\n  _createClass(Barchart, [{\n    key: \"drawVertical\",\n    value: function drawVertical() {\n      var _this2 = this;\n\n      var realHeight = this.container.clientHeight - this.padding.top - this.padding.bottom;\n      var viewboxHeightScale = 100 / realHeight;\n      var barCount = this.data.datasets.reduce(function (p, c) {\n        return Math.max(p, c.values.length);\n      }, 0);\n      var barWidth = this.barSize;\n      var barHeight = 100 - 25 * viewboxHeightScale;\n\n      if (this.adjustSize) {\n        var width = (barWidth + this.distance) * barCount + this.padding.left + this.padding.right;\n        this.container.style.width = \"\".concat(width, \"px\");\n      }\n\n      var realWidth = this.container.clientWidth - this.padding.right - this.padding.left;\n      var viewboxWidthScale = realWidth / 100;\n      var barSpacing = this.distance === 'variable' ? 100 * viewboxWidthScale / barCount - barWidth : this.distance;\n      this.svg = Draw.svg(\"calc(100% - \".concat(this.padding.right + this.padding.left, \"px)\"), \"calc(100% - \".concat(this.padding.top + this.padding.bottom, \"px)\"), 100 * viewboxWidthScale, 100); // Padding\n\n      this.svg.style.paddingTop = this.padding.top;\n      this.svg.style.paddingRight = this.padding.right;\n      this.svg.style.paddingBottom = this.padding.bottom;\n      this.svg.style.paddingLeft = this.padding.left;\n      this.svg.style.boxSizing = \"initial\"; // Draw data\n\n      for (var i = 0; i < barCount; i++) {\n        var label = this.data.labels[i] || \"\";\n        var rx = barWidth / 2;\n        var ry = barWidth / 2 * viewboxHeightScale;\n        var background = Draw.path(\"M \".concat((i + 0.5) * barSpacing + i * barWidth, \",\", 0, \" m 0, \").concat(barHeight - ry, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 \").concat(barWidth, \",0 v \").concat(ry * 2 - barHeight, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 \").concat(-barWidth, \",0 z\"), \"#E3E6E9\");\n        this.svg.appendChild(background);\n        var y = 0; // height of the bar. Contains the position at which to draw the next rectangle\n\n        var _loop = function _loop(j) {\n          var value = _this2.data.datasets[j].values[i] || 0;\n          var title = _this2.data.datasets[j].title || \"\";\n          var foreground = void 0;\n\n          if (_this2.data.datasets.length === 1) {\n            // single element\n            foreground = Draw.path(\"M \".concat((i + 0.5) * barSpacing + i * barWidth, \",\").concat(barHeight - y - ry, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 \").concat(barWidth, \",0 v \").concat(ry * 2 - barHeight * value, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 \").concat(-barWidth, \",0 z\"), _this2.colors[j % _this2.colors.length]);\n          } else if (y === 0) {\n            // First element\n            foreground = Draw.path(\"M \".concat((i + 0.5) * barSpacing + i * barWidth, \",\").concat(barHeight - y - ry, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 \").concat(barWidth, \",0 v \").concat(ry - barHeight * value, \" h \").concat(-barWidth, \" z\"), _this2.colors[j % _this2.colors.length]);\n          } else if (y + barHeight * value === barHeight || j === _this2.data.datasets.length - 1) {\n            // Last element\n            foreground = Draw.path(\"M \".concat((i + 0.5) * barSpacing + i * barWidth, \",\").concat(barHeight - y, \" h \").concat(barWidth, \" v \").concat(ry - barHeight * value, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 \").concat(-barWidth, \",0 z\"), _this2.colors[j % _this2.colors.length]);\n          } else {\n            // element in the middle\n            foreground = Draw.path(\"M \".concat((i + 0.5) * barSpacing + i * barWidth, \",\").concat(barHeight - y, \" h \").concat(barWidth, \" v \").concat(-barHeight * value, \" h \").concat(-barWidth, \" z\"), _this2.colors[j % _this2.colors.length]);\n          }\n\n          if (_this2.hover) {\n            foreground.addEventListener('mouseenter', function (evt) {\n              _this2.showTooltip(true, foreground, value, title);\n            });\n            foreground.addEventListener(\"mouseleave\", function (evt) {\n              _this2.showTooltip(false);\n            });\n          }\n\n          if (y < barHeight) {\n            // only draw the part if it would not overshoot\n            _this2.svg.appendChild(foreground);\n          }\n\n          y = y + barHeight * value;\n        };\n\n        for (var j = 0; j < this.data.datasets.length; j++) {\n          _loop(j);\n        }\n\n        var text = Draw.text((i + 0.5) * (barSpacing + barWidth), barHeight + 20 * viewboxHeightScale, label, \"black\", this.font);\n        text.setAttribute(\"transform\", \"scale(1,\".concat(viewboxHeightScale, \") translate(0, \").concat(parseFloat(text.getAttribute(\"y\")) / viewboxHeightScale - parseFloat(text.getAttribute(\"y\")), \")\"));\n        this.svg.appendChild(text);\n      }\n\n      clear(this.container);\n      this.tooltip = undefined;\n      this.container.appendChild(this.svg);\n    }\n    /**\r\n     * Draws a horizontal chart\r\n     * @private\r\n     */\n\n  }, {\n    key: \"drawHorizontal\",\n    value: function drawHorizontal() {\n      var _this3 = this;\n\n      var realWidth = this.container.clientWidth - this.padding.right - this.padding.left;\n      var viewboxWidthScale = 100 / realWidth;\n      var barCount = this.data.datasets.reduce(function (p, c) {\n        return Math.max(p, c.values.length);\n      }, 0);\n      var textWidth = this.data.labels.reduce(function (p, c) {\n        return Math.max(p, c.length > 0 ? (2 + c.length * 7.5) * viewboxWidthScale : 0);\n      }, 0); // 7.5 per char \n\n      var barWidth = 100 - textWidth;\n      var barHeight = this.barSize;\n\n      if (this.adjustSize) {\n        var height = (barCount + this.distance) * barHeight + this.padding.top + this.padding.bottom;\n        this.container.style.height = \"\".concat(height, \"px\");\n      }\n\n      var realHeight = this.container.clientHeight - this.padding.top - this.padding.bottom;\n      var viewboxHeightScale = realHeight / 100;\n      var barSpacing = this.distance === 'variable' ? 100 * viewboxHeightScale / barCount - barHeight : this.distance;\n      this.svg = Draw.svg(\"calc(100% - \".concat(this.padding.right + this.padding.left, \"px)\"), \"calc(100% - \".concat(this.padding.top + this.padding.bottom, \"px)\"), 100, 100 * viewboxHeightScale); // Padding\n\n      this.svg.style.paddingTop = this.padding.top;\n      this.svg.style.paddingRight = this.padding.right;\n      this.svg.style.paddingBottom = this.padding.bottom;\n      this.svg.style.paddingLeft = this.padding.left;\n      this.svg.style.boxSizing = \"initial\"; // Draw data\n\n      for (var i = 0; i < barCount; i++) {\n        var label = this.data.labels[i] || \"\";\n        var rx = barHeight / 2 * viewboxWidthScale;\n        var ry = barHeight / 2;\n        var background = Draw.path(\"M \".concat(textWidth + rx, \", \").concat((i + 0.5) * barSpacing + i * barHeight, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(barHeight, \" h \").concat(barWidth - rx * 2, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(-barHeight, \" z\"), \"#E3E6E9\");\n        this.svg.appendChild(background);\n        var x = 0; // width of the bar. Contains the position at which to draw the next rectangle\n\n        var _loop2 = function _loop2(j) {\n          var value = _this3.data.datasets[j].values[i] || 0;\n          var title = _this3.data.datasets[j].title || \"\";\n          var foreground = void 0;\n\n          if (_this3.data.datasets.length === 1) {\n            // single element\n            foreground = Draw.path(\"M \".concat(textWidth + x + rx, \",\").concat((i + 0.5) * barSpacing + i * barHeight, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(barHeight, \" h \").concat(barWidth * value - rx * 2, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(-barHeight, \" z\"), _this3.colors[j % _this3.colors.length]);\n          } else if (x === 0) {\n            // First element\n            foreground = Draw.path(\"M \".concat(textWidth + x + rx, \",\").concat((i + 0.5) * barSpacing + i * barHeight, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(barHeight, \" h \").concat(barWidth * value - rx, \" v \").concat(-barHeight, \" z\"), _this3.colors[j % _this3.colors.length]);\n          } else if (x + barWidth * value === barWidth || j === _this3.data.datasets.length - 1) {\n            // Last element\n            foreground = Draw.path(\"M \".concat(textWidth + x, \",\").concat((i + 0.5) * barSpacing + i * barHeight, \" v \").concat(barHeight, \" h \").concat(barWidth * value - rx, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(-barHeight, \" z\"), _this3.colors[j % _this3.colors.length]);\n          } else {\n            // element in the middle\n            foreground = Draw.path(\"M \".concat(textWidth + x, \", \").concat((i + 0.5) * barSpacing + i * barHeight, \" v \").concat(barHeight, \" h \").concat(barWidth * value, \" v \").concat(-barHeight, \" z\"), _this3.colors[j % _this3.colors.length]);\n          }\n\n          if (_this3.hover) {\n            foreground.addEventListener('mouseenter', function (evt) {\n              _this3.showTooltip(true, foreground, value, title);\n            });\n            foreground.addEventListener(\"mouseleave\", function (evt) {\n              _this3.showTooltip(false);\n            });\n          }\n\n          if (x < barWidth) {\n            // only draw the part if it would not overshoot\n            _this3.svg.appendChild(foreground);\n          }\n\n          x = x + barWidth * value;\n        };\n\n        for (var j = 0; j < this.data.datasets.length; j++) {\n          _loop2(j);\n        }\n\n        var text = Draw.text(0, (i + 0.5) * (barSpacing + barHeight), label, \"black\", this.font, {\n          \"text-anchor\": \"start\",\n          \"alignment-baseline\": \"central\"\n        });\n        text.setAttribute(\"transform\", \"scale(\".concat(viewboxWidthScale, \",1) translate(\").concat(parseFloat(text.getAttribute(\"x\")) / viewboxWidthScale - parseFloat(text.getAttribute(\"x\")), \", 0)\"));\n        this.svg.appendChild(text);\n      }\n\n      clear(this.container);\n      this.tooltip = undefined;\n      this.container.appendChild(this.svg);\n    }\n    /**\r\n     * Draws a tooltip at the horizontal center of the element\r\n     * @private\r\n     * @param {boolean} show - Whether to show or hide the tooltip\r\n     * @param {Object} g - the element on which the tooltip is centered\r\n     * @param {number|string} value - the value of the element\r\n     * @param {number|string} title - the title of the element\r\n     */\n\n  }, {\n    key: \"showTooltip\",\n    value: function showTooltip(show, g, value, title) {\n      if (this.tooltip === undefined) {\n        this.tooltip = document.createElement('div');\n        this.tooltip.style.display = \"block\";\n        this.tooltip.style.position = \"absolute\";\n        this.tooltip.style.fontFamily = this.font;\n        this.tooltip.classList.add('time-chart-tooltip');\n        this.tooltip.appendChild(document.createElement('span'));\n        this.container.appendChild(this.tooltip);\n      }\n\n      if (!show) {\n        this.tooltip.style.visibility = \"hidden\";\n        return;\n      }\n\n      clear(this.tooltip);\n      this.tooltip.innerHTML = \"<span style=\\\"color: gray\\\">\".concat(value, \"</span>\").concat(title !== \"\" ? \": \" + title : \"\");\n      this.tooltip.style.top = g.getBoundingClientRect().y - 43 + \"px\";\n      this.tooltip.style.left = \"calc(\".concat(g.getBoundingClientRect().x + g.getBoundingClientRect().width / 2 - this.tooltip.getBoundingClientRect().width / 2, \"px)\");\n      this.tooltip.style.visibility = \"visible\";\n    }\n    /**\r\n     * Replaces the existing data with new data.\r\n     * @param {array} [data] - the data to be displayed\r\n     * @param {string[]} [data.labels] - the labels underneath each bar\r\n     * @param {Object[]} [data.datasets] - each dataset represents one \"block\" of a bar. To create a stacked bar chart have multiple datasets.\r\n     * @param {number[]} data.datasets[].values - the values for each \"block\" of a bar. Should be between 0 and 1. \r\n     * @param {string} [data.datasets[].title] - the title for the dataset.\r\n     */\n\n  }, {\n    key: \"setDate\",\n    value: function setDate(data) {\n      this.data = data;\n      this.draw();\n    }\n  }]);\n\n  return Barchart;\n}();\n/**\r\n * Creates a timeline\r\n * @class\r\n */\n\n\nvar Timeline =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Constructs a timeline\r\n   * @constructor\r\n   * @param {string} element - css query selector of the container dom element into which the chart is placed.\r\n   * @param {Object} [params] - options.\r\n   * @param {Object} [params.lineHeight = 25] - the hight of a bar in a timeline in px.\r\n   * @param {Object} [params.scale] - options for the scale at the top of the timelines\r\n   * @param {number} [params.scale.from = 0] - the time in minutes at which the timeline should start.\r\n   * @param {number} [params.scale.to = 1440] - the time in minutes at which the timeline should end.\r\n   * @param {number} [params.scale.interval = 240] - the interval at which labels are shown on the scale.\r\n   * @param {number} [params.scale.intervalStart = 0] - the point at which the interval starts counting.\r\n   * @param {array} [params.data] - the data to be displayed.\r\n   * @param {Object[]} [params.data.timelines] - each object represents one timeline. For multiple timelines under each other, have multiple objects.\r\n   * @param {string} [params.data.timelines[].label] - the label to the right of the timeline.\r\n   * @param {Object[]} params.data.timelines[].values - the values (marked time slots).\r\n   * @param {number} params.data.timelines[].values[].start - the point at which the time slot starts in minutes.\r\n   * @param {number} params.data.timelines[].values[].length - the point at which the time slot ends in minutes.\r\n   * @param {string} [params.data.timelines[].values[].title] - the title of the time slot.\r\n   * @param {string[]} [params.data.timelines[].colors = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc']] - the colors for the timeline.\r\n   * @param {Object} [params.padding] - padding in all directions of the chart.\r\n   * @param {number|string} [params.padding.top] - top padding for the chart.\r\n   * @param {number|string} [params.padding.right] - right padding for the chart.\r\n   * @param {number|string} [params.padding.bottom] - bottom padding for the chart.\r\n   * @param {number|string} [params.padding.left] - left padding for the chart.\r\n   * @param {string} [params.font = 'Roboto'] - the font for all writing. Font must be imported separately.\r\n   * @param {boolean} [params.hover = true] - whether the titles should be shown on hover or not.\r\n   * @param {boolean} [params.legend = true] - whether a legend should be shown underneath the timelines.\r\n   * @param {number} [params.legendDistance = 15] - distance from the last timeline to the legend in px. Always set to 0 if params.legend === false.\r\n   * @param {'variable' | number} [params.distance = 'variable'] - whether the distance between timelines should be variable (based on svg size) or a fixed number of px.\r\n   * @param {boolean} [params.adjustSize = false] - whether the size of the container should be adjusted based on the needed space. Only works if params.distance != 'variable'.\r\n   * @throws Will throw an error if the container element is not found.\r\n   */\n  function Timeline(element, params) {\n    var _this4 = this;\n\n    _classCallCheck(this, Timeline);\n\n    this.container = document.querySelector(element);\n\n    if (this.container == null) {\n      console.error(\"Container for chart does not exist\");\n      return;\n    } // Extract parameters and sets defaults if parameters not available\n\n\n    mergeObjects(params, {\n      scale: {\n        from: 0,\n        to: 1440,\n        interval: 240,\n        intervalStart: 0\n      },\n      data: {\n        timelines: []\n      },\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      font: \"Roboto\",\n      hover: true,\n      legend: true,\n      legendDistance: 15,\n      lineHeight: 25,\n      distance: 'variable',\n      adjustSize: false\n    });\n    this.scale = params.scale;\n    this.data = params.data;\n    this.padding = params.padding;\n    this.font = params.font;\n    this.hover = params.hover;\n    this.legend = params.legend;\n    this.legendDistance = params.legendDistance;\n    this.lineHeight = params.lineHeight;\n    this.distance = params.distance;\n    this.adjustSize = this.distance !== 'variable' && params.adjustSize;\n    this.draw();\n    window.addEventListener('resize', function () {\n      _this4.draw();\n    });\n  }\n  /**\r\n   * Draws the timeline\r\n   * @private\r\n   */\n\n\n  _createClass(Timeline, [{\n    key: \"draw\",\n    value: function draw() {\n      var _this5 = this;\n\n      var realWidth = this.container.clientWidth - this.padding.right - this.padding.left;\n      var viewboxWidthScale = 100 / realWidth;\n      var lineCount = this.data.timelines.length;\n      var textWidth1 = this.data.timelines.reduce(function (p, c) {\n        return Math.max(p, c.label.length > 0 ? (40 + c.label.length * 7.5) * viewboxWidthScale : 0);\n      }, 0); // 7.5 per char \n\n      var textWidth2 = this.data.timelines.reduce(function (p, c) {\n        return Math.max(p, c.values.reduce(function (p, c) {\n          return Math.max(p, (10 + _this5.formatMinutes(c.length).length * 7.5) * viewboxWidthScale);\n        }, 0));\n      }, 0); // 7.5 per char\n\n      var widthLeft = Math.max(textWidth1 + textWidth2, 20 * viewboxWidthScale);\n      var widthRight = 20 * viewboxWidthScale;\n      var scaleHeight = 20;\n      var lineWidth = 100 - widthLeft - widthRight;\n      var lineHeight = this.lineHeight;\n      var legendHeight = this.legend ? lineHeight : 0;\n      var legendSpacing = this.legend ? this.legendDistance : 0;\n\n      if (this.adjustSize) {\n        var height = scaleHeight + legendHeight + legendSpacing + lineCount * (lineHeight + this.distance) + this.padding.top + this.padding.bottom;\n        this.container.style.height = \"\".concat(height, \"px\");\n      }\n\n      var realHeight = this.container.clientHeight - this.padding.top - this.padding.bottom;\n      var viewboxHeightScale = realHeight / 100;\n      var lineSpacing = this.distance === 'variable' ? (100 * viewboxHeightScale - scaleHeight - legendHeight - legendSpacing) / lineCount - lineHeight : this.distance;\n      var scaleStart = Math.max(0.5 * lineSpacing - scaleHeight, 0);\n      this.svg = Draw.svg(\"calc(100% - \".concat(this.padding.right + this.padding.left, \"px)\"), \"calc(100% - \".concat(this.padding.top + this.padding.bottom, \"px)\"), 100, 100 * viewboxHeightScale); // Padding\n\n      this.svg.style.paddingTop = this.padding.top;\n      this.svg.style.paddingRight = this.padding.right;\n      this.svg.style.paddingBottom = this.padding.bottom;\n      this.svg.style.paddingLeft = this.padding.left;\n      this.svg.style.boxSizing = \"initial\"; // Draw scale\n\n      var from = this.scale.from;\n      var to = this.scale.to;\n      var interval = this.scale.interval;\n      var intervalStart = this.scale.intervalStart / (to - from) * lineWidth;\n      var intervalSteps = Math.floor((to - from) / interval);\n      var intervalStepsWidth = lineWidth / intervalSteps;\n\n      for (var i = 0; i <= intervalSteps; i++) {\n        var text = Draw.text(widthLeft + intervalStart + i * intervalStepsWidth, scaleStart, this.formatMinutes2(from + this.scale.intervalStart + i * interval), \"black\", this.font, {\n          \"text-anchor\": \"middle\",\n          \"alignment-baseline\": \"text-before-edge\"\n        });\n        text.setAttribute(\"transform\", \"scale(\".concat(viewboxWidthScale, \",1) translate(\").concat(parseFloat(text.getAttribute(\"x\")) / viewboxWidthScale - parseFloat(text.getAttribute(\"x\")), \", 0)\"));\n        this.svg.appendChild(text);\n      }\n\n      var x = 0; // Draw data\n\n      var _loop3 = function _loop3(_i3) {\n        var label = _this5.data.timelines[_i3].label || \"\";\n        var values = _this5.data.timelines[_i3].values || [];\n        var colors = _this5.data.timelines[_i3].colors || ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc'];\n        var valueMap = {}; // Helper to calculate grouped values and store color codes\n\n        var sum = _this5.data.timelines[_i3].values.reduce(function (p, c) {\n          return p + c.length;\n        }, 0);\n\n        var rx = lineHeight / 2 * viewboxWidthScale;\n        var ry = lineHeight / 2; // Draw background\n        // Gray background\n\n        var background = Draw.path(\"M \".concat(widthLeft + rx, \", \").concat(scaleStart + scaleHeight + _i3 * (lineSpacing + lineHeight), \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(lineHeight, \" h \").concat(lineWidth - rx * 2, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(-lineHeight, \" z\"), \"#E3E6E9\");\n\n        _this5.svg.appendChild(background); // White stripes each hour\n\n\n        var steps = (to - from) / 60;\n        var stepWidth = lineWidth / steps;\n\n        for (var j = 1; j < steps; j++) {\n          var rect = Draw.rect(widthLeft + j * stepWidth - 1 * viewboxWidthScale, scaleStart + scaleHeight + _i3 * (lineSpacing + lineHeight), 2 * viewboxWidthScale, lineHeight, \"white\");\n\n          _this5.svg.appendChild(rect);\n        } // Draw foreground\n\n\n        var _loop4 = function _loop4(_j) {\n          var relativeStart = Math.max(0, values[_j].start - from) / (to - from);\n          var relativeLength = Math.max(0, values[_j].start - from + values[_j].length) / (to - from);\n          var title = values[_j].title || \"\";\n          var color = \"\";\n\n          if (!(title in valueMap)) {\n            // sub-category has not be encountered before\n            color = colors[Object.keys(valueMap).length % colors.length];\n            valueMap[title] = {\n              color: color,\n              value: values[_j].length\n            };\n          } else {\n            color = valueMap[title].color;\n            valueMap[title].value = valueMap[title].value + values[_j].length;\n          }\n\n          var foreground = Draw.path(\"M \".concat(widthLeft + lineWidth * relativeStart + rx, \",\").concat(scaleStart + scaleHeight + _i3 * (lineSpacing + lineHeight), \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(lineHeight, \" h \").concat(lineWidth * (relativeLength - relativeStart) - rx * 2, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(-lineHeight, \" z\"), color);\n\n          _this5.svg.appendChild(foreground);\n\n          if (_this5.hover) {\n            foreground.addEventListener('mouseenter', function (evt) {\n              _this5.showTooltip(true, foreground, values[_j].start, values[_j].start + values[_j].length, title);\n            });\n            foreground.addEventListener(\"mouseleave\", function (evt) {\n              _this5.showTooltip(false);\n            });\n          }\n        };\n\n        for (var _j = 0; _j < values.length; _j++) {\n          _loop4(_j);\n        } // Draw label\n\n\n        var text = Draw.text(0.5 * textWidth1, scaleStart + scaleHeight + _i3 * lineSpacing + (_i3 + 0.5) * lineHeight, label, \"black\", _this5.font, {\n          \"text-anchor\": \"middle\",\n          \"alignment-baseline\": \"central\",\n          \"font-weight\": \"bold\"\n        });\n        text.setAttribute(\"transform\", \"scale(\".concat(viewboxWidthScale, \",1) translate(\").concat(parseFloat(text.getAttribute(\"x\")) / viewboxWidthScale - parseFloat(text.getAttribute(\"x\")), \", 0)\"));\n\n        _this5.svg.appendChild(text); // Draw sum\n\n\n        var text2 = Draw.text(textWidth1, scaleStart + scaleHeight + _i3 * lineSpacing + (_i3 + 0.5) * lineHeight, _this5.formatMinutes(sum), \"black\", _this5.font, {\n          \"text-anchor\": \"start\",\n          \"alignment-baseline\": \"central\"\n        });\n        text2.setAttribute(\"transform\", \"scale(\".concat(viewboxWidthScale, \",1) translate(\").concat(parseFloat(text2.getAttribute(\"x\")) / viewboxWidthScale - parseFloat(text2.getAttribute(\"x\")), \", 0)\"));\n\n        _this5.svg.appendChild(text2); // Draw legend\n\n\n        if (_this5.legend) {\n          for (var _i4 = 0, _Object$keys2 = Object.keys(valueMap); _i4 < _Object$keys2.length; _i4++) {\n            var key = _Object$keys2[_i4];\n            var content = \"\".concat(key, \" - \").concat(_this5.formatMinutes(valueMap[key].value));\n            var width = content.length * 7.5 * viewboxWidthScale + 2 * rx;\n            var legend = Draw.path(\"M \".concat(widthLeft + x + rx, \",\").concat(scaleStart + legendSpacing + scaleHeight + (lineCount - 1) * lineSpacing + lineCount * lineHeight, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(legendHeight, \" h \").concat(width - rx * 2, \" a \").concat(rx, \",\").concat(ry, \" 0 0 0 0,\").concat(-legendHeight, \" z\"), valueMap[key].color);\n\n            _this5.svg.appendChild(legend);\n\n            var _text = Draw.text(widthLeft + x + 0.5 * width, scaleStart + legendSpacing + legendHeight * 0.5 + scaleHeight + (lineCount - 1) * lineSpacing + lineCount * lineHeight, content, \"white\", _this5.font, {\n              \"text-anchor\": \"middle\",\n              \"alignment-baseline\": \"central\"\n            });\n\n            _text.setAttribute(\"transform\", \"scale(\".concat(viewboxWidthScale, \",1) translate(\").concat(parseFloat(_text.getAttribute(\"x\")) / viewboxWidthScale - parseFloat(_text.getAttribute(\"x\")), \", 0)\"));\n\n            _this5.svg.appendChild(_text);\n\n            x = x + width + 10 * viewboxWidthScale; // previous x, width of the rectangle and padding\n          }\n        }\n      };\n\n      for (var _i3 = 0; _i3 < lineCount; _i3++) {\n        _loop3(_i3);\n      }\n\n      clear(this.container);\n      this.tooltip = undefined;\n      this.container.appendChild(this.svg);\n    }\n    /**\r\n     * Converts a number of minutes into a string\r\n     * @private\r\n     * @param {number} minutes - the minutes\r\n     * @returns {string} - format: 4h 35m\r\n     */\n\n  }, {\n    key: \"formatMinutes\",\n    value: function formatMinutes(minutes) {\n      var h = Math.floor(minutes / 60);\n      var m = Math.floor(minutes % 60);\n\n      if (m === 0 && h === 0) {\n        return \"\";\n      } else if (m === 0) {\n        return \"\".concat(h, \"h\");\n      } else if (h === 0) {\n        return \"\".concat(m, \"m\");\n      }\n\n      {\n        return \"\".concat(h, \"h \").concat(m, \"m\");\n      }\n    }\n    /**\r\n     * Converts a number of minutes into a string\r\n     * @private\r\n     * @param {number} minutes - the minutes\r\n     * @returns {string} - format: 4:30 am\r\n     */\n\n  }, {\n    key: \"formatMinutes2\",\n    value: function formatMinutes2(minutes) {\n      var h = Math.floor(minutes / 60);\n      var ending = \"am\";\n      var m = Math.floor(minutes % 60);\n\n      if (h > 12) {\n        ending = \"pm\";\n        h = h - 12;\n      }\n\n      if (m === 0) {\n        return \"\".concat(h, \" \").concat(ending);\n      } else {\n        return \"\".concat(h, \":\").concat(m < 10 ? m + \"0\" : m, \" \").concat(ending);\n      }\n    }\n    /**\r\n     * Draws a tooltip at the horizontal center of the element\r\n     * @private\r\n     * @param {boolean} show - Whether to show or hide the tooltip\r\n     * @param {Object} g - the element on which the tooltip is centered\r\n     * @param {number} start - the start value in minutes\r\n     * @param {number} end - the vend value in minutes\r\n     * @param {number|string} title - the title of the element\r\n     */\n\n  }, {\n    key: \"showTooltip\",\n    value: function showTooltip(show, g, start, end, title) {\n      if (this.tooltip === undefined) {\n        this.tooltip = document.createElement('div');\n        this.tooltip.style.display = \"block\";\n        this.tooltip.style.position = \"absolute\";\n        this.tooltip.style.fontFamily = this.font;\n        this.tooltip.classList.add('time-chart-tooltip');\n        this.tooltip.appendChild(document.createElement('span'));\n        this.container.appendChild(this.tooltip);\n      }\n\n      if (!show) {\n        this.tooltip.style.visibility = \"hidden\";\n        return;\n      }\n\n      this.tooltip.style.top = g.getBoundingClientRect().y - 43 + \"px\";\n      clear(this.tooltip);\n      this.tooltip.innerHTML = \"<span style=\\\"color: gray\\\">\".concat(this.formatMinutes2(start), \" - \").concat(this.formatMinutes2(end), \"</span>\").concat(title !== \"\" ? \": \" + title : \"\");\n      this.tooltip.style.left = \"calc(\".concat(g.getBoundingClientRect().x + g.getBoundingClientRect().width / 2 - this.tooltip.getBoundingClientRect().width / 2, \"px)\");\n      this.tooltip.style.visibility = \"visible\";\n    }\n    /**\r\n     * Replaces the existing data with new data. \r\n     * @param {array} [params.data] - the data to be displayed.\r\n     * @param {Object[]} [params.data.timelines] - each object represents one timeline. For multiple timelines under each other, have multiple objects.\r\n     * @param {string} [params.data.timelines[].label] - the label to the right of the timeline.\r\n     * @param {Object[]} params.data.timelines[].values - the values (marked time slots).\r\n     * @param {number} params.data.timelines[].values[].start - the point at which the time slot starts in minutes.\r\n     * @param {number} params.data.timelines[].values[].length - the point at which the time slot ends in minutes.\r\n     * @param {string} [params.data.timelines[].values[].title] - the title of the time slot.\r\n     * @param {string[]} [params.data.timelines[].colors = ['#7cd6fd', '#5e64ff', '#743ee2', '#ff5858', '#ffa00a', '#feef72', '#28a745', '#98d85b', '#b554ff', '#ffa3ef', '#36114C', '#bdd3e6', '#f0f4f7', '#b8c2cc']] - the colors for the timeline.\r\n     * @param {Object} [params.padding] - padding in all directions of the chart.\r\n     */\n\n  }, {\n    key: \"setDate\",\n    value: function setDate(data) {\n      this.data = data;\n      this.draw();\n    }\n  }]);\n\n  return Timeline;\n}(); // attach properties to the exports object to define\n// the exported module properties.\n\n\n\n\n//# sourceURL=webpack://TimeCharts/./src/index.js?");

                            /***/
})

                    /******/
});
        });
    </script>


    <!-- Css (place under the other imports as it overrides styles from dependencies) -->
    <style>
            /* Color Scheme */

            html[dark_mode = "true"] {
                --highlight_color: rgb(38, 139, 210);
                --highlight_color_light: rgb(79, 155, 209);
                --highlight_color_dark: rgb(31, 100, 150);
                --color_very_dark: rgb(20, 20, 20);
                --color_dark: rgb(50, 50, 50);
                --color_ldark: rgb(80, 80, 80);
                --color_med: rgb(100, 100, 100);
                --color_llight: rgb(120, 120, 120);
                --color_light: rgb(160, 160, 160);
                --color_very_light: rgb(200, 200, 200);
                --default_text_color: white;
                --content_background: rgb(40, 40, 40);
                --menu_background: var(--color_dark);
                --default_border: var(--color_ldark);
                --default_hover_border: var(--color_light);
                --default_selected_border: white;
                --button_background: var(--color_ldark);
                --button_hover_background: var(--color_med);
                --input_border: var(--color_ldark);
                --input_hover_border: var(--color_med);
                --menu_item_background_b: var(--menu_background);
                --menu_item_background_a: var(--menu_background);
                --menu_item_background_hover: var(--color_ldark);
                --menu_item_background_active: var(--color_med);
                --menu_icon_description_text: var(--color_med);
                --setting_no: var(--color_med);
                --setting_hover: var(--color_light);
                --setting_yes: var(--color_very_light);
                --settings_slider_bar: var(--color_ldark);
                --settings_slider_thumb: var(--color_very_light);
                --daypicker_move_icon_default: var(--color_ldark);
                --daypicker_move_icon_hover: var(--color_light);
                --daypicker_move_icon_active: lightblue;
                --daypicker_selected_days_background: rgba(38, 139, 210, 0.5);
                --daypicker_day_hover: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='rgba(38, 139, 210, 0.5)' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
                --daypicker_buttons: var(--button_background);
                --daypicker_buttons_hover: var(--button_hover_background);
                --daypicker_tooltip_background: var(--color_ldark);
                --daypicker_tooltip_text: var(--default_text_color);
                --daypicker_background: var(--color_dark);
                --tag_text: var(--default_text_color);
                --tag_border: var(--color_very_light);
                --tag_close_hover: rgb(150, 150, 150);
                --disabled_font: var(--color_med);
                --selector_tag_l0: var(--color_dark);
                --selector_tag_l1: var(--color_dark);
                /* --table_header: rgb(40,40,40);
        --table_header_selected: rgb(80,80,80);
        --table_first_row: var(--table_header);
        --table_first_row_selected: var(--table_header_selected);
        --table_content: var(--content_background);
        --table_caret_color: rgb(240,240,240);
        --table_highlight_selected: black; */
            }

            html[dark_mode = "false"] {
                --highlight_color: rgb(105, 183, 240);
                --highlight_color_light: rgba(105, 183, 240, 0.5);
                --highlight_color_dark: rgba(105, 183, 240, 0.75);
                --color_very_dark: rgb(20, 20, 20);
                --color_dark: rgb(50, 50, 50);
                --color_ldark: rgb(80, 80, 80);
                --color_med: rgb(100, 100, 100);
                --color_llight: rgb(120, 120, 120);
                --color_light: rgb(150, 150, 150);
                --color_very_light: rgb(200, 200, 200);
                --color_vvery_light: rgb(220, 220, 220);
                --color_vvvery_light: rgb(243, 243, 243);
                --default_text_color: black;
                --default_box_shadow: rgba(0, 0, 0, 0.25);
                --content_background: var(--color_vvvery_light);
                --menu_background: rgb(230, 230, 230);
                --default_border: var(--color_llight);
                --default_hover_border: var(--color_vvery_light);
                --default_selected_border: black;
                --button_background: var(--color_vvery_light);
                --button_hover_background: var(--color_very_light);
                --input_border: var(--color_very_light);
                --input_hover_border: var(--color_llight);
                --menu_item_background_b: var(--menu_background);
                --menu_item_background_a: var(--menu_background);
                --menu_item_background_hover: var(--color_vvery_light);
                --menu_item_background_active: var(--color_very_light);
                --menu_icon_description_text: var(--color_med);
                --setting_no: var(--color_light);
                --setting_hover: var(--color_med);
                --setting_yes: var(--color_dark);
                --settings_slider_bar: var(--color_ldark);
                --settings_slider_thumb: var(--color_very_light);
                --daypicker_move_icon_default: var(--color_ldark);
                --daypicker_move_icon_hover: var(--color_light);
                --daypicker_move_icon_active: lightblue;
                --daypicker_selected_days_background: rgba(105, 183, 240, 0.5);
                --daypicker_day_hover: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle fill='rgba(105, 183, 240, 0.5)' cx='16' cy='16' r='16'/%3E%3C/svg%3E");
                --daypicker_buttons: var(--button_background);
                --daypicker_buttons_hover: var(--button_hover_background);
                --daypicker_tooltip_background: var(--button_background);
                --daypicker_tooltip_text: var(--default_text_color);
                --daypicker_background: var(--color_vvvery_light);
                --tag_text: var(--default_text_color);
                --tag_border: var(--color_med);
                --tag_close_hover: var(--color_med);
                --disabled_font: var(--color_med);
                --selector_top_border: var(--color_very_light);
                --selector_tag_l0: var(--daypicker_background);
                --selector_tag_l1: var(--daypicker_background);
                /* --table_header: rgb(40,40,40);
        --table_header_selected: rgb(80,80,80);
        --table_first_row: var(--table_header);
        --table_first_row_selected: var(--table_header_selected);
        --table_content: var(--content_background);
        --table_caret_color: rgb(240,240,240);
        --table_highlight_selected: black; */
            }
    </style>
    <style>
                /* View */
                .view_container {
                    width: 100%;
                    height: 100%;
                    display: flex;
                }

                .show_view {
                    display: inline;
                }


                /* General Header */
                .header {
                    font-size: 20px;
                    margin-top: 10px;
                    margin-bottom: 10px;
                    font-weight: 600;
                }
                /* .header[seperate="true"] {
            margin-top: 30px;
        } */

                .text {
                    display: inline-block;
                    font-size: 14px;
                    line-height: 18px;
                }

                .subheader {
                    font-size: 18px;
                    font-weight: 600;
                    margin-bottom: 5px;
                }

                /* General Button */
                .standard_button {
                    background-color: var(--button_background);
                    border-radius: 10px;
                    /* border-color: var(--button_border); */
                    border-width: 0px;
                    padding: 5px;
                    padding-left: 20px;
                    padding-right: 20px;
                    font-size: 14px;
                    cursor: pointer;
                    color: var(--default_text_color);
                    user-select: none;
                }

                    .standard_button:focus {
                        outline: none;
                    }

                    .standard_button:hover {
                        background-color: var(--button_hover_background)
                    }

                    .standard_button:not([icononly = "true"]) i {
                        margin-right: 10px;
                    }

                    .standard_button.mini {
                        border: none;
                        height: 26px;
                    }

                        .standard_button.mini:hover {
                            background-color: var(--daypicker_buttons_hover)
                        }

                /* .standard_button.right {
            float: right;
        } */

                /* Charts*/
                .chart {
                }
                    /* Chart titles */
                    .chart > .title {
                        font-size: 15px;
                        letter-spacing: 2px;
                        margin-top: 10px;
                        margin-bottom: 10px;
                    }
    </style>
    <style>
        #title_container {
            margin: 15px;
            /* height: 60px; */
            font-size: 25px;
            font-weight: 600;
            text-align: center;
        }

        #title_image {
            margin-top: 15px;
            width: 50px;
        }

        #menu.hide #title_image {
            width: 25px;
        }

        #menu.hide #title_text {
            visibility: hidden;
        }

        /* Menu item */
        .menu_item:hover:enabled {
            background-color: rgb(61, 61, 61);
        }

        .menu_item:focus {
            background-color: rgb(61, 61, 61);
        }

        /* Default Item functionality and style */

        /* Menu Item */
        .menu_item {
            width: 200px;
            border: none;
            margin-bottom: 0px;
            /* letter-spacing: 0.5px; */
            text-align: left;
            padding-left: 18px;
            height: 40px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        #menu.hide .menu_item {
            width: 1000px;
            padding-left: 18px;
            overflow: hidden;
        }

        .menu_icon {
            width: 20px;
            text-align: center;
        }

        #menu.hide .menu_icon {
            width: 20px;
            margin-right: 15px;
            font-size: 18px;
        }

        #menu.hide .menu_item.description {
            /* visibility: hidden; */
            display: none;
        }

        #expand_menu {
            font-size: 18px;
            background-color: inherit;
            color: var(--daypicker_move_icon_default)
        }

            #expand_menu:focus {
                outline: 0;
            }

        #menu_unexpand {
            text-align: right;
            width: 100%;
        }

        #menu_expand {
            display: none;
        }

        #menu.hide #menu_expand {
            display: inline;
        }

        #menu.hide #menu_unexpand {
            display: none;
        }

        #expand_menu:hover {
            color: var(--daypicker_move_icon_hover)
        }

        .menu_item.description {
            width: 200px;
            height: 25px;
            cursor: auto;
            margin-top: 20px;
            /* margin-bottom: 10px; */
            line-height: normal;
            letter-spacing: 3px;
            font-size: 12px;
            color: var(--menu_icon_description_text);
        }

        .menu_item.menu_button {
            color: var(--menu_icon_button);
        }

            .menu_item.menu_button:hover:enabled {
                background-color: var(--menu_item_background_hover);
            }

            .menu_item.menu_button:focus {
                background-color: var(--menu_item_background_active) !important;
                outline: 0;
            }

            .menu_item.menu_button.selected {
                background-color: var(--menu_item_background_active) !important;
            }

            .menu_item.menu_button.typea {
                background-color: var(--menu_item_background_a);
            }

            .menu_item.menu_button.typeb {
                background-color: var(--menu_item_background_b);
            }
    </style>
    <style>
        #setting_ignore_app_container {
            max-height: calc(100vh - 300px);
            min-height: 100px;
            overflow-y: auto;
            overflow-x: hidden;
            width: 100%;
            margin-top: 10px;
        }

        .setting_ignore_app > .setting_entry {
            width: calc(100% - 50px);
            border-width: 1px;
            margin-right: 0px;
        }

        .setting_ignore_app > .standard_button {
            border: none;
            margin-left: 10px;
            width: 30px;
            height: 26px;
            padding: 0px;
        }
    </style>
    <style>
        #bugreport {
            color: var(--default_text_color);
            background-color: var(--content_background);
            border-color: var(--input_border);
            resize: none;
            width: 100%;
            height: 300px;
            font-size: 16px;
            padding: 30px;
        }

            #bugreport:focus {
                outline: none;
            }
    </style>
    <style>
                /* Day Picker */
                .day_picker_navigator {
                    vertical-align: top;
                    display: inline-block;
                    text-align: center;
                    height: 50px;
                    width: 50px;
                    line-height: 50px;
                    color: var(--daypicker_move_icon_default);
                    cursor: pointer;
                }

                    .day_picker_navigator:hover {
                        color: var(--daypicker_move_icon_hover);
                    }
                /* .day_picker_navigator:active {
            color: var(--daypicker_move_icon_active)
        } */

                #day_picker > .day {
                    display: inline-block;
                    width: 15%;
                    min-width: 50px;
                    max-width: 120px;
                    height: 50px;
                    line-height: 40px;
                    font-size: 20px;
                    text-align: center;
                    cursor: pointer;
                    transition: 0.25s ease-in-out;
                    margin-left: 3px;
                    margin-right: 3px;
                    border-bottom: 2px solid var(--default_border);
                }

                    #day_picker > .day > .number {
                        height: 20px;
                    }

                    #day_picker > .day > .month {
                        height: 30px;
                        margin-top: -5px;
                        font-size: 10px;
                    }

                    #day_picker > .day:hover {
                        border-bottom-color: var(--default_hover_border);
                    }

                    #day_picker > .day.selected {
                        border-bottom-color: var(--default_selected_border);
                    }
                /* #day_picker > .day:active {
            border-bottom-color: var(--highlight_color_light) !important;
        } */

                #day_picker {
                    vertical-align: top;
                    width: calc(100%);
                    max-width: 600px;
                    height: 50px;
                    text-align: center;
                    overflow: hidden;
                    user-select: none;
                }

                /* #day_picker:first-child {
            display: none !important;
        } */

                /* Components */
                #day_picker_container {
                    width: 100%;
                    padding: 20px;
                    justify-content: center;
                    display: flex;
                }

                #element_weekly {
                    width: 100%;
                    height: auto;
                    padding: 20px;
                }

                #element_daily {
                    width: 100%;
                    height: auto;
                    padding: 20px;
                }

                .chart_title {
                    font-size: 16px;
                    font-weight: 600;
                    margin-bottom: 10px;
                }

                /* Placeholders */
                #chart_daily {
                    width: 100%;
                }

                #chart_weekly_1 {
                    flex: 60% 0;
                    height: 400px;
                    margin-right: 20px;
                }

                #chart_weekly_2 {
                    flex: 1 0;
                    height: 400px;
                    margin-left: 20px;
                }

                #element_daily {
                    margin-bottom: 10px;
                }

                #element_daily, #element_weekly {
                    /* #chart_weekly_1, #chart_weekly_2, #chart_daily { */
                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                    background-color: white;
                    border-radius: 4px;
                    /* background-color: var(--color_vvvvery_light); */
                }

                .chart_title {
                    font-size: 21px;
                }
    </style>
    <style>
                /* Report */
                .searchbar {
                    box-shadow: none;
                    width: 300px;
                    padding: 5px;
                    padding-left: 15px;
                    font-size: 14px;
                    /* border-radius: 20px; */
                    background-color: var(--content_background);
                    color: var(--default_text_color);
                    border-color: var(--input_border);
                    border-style: solid;
                    border-width: 1px;
                }

                    .searchbar:hover {
                        border-color: var(--hover_border);
                    }

                    .searchbar:focus {
                        outline: none;
                    }

                input::-webkit-calendar-picker-indicator {
                    background-color: var(--content_background);
                }

                /* Doesnt seem possible to style this
         https://stackoverflow.com/questions/10062414/is-it-possible-to-style-the-drop-down-suggestions-when-using-html5-datalist/20763771
        */
                /* datalist {
            background-color: red !important;
            color: red !important;
        } */


                #tags_bar {
                    width: 100%;
                    margin-top: 10px;
                    margin-bottom: 10px;
                }

                .tag {
                    cursor: pointer;
                    color: var(--tag_text);
                    border: 1px solid var(--tag_border);
                    border-radius: 5px;
                    width: auto;
                    padding: 3px;
                    margin: 3px;
                    padding-left: 10px;
                    padding-right: 10px;
                    display: inline-block;
                    user-select: none;
                }

                    .tag:first-child {
                        margin-left: 0px;
                        background-color: red;
                    }

                    .tag.hide {
                        display: none;
                    }

                    .tag > i {
                        color: var(--tag_text);
                        font-size: 12px;
                        margin-left: 5px;
                    }

                    .tag:hover > i {
                        color: var(--tag_close_hover);
                    }

                /* Datepicker */
                #datepicker {
                    display: inline-block;
                    width: 300px;
                    padding: 5px;
                    padding-left: 15px;
                    font-size: 14px;
                    /* border-radius: 20px; */
                    background-color: var(--content_background);
                    border-color: var(--input_border);
                    border-style: solid;
                    border-width: 1px;
                }

                    #datepicker:hover {
                        border-color: var(--hover_border);
                    }

                    #datepicker:focus {
                        outline: none;
                        border-color: var(--hover_border);
                    }

                /* color overrides for datepicker */
                .lightpick {
                    background-color: var(--daypicker_background);
                    color: var(--default_text_color);
                    box-shadow: 0 1px 3px var(--default_box_shadow)
                }

                .lightpick__months, .lightpick__month {
                    background-color: var(--daypicker_background);
                }

                .lightpick__day, .lightpick__select {
                    cursor: pointer;
                    font-size: 12px;
                }

                    .lightpick__day:not(.is-disabled):hover {
                        background-size: contain;
                        background-image: var(--daypicker_day_hover);
                    }

                .lightpick__tooltip {
                    background-color: var(--daypicker_tooltip_background);
                    color: var(--daypicker_tooltip_text);
                }

                .lightpick__previous-action, .lightpick__next-action {
                    background-color: var(--daypicker_buttons);
                    cursor: pointer;
                }

                    .lightpick__previous-action:hover, .lightpick__next-action:hover {
                        background-color: var(--daypicker_buttons_hover);
                    }

                .lightpick__day.is-in-range {
                    background-color: var(--daypicker_selected_days_background);
                }

                .lightpick__tooltip::after {
                    border-top: 4px solid var(--daypicker_tooltip_background);
                }

                .lightpick__day.is-end-date.is-in-range, .lightpick__day.is-start-date.is-in-range.is-flipped,
                .lightpick__day.is-start-date.is-in-range, .lightpick__day.is-end-date.is-in-range.is-flipped {
                    background-color: var(--highlight_color);
                }

                /* -------- */

                #tags_suggestion_container {
                    position: absolute;
                    top: 92px;
                    width: 300px;
                    border-radius: 5px;
                    overflow: hidden;
                    box-shadow: 0 1px 3px var(--default_box_shadow)
                }

                    #tags_suggestion_container.hide {
                        display: none;
                    }

                #tags_suggestion_buttons_container {
                    height: 40px;
                    padding: 7px;
                    background-color: var(--selector_tag_l0);
                    text-align: center;
                }

                    #tags_suggestion_buttons_container .standard_button {
                        background-color: var(--daypicker_buttons);
                    }

                        #tags_suggestion_buttons_container .standard_button:hover {
                            background-color: var(--daypicker_buttons_hover);
                        }

                .tag_suggestion {
                    width: 100%;
                    height: 30px;
                    line-height: 20px;
                    overflow: hidden;
                    vertical-align: middle;
                    padding: 5px;
                    padding-left: 10px;
                    cursor: pointer;
                    user-select: none;
                    font-size: 12px;
                }

                    .tag_suggestion.hide {
                        display: none;
                    }

                    .tag_suggestion.unselectable {
                        color: var(--disabled_font);
                    }


                    .tag_suggestion:not(:first-child) {
                        border-top: 1px solid var(--selector_top_border);
                    }

                    .tag_suggestion.l0 {
                        margin-left: 0px;
                        background-color: var(--selector_tag_l0);
                        text-transform: uppercase;
                        letter-spacing: 2px;
                        color: var(--disabled_font);
                    }

                    .tag_suggestion.l1 {
                        padding-left: 40px;
                        background-color: var(--selector_tag_l1);
                        border-top: 1px solid var(--content_background);
                    }

                    .tag_suggestion.selected {
                        background-color: var(--highlight_color_light);
                    }

                    .tag_suggestion.l1:hover:not(.selected) {
                        background-color: var(--highlight_color_dark);
                    }

                    .tag_suggestion.l1:hover.selected {
                        background-color: var(--highlight_color_dark);
                    }
    </style>
    <style>
        /* SETTINGS */

        .setting {
            font-size: 14px;
            margin-bottom: 10px;
        }

        /* Yes - No - Setting */
        .setting_text {
            display: inline-block;
            vertical-align: top;
            line-height: 24px;
        }

        .setting_yes, .setting_no {
            display: inline-block;
            cursor: pointer;
            margin-right: 10px;
            font-size: 24px;
            color: var(--setting_no);
        }

        .setting_no {
            color: var(--setting_no);
        }

        .setting_yes {
            color: var(--setting_yes);
        }

        .setting:hover .setting_no, .setting:hover .setting_yes {
            color: var(--setting_hover);
        }

        .setting[status = "true"] .setting_no {
            display: none;
        }

        .setting[status = "false"] .setting_yes {
            display: none;
        }

        /* Text Entry */
        .setting_entry {
            outline: 0;
            padding: 5px;
            font-size: 12px;
            background-color: var(--content_background);
            margin-right: 12px;
            border: 1px solid var(--input_border);
            margin-top: 5px;
            width: 75px;
        }

            .setting_entry:hover {
                border-color: var(--input_hover_border);
            }

            .setting_entry ~ .setting_text {
                vertical-align: middle;
            }

        /* Slider - Setting */
        .setting_slider {
            width: 300px;
            display: inline-block;
            margin-top: 10px;
            -webkit-appearance: none;
            height: 7.5px;
            border-radius: 10px;
            background: var(--settings_slider_bar);
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

            .setting_slider:hover {
                opacity: 1; /* Fully shown on mouse-over */
            }

            .setting_slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: var(--settings_slider_thumb);
                cursor: pointer;
            }

        .setting_slider_text {
            display: inline-block;
            font-size: 12px;
        }
    </style>
    <style>
        /* Table */
        .spacer {
            display: inline-block;
            width: 20px;
            text-align: center;
        }

        .jexcel > thead > tr > td {
            background-color: var(--table_header);
        }

        .jexcel > tbody > tr > td:first-child {
            background-color: var(--table_first_row);
        }

        .jexcel {
            background-color: var(--table_content);
        }

            .jexcel > thead > tr > td.selected {
                background-color: var(--table_header_selected);
            }

            .jexcel > tbody > tr.selected > td:first-child {
                background-color: var(--table_header_selected);
            }

        .jexcel_corner {
            background-color: var(--table_caret_color);
            border: 1px solid var(--table_caret_color);
        }

        .jexcel .highlight-selected {
            background-color: var(--table_highlight_selected);
        }

        .jexcel .highlight {
            background-color: var(--table_highlight_selected);
        }
    </style>

    <!-- Main Javascript  -->
    <script>

        /* Constants */

        let current_view;
        let VIEW_DAILY;
        let VIEW_WEEKLY;
        let VIEW_SETTINGS;
        let VIEW_TRACKING_SETTINGS;
        let VIEW_EDIT_DATA;

        // ----------------- General --------------------

        let open_link = (url) => {
            //Todo - open link in C#
            window.open(url, '_blank');
        }

        // ----------------- Menu --------------------

        let toggle_menu = () => {
            document.getElementById("menu").classList.toggle("hide");
        }

        let expand_menu = () => {
            console.log("expanding")
            document.getElementById("menu").classList.remove("hide");
        }

        let unexpand_menu = () => {
            console.log("unexpand menu")
            document.getElementById("menu").classList.add("hide");
        }


        // ----------------- View/Window Management --------------------

        class View {
            constructor(options) {
                this.view_id = options.view_id;
                this.button_id = options.button_id;
                this.components = options.components;

                this.view = document.getElementById(this.view_id);
                this.button = document.getElementById(this.button_id);
            }

            select_view() {
                if (this === current_view)
                    return;

                if (current_view !== undefined)
                    current_view.hide()

                this.show()
                current_view = this;
            }

            /* Show and hide content panel*/
            show() {
                this.view.classList.add("show_view")
                this.button.classList.add("selected");
            }
            hide() {
                this.view.classList.remove("show_view")
                this.button.classList.remove("selected");
            }
        }

        // ----------------- Overrides for niceness sake --------------------

        Date.prototype.nth = getOrdinalNum = (n) => {
            return n + (n > 0 ? ['th', 'st', 'nd', 'rd'][(n > 3 && n < 21) || n % 10 > 3 ? 0 : n % 10] : '');
        }

        Date.prototype.add_days = function (days) {
            var date = new Date(this.valueOf());
            date.setDate(date.getDate() + days);
            return date;
        }

        Date.prototype.add_months = function (months) {
            var date = new Date(this.valueOf());
            date.setMonth(date.getMonth() + months);
            return date;
        }

        // ----------------- Day Picker --------------------

        class DayPickerDay {
            constructor(date, parent) {
                this.date = date;
                this.parent = parent;

                this.div = document.createElement("div");
                this.div.className = "day";
                this.div.parentClassElement = this;

                this.div_number = document.createElement("div");
                this.div_number.textContent = getOrdinalNum(date.getDate());
                this.div_number.className = "number"

                this.div_month = document.createElement("div");
                this.div_month.textContent = date.toLocaleString('en-us', { month: 'long' }) + " '" + (date.getFullYear() + "").slice(2);
                this.div_month.className = "month"

                this.div.appendChild(this.div_number);
                this.div.appendChild(this.div_month);

                //Overriden if center
                this.div.onclick = () => {
                    this.parent.set_center_date(date);
                }
            }

            set_selected() {
                this.div.classList.add("selected");
                this.div.onclick = (e) => {

                    //Stop container from closing straight away
                    e.stopPropagation();

                    if (!this.parent.datepicker_open) {
                        this.parent.open()
                    }
                    else {
                        this.parent.close()
                    }

                }
            }

            set_unselected() {
                this.div.classList.remove("selected");
            }
        }

        class DayPicker {
            constructor(options) {

                //General
                this.date = options.date;

                //Element ids
                //Navigation & Co
                this.days_container_id = options.days_container_id;
                this.button_back_days_id = options.button_back_days_id;
                this.button_forward_days_id = options.button_forward_days_id;
                this.button_back_months_id = options.button_back_months_id;
                this.button_forward_months_id = options.button_forward_months_id;
                //Datepicker
                this.datepicker_container_id = options.datepicker_container_id;
                this.button_to_today_id = options.button_to_today_id;

                //Get components
                this.div_days_container = document.getElementById(this.days_container_id);
                this.button_back_days = document.getElementById(this.button_back_days_id)
                this.button_forward_days = document.getElementById(this.button_forward_days_id)
                this.button_back_months = document.getElementById(this.button_back_months_id)
                this.button_forward_months = document.getElementById(this.button_forward_months_id)

                this.datepicker_container = document.getElementById(this.datepicker_container_id)
                this.button_to_today = document.getElementById(this.button_to_today_id)

                //Days visible
                this.day_picker_dates = [];

                //Datepicker creation
                this.date_picker = new Lightpick({
                    field: document.getElementById("day_picker_dummy_field"),
                    inline: true,
                    lang: 'en',
                    onSelect: (date) => {
                        this.set_center_date(date.toDate())
                        this.close()
                    }
                });
                this.date_picker.setDate(new Date())
                this.date_picker_open = false;

                this.datepicker_container.onclick = (e) => {
                    e.stopPropagation();
                }

                //Listeners
                this._add_button_listeners();

                //Init
                this.set_center_date(this.date)
            }

            _add_button_listeners() {
                this.button_to_today.onclick = () => {
                    this.set_center_date(new Date())
                }
                this.button_back_days.onclick = () => {
                    this.shift_days(-5);
                }
                this.button_forward_days.onclick = () => {
                    this.shift_days(+5);
                }
                this.button_back_months.onclick = () => {
                    this.shift_months(-1)
                }
                this.button_forward_months.onclick = () => {
                    this.shift_months(+1)
                }
            }

            _add_date_components() {
                this.day_picker_dates = [];
                let tmp_date = new Date(this.date)
                tmp_date.setDate(this.date.getDate() - 2);
                for (let i = 0; i < 5; i++) {
                    let day_picker = new DayPickerDay(new Date(tmp_date), this);
                    this.day_picker_dates.push(day_picker)
                    this.div_days_container.appendChild(day_picker.div)
                    tmp_date.setDate(tmp_date.getDate() + 1);
                }
            }

            _remove_all() {
                while (this.div_days_container.firstChild) {
                    this.div_days_container.firstChild.remove();
                }
            }

            open() {
                document.getElementById("day_picker_dummy_container").style.display = "inline";
                this.datepicker_open = true;
                document.body.addEventListener("click", this.close)
            }

            close() {
                document.body.removeEventListener("click", this.close)
                document.getElementById("day_picker_dummy_container").style.display = "none";
                this.datepicker_open = false;
            }

            get_center_div() {
                return this.day_picker_dates[parseInt(Math.floor(this.day_picker_dates / 2))]
            }

            set_center_date(date) {

                this.date = date;
                this._remove_all();
                this._add_date_components();

                let center_day_picker = this.day_picker_dates.filter(day_picker => day_picker.date.getDate() === this.date.getDate())[0];
                center_day_picker.set_selected();

                this.close();
            }

            shift_days(amount_of_days) {
                this.date_picker.setDate(this.date.add_days(amount_of_days));
            }

            shift_months(amount_of_months) {
                this.date_picker.setDate(this.date.add_months(amount_of_months));
            }

        }

        let day_picker;
        const date_to_day_of_year = (date) => {
            var start = new Date(date.getFullYear(), 0, 0);
            var diff = (date - start) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000);
            var day = Math.floor(diff / (1000 * 60 * 60 * 24));
            return day;
        }

        // ----------------- Settings --------------------

        let dark_mode = (status) => {
            document.getElementById("setting_dark_mode").setAttribute("status", status);
            document.documentElement.setAttribute("dark_mode", status)
        }

        // ----------------- Edit Data --------------------

        const data = [
            ['Google', 100, 100, 100, 100, 1998, 807.80],
            ['Apple', 100, 100, 100, 100, 1976, 116.52],
            ['Yahoo', 100, 100, 100, 100, 1994, 38.66],
            ['Google', 100, 100, 100, 100, 1998, 807.80],
            ['Apple', 100, 100, 100, 100, 1976, 116.52],
            ['Yahoo', 100, 100, 100, 100, 1994, 38.66],
            ['Google', 100, 100, 100, 100, 1998, 807.80],
            ['Apple', 100, 100, 100, 100, 1976, 116.52],
            ['Yahoo', 100, 100, 100, 100, 1994, 38.66],
            ['Google', 100, 100, 100, 100, 1998, 807.80],
            ['Apple', 100, 100, 100, 100, 1976, 116.52],
            ['Yahoo', 100, 100, 100, 100, 1994, 38.66],
        ];

        // ----------------- Report --------------------

        class TagBar {
            constructor(options) {

                this.options = options.options;
                this.selected = options.selected || [];

                this.tag_container_id = options.tag_container_id;
                this.div = document.getElementById(this.tag_container_id);

                this.input_id = options.input_id;
                this.div_input = document.getElementById(this.input_id);

                this._add_input_listeners();
                this._make_datalist();
                this._set_datalist_options(this.options);
            }

            _add_input_listeners() {
                let last_non_matching = null;
                this.div_input.onkeyup = (e) => {
                    /* this works because when appending from the datalist via enter, no key is
                    pressed even tho the keyup is triggered - dont ask me why */
                    if (e.keyCode === undefined) {
                        this.div_input.value = last_non_matching;
                    }
                }

                this.div_input.oninput = (e) => {
                    if (this.options.includes(e.srcElement.value)) {
                        this.select_tag(e.srcElement.value);
                    } else {
                        last_non_matching = e.srcElement.value;
                    }
                }
            }

            _make_datalist() {
                this.datalist = document.createElement("datalist")
                this.datalist.id = this.tag_container_id + "_datalist";
                this.div.appendChild(this.datalist)
            }

            _set_datalist_options(options) {
                while (this.datalist.firstChild) {
                    this.datalist.removeChild(this.datalist.firstChild);
                }
                for (let option of options) {
                    let datalist_option = document.createElement("option");
                    datalist_option.value = option;
                    this.datalist.appendChild(datalist_option);
                }
            }

            add_option(option) {
                this.options.push(option);
                this.update_options();
            }

            remove_option(option) {
                this.unselect_tag(option)
                let index = this.selected.indexOf(tag);

                if (index === -1)
                    return;

                this.selected.splice(index, 1);
                this.options.push(option);
                this.update_options();
            }

            update_options() {
                let selected_options = this.selected.map(tag => tag.tag_name);
                let left_options = this.options.filter((el) => !selected_options.includes(el));
                this._set_datalist_options(left_options);
            }

            select_tag(tag_name) {

                if (!this.options.includes(tag_name)) {
                    console.error(`Trying to add tag "${tag_name}", not in options.`);
                    return;
                }

                if (this.selected.filter(tag => tag.tag_name === tag_name).length !== 0) {
                    console.error(`Trying to add tag "${tag_name}", already selected.`);
                    return;
                }

                let tag = new Tag(tag_name, this);
                this.selected.push(tag);
                this.div.appendChild(tag.div);
                this.update_options();
            }

            unselect_tag(tag_name) {
                let tag = this.selected.filter(tag => tag.tag_name === tag_name);
                if (tag.length === 0)
                    return;

                tag = tag[0];
                let index = this.selected.indexOf(tag);
                this.selected.splice(index, 1);
                this.div.removeChild(tag.div)
                this.update_options();
            }
        }

        class Tag {
            constructor(tag_name, parent) {
                this.tag_name = tag_name;
                this.parent = parent;
                this.create_dom();
            }
            create_dom() {
                this.div = document.createElement("div");
                this.div.className = "tag";
                this.div.textContent = this.tag_name;
                this.div_close = document.createElement("i");
                this.div_close.className = "fas fa-times";
                this.div.appendChild(this.div_close);

                this.div.onclick = (e) => {
                    this.parent.unselect_tag(this.tag_name);
                }
            }
        }

        // -----------------------------------------------------------------

        let test = (options) => {
            if (!options.test2) {
                console.error("missing argument");
                return;
            }
            console.log("reached next");
        }

        // -----------------------------------------------------------------

        const getDayData = async () => {
            return new Promise((resolve, reject) => {
                resolve([
                    {
                        label: "WORK",
                        colors: ["#7cd6fd", "#5e64ff"],
                        values: [{
                            start: 8 * 60,
                            length: 120,
                            title: "Project 1"
                        },
                        {
                            start: 11 * 60,
                            length: 45,
                            title: "Project 2"
                        },
                        {
                            start: 13 * 60,
                            length: 120,
                            title: "Project 1"
                        }]
                    },
                    {
                        label: "STUDY",
                        colors: ["#98d85b"],
                        values: [{
                            start: 10 * 60,
                            length: 60,
                            title: "Topic 1"
                        },
                        {
                            start: 15 * 60,
                            length: 90,
                            title: "Topic 1"
                        },
                        {
                            start: 16 * 60 + 45,
                            length: 90,
                            title: "Topic 1"
                        }]
                    }
                ]);
            });
        }

        const getWeekDataBreakdown = async () => {
            return new Promise((resolve, reject) => {
                resolve({
                    labels: ["Mo", "Tu", "We", "Th", "Fr", "Sa", "Su", "Mo", "Tu", "We"],
                    datasets: [
                        {
                            values: [0.25, 0.5, 0.25, 0.5, 0.25, 0.5, 0.25, 0.5, 0.25, 0.5],
                            title: "test"
                        },
                        {
                            values: [0.5, 0.2, 0.5, 0.2, 0.5, 0.2, 0.5, 0.2, 0.5, 0.2]
                        },
                        {
                            values: [0.25, 0.1, 0.25, 0.1, 0.25, 0.1, 0.25, 0.1, 0.25, 0.1]
                        },
                    ],
                });
            });
        }

        const getWeekDataSum = async () => {
            return new Promise((resolve, reject) => {
                resolve({
                    labels: ["Work", "Study"],
                    datasets: [
                        {
                            values: [0.25, 0.5],
                            title: "test"
                        },
                        {
                            values: [0.5, 0.2]
                        },
                        {
                            values: [0.25, 0.1]
                        },
                    ],
                });
            });
        }


        init = () => {

            day_picker = new DayPicker({
                date: new Date(),
                days_container_id: "day_picker",
                button_back_days_id: "day_back",
                button_forward_days_id: "day_forward",
                button_back_months_id: "month_back",
                button_forward_months_id: "month_forward",
                datepicker_container_id: "day_picker_dummy_container",
                // datepicker_clingy_field_id: "day_picker_dummy_field",
                button_to_today_id: "button_to_today"
            });
            VIEW_DAILY = new View({
                view_id: "view_daily",
                button_id: "button_view_daily",
                components: { day_picker: day_picker }
            });

            getDayData().then(timelines => {
                const chart1 = new TimeCharts.Timeline("#chart_daily", {
                    scale: {
                        from: 7 * 60,
                        to: 19 * 60,
                        intervalStart: 0
                    },
                    data: {
                        timelines: timelines,
                    },
                    legend: true,
                    padding: {
                        top: 20,
                        right: 20,
                        bottom: 20,
                        left: 20
                    },
                    legendDistance: 15,
                    distance: 20,
                    adjustSize: true
                });
            });

            getWeekDataBreakdown().then(data => {
                const chart2 = new TimeCharts.Barchart("#chart_weekly_1", {
                    data: data,
                    padding: {
                        top: 20,
                        right: 20,
                        bottom: 20,
                        left: 20
                    },
                    distance: 20
                });
            });

            getWeekDataSum().then(data => {
                const chart3 = new TimeCharts.Barchart("#chart_weekly_2", {
                    data: data,
                    orientation: "horizontal",
                    padding: {
                        top: 20,
                        right: 20,
                        bottom: 20,
                        left: 20
                    },
                    distance: 20
                });
            });

            edit_data_excel = jexcel(document.getElementById('edit_data_table'), {
                data: data,
                colWidths: [300, 100, 100, 50, 50, 100, 100]
            });
            VIEW_EDIT_DATA = new View({
                view_id: "view_edit_data",
                button_id: "button_view_edit_data",
                components: {
                    edit_data_excel: edit_data_excel
                }
            });


            // let tag_selector = new TagBar({
            // 	options: ["Wish You Were Here", "Welcome to the Machine", "Have a Cigar", "Shine On You Crazy Diamond", "Another Brick in the Wall"],
            // 	tag_container_id: "tags_bar",
            // 	input_id: "datalist_report_select"
            // });
            let date_picker = new Lightpick({
                field: document.getElementById('datepicker'),
                singleDate: false,
                numberOfMonths: 2,
            });
            VIEW_REPORT = new View({
                view_id: "view_report",
                button_id: "button_view_report",
                components: {
                    date_picker: date_picker
                }
            });


            VIEW_ABOUT = new View({
                view_id: "view_about",
                button_id: "button_view_about"
            });

            VIEW_BUGREPORT = new View({
                view_id: "view_bugreport",
                button_id: "button_view_bugreport"
            });

            VIEW_SETTINGS = new View({
                view_id: "view_settings",
                button_id: "button_view_settings"
            });

            let ignore_apps = new IgnoreApps({
                div_container_id: "setting_ignore_app_container",
                button_add_id: "add_app_to_ignore",
                apps_to_ignore: ["explorer", "WindowsTimeTracker", "AdobeXD", "Java", "explorer", "WindowsTimeTracker", "AdobeXD", "Java", "explorer", "WindowsTimeTracker", "AdobeXD", "Java", "explorer", "WindowsTimeTracker", "AdobeXD", "Java"]
            })

            VIEW_TRACKING_SETTINGS = new View({
                view_id: "view_tracking_settings",
                button_id: "button_view_tracking_settings",
                components: {
                    ignore_apps: ignore_apps
                }
            });

            let tag_options = [
                {
                    name: "Over1",
                    children: [
                        {
                            name: "Under 1x",
                        },
                        {
                            name: "Under 1y",
                        },
                    ]
                },
                {
                    name: "Over2",
                    children: [
                        {
                            name: "Under2z",
                            level: 1,
                        },
                        {
                            name: "Under2a",
                            level: 1,
                        },
                    ]
                },
                {
                    name: "Over3",
                    children: [
                        {
                            name: "Under 1x",
                        },
                        {
                            name: "Under 1y",
                        },
                    ]
                },
                {
                    name: "Over1",
                    children: [
                        {
                            name: "Under 1",
                        },
                        {
                            name: "Under 1",
                        },
                    ]
                },
                {
                    name: "Over1",
                    children: [
                        {
                            name: "Under 1",
                        },
                        {
                            name: "Under 1",
                        },
                    ]
                }
            ]
            tagselector = new TagSelector({
                container_id: "tags_suggestion_container",
                input_id: "tags_selector",
                button_tags_select_all_id: "button_tags_select_all",
                button_tags_unselect_all_id: "button_tags_unselect_all",
                tag_bar_id: "tags_bar",
                tag_options: tag_options
            });

            VIEW_DAILY.select_view();
        }

        class TagSelector {
            constructor(options) {
                this.container_id = options.container_id;
                this.input_id = options.input_id;
                this.button_tags_select_all_id = options.button_tags_select_all_id;
                this.button_tags_unselect_all_id = options.button_tags_unselect_all_id;
                this.tag_bar_id = options.tag_bar_id;

                this.container = document.getElementById(this.container_id);
                this.input = document.getElementById(this.input_id);
                this.button_tags_select_all = document.getElementById(this.button_tags_select_all_id);
                this.button_tags_unselect_all = document.getElementById(this.button_tags_unselect_all_id);
                this.tag_bar = document.getElementById(this.tag_bar_id);

                this.tag_options = options.tag_options;

                this.hovering = false;
                this.mode_add = true;

                this.children = [];

                for (let tag_option of this.tag_options) {
                    // this.createGuiElement(tag_option)
                    let tag = new Tag2({
                        tag_name: tag_option.name,
                        level: 0,
                        handler: this,
                        children: []
                    })
                    this.children.push(tag);
                    this.container.appendChild(tag.div);
                    this.tag_bar.appendChild(tag.div_tag);
                    if (tag_option.children) {
                        for (let tag_child of tag_option.children) {
                            let tag_c = new Tag2({
                                tag_name: tag_child.name,
                                level: 1,
                                handler: this,
                                parent: tag
                            })
                            tag.children.push(tag_c);
                            this.container.appendChild(tag_c.div);
                            this.tag_bar.appendChild(tag_c.div_tag);
                        }
                    }
                }

                this._add_listeners()
            }

            _add_listeners() {
                //Upon clicking the input box, open the selector
                this.input.onclick = (e) => {
                    e.stopPropagation();
                    this.open();
                }
                //When clicking on the selector, stop event propagation (otherwise would close itself)
                this.container.onclick = (e) => {
                    e.stopPropagation();
                }

                //Upon typing, search
                this.input.oninput = (e) => {
                    this.filter(this.input.value);
                }

                //Buttons
                this.button_tags_select_all.onclick = () => {
                    this.input.focus();
                    this.children.map(child => {
                        if (child.showing)
                            child.select()
                    });
                }
                this.button_tags_unselect_all.onclick = () => {
                    this.input.focus();
                    this.children.map(child => {
                        if (child.showing)
                            child.unselect()
                    });
                }
            }

            select_all_visibile() {
                this.children.map(child => {
                    if (child.showing) {
                        child.select();
                    }
                });
            }

            filter(query) {
                this.children.map(child => child.filter(query));
            }

            open() {
                this.container.style.display = "inherit";
                this.showing = true;
                document.body.addEventListener("click", this.close)
            }

            close() {
                this.container.style.display = "none";
                this.showing = false;
                document.body.removeEventListener("click", this.close)
            }

            createGuiElement(tag_option) {
                let div_tag = document.createElement("div");
                div_tag.textContent = tag_option.name;
                div_tag.classList.add("tag_suggestion")
                if (tag_option.level === 0)
                    div_tag.classList.add("l0")
                else
                    div_tag.classList.add("l1")
                this.container.appendChild(div_tag)

                div_tag.onmousedown = (e) => {
                    console.log("down", tag_option.name);

                    if (div_tag.classList.contains("selected")) {
                        this.mode_add = false;
                    } else {
                        this.mode_add = true;
                    }
                    div_tag.classList.toggle("selected");

                    this.hovering = true;
                }
                div_tag.onmouseup = (e) => {
                    console.log("up", tag_option.name);
                    this.hovering = false;
                }
                div_tag.onmouseenter = (e) => {
                    // console.log("enter", tag_option.name);
                    if (this.hovering && this.mode_add) {
                        div_tag.classList.add("selected");
                    } else if (this.hovering && !this.mode_add) {
                        div_tag.classList.remove("selected");
                    }
                }
            }
        }

        class TagX {
            constructor(tag_name, parent) {
                this.tag_name = tag_name;
                this.parent = parent;
                this.create_dom();
            }
            create_dom() {
                this.div = document.createElement("div");
                this.div.className = "tag";
                this.div.textContent = this.tag_name;
                this.div_close = document.createElement("i");
                this.div_close.className = "fas fa-times";
                this.div.appendChild(this.div_close);

                this.div.onclick = (e) => {
                    this.parent.unselect();
                }
            }
        }

        class Tag2 {
            constructor(options) {
                this.tag_name = options.tag_name;
                this.level = options.level;
                this.children = options.children || [];
                this.parent = options.parent || undefined;
                this.handler = options.handler;

                this.selectable = true;

                //Create gui element for tag
                this.div_tag = document.createElement("div");
                this.div_tag.className = "tag hide";
                this.div_tag.textContent = this.tag_name;
                this.div_tag_close = document.createElement("i");
                this.div_tag_close.className = "fas fa-times";
                this.div_tag.appendChild(this.div_tag_close);

                //Create gui element in selector
                this.div = document.createElement("div");
                this.div.textContent = this.tag_name;
                this.div.classList.add("tag_suggestion")

                if (this.level === 0)
                    this.div.classList.add("l0")
                else
                    this.div.classList.add("l1")

                this._add_listeners();
            }

            _add_listeners() {
                this.div.onmousedown = (e) => {
                    // console.log("down", this.tag_name);

                    if (this, this.is_selected) {
                        this.handler.mode_add = false;
                        this.unselect();
                    } else {
                        this.handler.mode_add = true;
                        this.select();
                    }

                    this.handler.hovering = true;
                }
                this.div.onmouseup = (e) => {
                    // console.log("up", this.tag_name);
                    this.handler.hovering = false;
                }
                this.div.onmouseenter = (e) => {
                    // console.log("enter", tag_option.name);
                    if (this.handler.hovering && this.handler.mode_add) {
                        if (this.children.length === 0)
                            this.select();
                    } else if (this.handler.hovering && !this.handler.mode_add) {
                        if (this.children.length === 0)
                            this.unselect();
                    }
                }
                this.showing = true;

                this.div_tag.onclick = () => {
                    this.unselect();
                }
            }

            _set_unselectable() {
                this.div.classList.add("unselectable");
                this.selectable = false;
            }
            _set_selectable() {
                this.div.classList.remove("unselectable");
                this.selectable = true;
            }

            filter(query) {
                if (this.tag_name.includes(query)) {
                    this.show();
                    this._set_selectable();
                    this.children.map(child => child.show());
                    return true;
                } else {
                    let found = this.children.filter(child => child.filter(query)).length;
                    // console.log(this.tag_name, found, query)
                    if (found !== 0 && found === this.children.length) {
                        this.show();
                        this._set_selectable();
                    } else if (found !== 0) {
                        this._set_unselectable();
                        this.show();
                    } else {
                        this.hide();
                    }
                }
            }

            show() {
                this.showing = true;
                this.div.classList.remove("hide")
            }

            hide() {
                this.showing = false;
                this.div.classList.add("hide")
            }

            //Selects & permutates to children
            select() {
                if (this.selectable) {
                    for (let child of this.children) {
                        child.select()
                    }
                    if (this.children.length === 0)
                        this.div.classList.add("selected")
                    this.is_selected = true;

                    if (this.children.length === 0)
                        this.div_tag.classList.remove("hide")
                }
            }

            // Unselects only iteself
            unselect_excl() {
                this.is_selected = false;
                this.div.classList.remove("selected")
            }

            // Unselects & permutates to children
            unselect() {
                for (let child of this.children) {
                    child.unselect()
                }
                if (this.parent) {
                    this.parent.unselect_excl();
                }
                this.is_selected = false;
                this.div.classList.remove("selected")
                this.div_tag.classList.add("hide")
            }
        }


        class IgnoreApps {
            constructor(options) {
                this.div_container_id = options.div_container_id;
                this.div_container = document.getElementById(this.div_container_id);

                this.button_add_id = options.button_add_id;
                this.button_add = document.getElementById(this.button_add_id);

                this.elements = [];
                if (options.apps_to_ignore !== undefined) {
                    for (let app of options.apps_to_ignore) {
                        this.create(app);
                    }
                }

                this.button_add.onclick = () => {
                    this.create();
                }
            }

            tolist() {
                this.elements.map(element => element.get_text());
            }

            create(text = "") {
                let ignore_app_element = new IgnoreAppElement(text, this);
                this.div_container.appendChild(ignore_app_element.div);
                this.elements.push(ignore_app_element);
                this.div_container.scrollTop = this.div_container.scrollHeight;
            }

            remove(ignore_app_element) {
                this.div_container.removeChild(ignore_app_element.div);
                this.elements.splice(this.elements.indexOf(ignore_app_element), 1);
            }
        }

        class IgnoreAppElement {
            constructor(text, parent) {
                this.parent = parent;

                this.div = document.createElement("div");
                this.div.className = "setting_ignore_app";

                this.div_entry = document.createElement("input");
                this.div_entry.className = "setting_entry";
                this.div_entry.value = text;

                this.button = document.createElement("button");
                this.button.className = "standard_button";
                this.button.setAttribute("icononly", "true");

                this.icon = document.createElement("i")
                this.icon.className = "fas fa-times";

                this.button.appendChild(this.icon)
                this.div.appendChild(this.div_entry)
                this.div.appendChild(this.button)

                this.button.onclick = () => {
                    this.parent.remove(this);
                }
            }

            get_text() {
                return this.div_entry.value;
            }
        }
    </script>


</head>

<style>
    /* Overrides */
    *:not(.time-chart-tooltip):not(.time-chart-tooltip *) {
        box-sizing: border-box;
        color: var(--default_text_color);
        transition: 0.15s ease-in-out;
    }

    body {
        margin: 0px;
        display: flex;
        height: 100%;
        font-family: Helvetica;
    }

    /* For fontawesome - take original color */
    .fas {
        color: none;
        /* color: inherit */
    }

    /* Site stuff components (Important, thats why its here) :)*/
    #menu {
        flex: 0 200px;
        background-color: var(--menu_background);
        height: 100vh;
        z-index: 2;
        overflow: hidden;
    }

        #menu.hide {
            flex: 0 53px;
        }

    .content {
        height: 100vh;
        flex: 1 0;
        padding: 20px;
        background-color: var(--content_background);
        display: none;
        overflow-x: hidden;
        overflow-y: auto;
    }

    .show_view {
        display: inline;
    }

    #day_picker_dummy_container {
        position: absolute;
        top: 100px;
    }

    #day_picker_addition {
        width: 296px;
        background-color: var(--daypicker_background);
        border-radius: 5px;
        padding: 10px;
        margin-bottom: -5px;
    }

    /* -------------------------------------------------- */

    @media only screen and (max-height: 650px) {
        #title_image {
            margin-top: 0px;
            width: 40px;
        }

        #menu.hide .menu_item {
            height: 30px;
            font-size: 12px;
        }

        #title_text {
            display: none;
        }
    }
    /* @media only screen and (max-height: 650px) {
        .menu_item {
            height: 30px;
            font-size: 12px;
        }
        #title_text {
            display: none;
        }
        #title_image {
            margin-top: 0px;
            width: 40px;
        }
        #menu.hide #title_container {
            height: 30px;
        }
        #title_container {
            height: 70px;
        }
        #menu.hide .menu_icon {
            font-size: 14px;
        }
    } */

</style>

<body onload="init()">
    <div id="menu" class="hide">
        <button id="expand_menu" class="menu_item" onclick="toggle_menu()">
            <i class="far fa-caret-square-left" id="menu_unexpand" style="color: inherit"></i>
            <i class="fas fa-caret-square-right" id="menu_expand" style="color: inherit"></i>
        </button>
        <div id="title_container" class="title">
            <img id="title_image" src="Icon.png" width="100%">
            <div id="title_text">Timetracker</div>
        </div>
        <div class="menu_item description">
            <!-- <i class="menu_icon fas fa-chart-line"></i> -->
            VIEWS
        </div>
        <button class="menu_item menu_button typea" id="button_view_daily" onclick="VIEW_DAILY.select_view();">
            <i class="menu_icon fas fa-calendar-day"></i>
            Daily
        </button>
        <button class="menu_item menu_button typeb" id="button_view_report" onclick="VIEW_REPORT.select_view();">
            <i class="menu_icon fas fa-calendar-alt"></i>
            Monthly
        </button>
        <!-- <div class="menu_item description">STATISTICS</div>
        <button class="menu_item menu_button typea">
            <i class="fas fa-chart-line"></i>
            Overall
        </button> -->
        <div class="menu_item description">
            <!-- <i class="menu_icon fas fa-keyboard"></i> -->
            TRACKING
        </div>
        <button class="menu_item menu_button typea" id="button_view_edit_data" onclick="VIEW_EDIT_DATA.select_view()">
            <i class="menu_icon fas fa-edit"></i>
            Edit data
        </button>
        <div class="menu_item description">
            <!-- <i class="menu_icon fas fa-cogs"></i> -->
            SETTINGS
        </div>
        <button class="menu_item menu_button typea" id="button_view_tracking_settings" onclick="VIEW_TRACKING_SETTINGS.select_view()">
            <i class="menu_icon fas fa-sliders-h"></i>
            Tracking
        </button>
        <button class="menu_item menu_button typeb" id="button_view_settings" onclick="VIEW_SETTINGS.select_view()">
            <i class="menu_icon fas fa-cog"></i>
            General
        </button>
        <div class="menu_item description">
            <!-- <i class="menu_icon fas fa-bars"></i> -->
            ABOUT
        </div>
        <button class="menu_item menu_button typea" id="button_view_bugreport" onclick="VIEW_BUGREPORT.select_view()">
            <i class="menu_icon fas fa-bug"></i>
            Report Issue
        </button>
        <button class="menu_item menu_button typeb" id="button_view_about" onclick="VIEW_ABOUT.select_view()">
            <i class="menu_icon fas fa-info"></i>
            About
        </button>
        <!--
        <div id="bottom_box">
            <button id="test_menu_item" class="menu_item menu_button typea">About</button>
            <button id="test_menu_item" class="menu_item menu_button typeb">App Settings</button>
        </div>
        -->
    </div>

    <div id="view_bugreport" class="content">
        <div class="header">Bug Report</div>
        <div class="text">Since you're here, something seems to have gone wrong. We're sorry to heart that!</div>
        <br>
        <div class="text">Please tell us what didn't work and we'll have a look.</div>
        <br><br>
        <textarea id="bugreport" rows="4" cols="50" name="comment" form="usrform"></textarea>
        <br><br>
        <button class="standard_button">
            <i class="fas fa-paper-plane"></i>
            Send
        </button>
    </div>

    <div id="view_about" class="content">
        <div class="header">About</div>
        <div class="text">Made with &#x2764; by&nbsp;</div>
        <button class="standard_button" onclick="open_link('https://github.com/RobinWeitzel')">
            <i class="fab fa-github"></i>
            RobinWeitzel
        </button>
        <div class="text">&nbsp;and&nbsp;</div>
        <button class="standard_button" onclick="open_link('https://github.com/TristanMenzinger')">
            <i class="fab fa-github"></i>
            TristanMenzinger
        </button>
        <br><br>
        <div class="subheader">Data Protection</div>
        <div class="text">
            We made this app so you can track yourself, for yourself. <br>
            All data is stored locally, there is zero traffic to any servers. We encourage you to have a look at the Project
            on GitHub and have a look for yourself. <br> Since we won't ever interrupt you for feedback and don't track usage statistics by default, we rely on you to send us feedback.
        </div>
        <br><br>
        <div class="subheader">Feedback or suggestion?</div>
        <div class="text">Write an&nbsp;</div>
        <button class="standard_button">
            <i class="fas fa-envelope"></i>
            E-Mail
        </button>
        <br><br>
        <div class="subheader">Want to have a look?</div>
        <button class="standard_button" onclick="open_link('https://github.com/RobinWeitzel/WindowsTimeTracker')">
            <i class="fab fa-github"></i>
            Visit the project on GitHub
        </button>
        <br><br>
        <div class="subheader">Dependencies</div>
        <div class="text">CsvHelper by JoshClose (Apache-2.0)</div><br>
        <div class="text">CefSharp by CefSharp Community (BSD)</div><br>
        <div class="text">Lighpick by wakirin (MIT)</div><br>
        <div class="text">JExcel2 by paulhodel (MIT)</div><br>
    </div>

    <div id="view_edit_data" class="content">
        <div class="header">Manually Edit Data</div>
        <button class="standard_button">
            <i class="fas fa-folder-open"></i>
            Open
        </button>
        <button class="standard_button">
            <i class="fas fa-archive"></i>
            Export / Backup
        </button>
        <div class="spacer">|</div>
        <button class="standard_button">
            <i class="fas fa-backspace"></i>
            Discard Changes
        </button>
        <button class="standard_button">
            <i class="fas fa-save"></i>
            Save
        </button>
        <div class="spacer">|</div>
        <button class="standard_button" icononly="true">
            <i class="fas fa-undo"></i>
        </button>
        <button class="standard_button" icononly="true">
            <i class="fas fa-redo"></i>
        </button>
        <br><br>
        <div id="edit_data_table"></div>
    </div>

    <div id="view_settings" class="content">
        <div class="header">General Settings</div>
        <div class="subheader">Application</div>
        <div class="setting" status="false" id="setting_dark_mode">
            <i class="setting_no fas fa-toggle-off" onclick="dark_mode(true)"></i>
            <i class="setting_yes fas fa-toggle-on" onclick="dark_mode(false)"></i>
            <div class="setting_text">Dark Mode</div>
        </div>
        <br>
        <div>
            <div class="subheader">Notifications</div>
            <div class="setting">
                <input class="setting_entry">
                <div class="setting_text">Amount of time a notification is visible on screen</div>
            </div>
            <div class="setting" status="false">
                <i class="setting_no fas fa-toggle-off"></i>
                <i class="setting_yes fas fa-toggle-on"></i>
                <div class="setting_text">Make a sound every time a notification is shown</div>
            </div>
        </div>
        <br>
        <div>
            <div class="subheader">Trigger Delay</div>
            <div class="setting" status="false">
                <input class="setting_entry">
                <div class="setting_text">
                    Amount of time that must have passed before the Timetracker asks again
                    to what activity a window belongs
                </div>
            </div>
            <div class="setting" status="false">
                <input class="setting_entry">
                <div class="setting_text">
                    Amount of time in which the Timetracker does not ask for an activity after selecting one
                </div>
            </div>
        </div>
        <br>
        <div>
            <div class="subheader">Hotkeys</div>
            <div class="setting" status="false">
                <i class="setting_no fas fa-toggle-off"></i>
                <i class="setting_yes fas fa-toggle-on"></i>
                <div class="setting_text">Enable global hotkey</div>
            </div>
            <div class="setting" status="false">
                <input class="setting_entry">
                <div class="setting_text">
                    Enter Hotkey
                </div>
            </div>
        </div>
        <div class="text">s = Seconds, m = Minutes, h = Hours</div>
        <br><br>
        <div>
            <div class="subheader">Telemetry</div>
            <div class="setting" status="true">
                <i class="setting_no fas fa-toggle-off"></i>
                <i class="setting_yes fas fa-toggle-on"></i>
                <div class="setting_text">Send usage statistics</div>
            </div>
            <div class="text">
                We do not send any activity data or personal information.
                Upon installation, a unique ID is generated that is sent
                along with the number of app uses.
            </div>
            <br>
        </div>
        <br>
        <!-- <div class="setting">
            <div class="setting_text">Choose sensitivity</div>
            <br>
            <div class="setting_slider_text">0</div>
            <input class="setting_slider" type="range" min="1" max="100" value="50">
            <div class="setting_slider_text">100</div>
        </div> -->
        <button class="standard_button">
            <i class="fas fa-backspace"></i>
            Discard
        </button>
        <button class="standard_button">
            <i class="fas fa-save"></i>
            Save
        </button>
    </div>

    <div id="view_tracking_settings" class="content">
        <div class="header">Tracking Settings</div>
        <div class="subheader">Blacklist Apps</div>
        <button class="standard_button" icononly="true" id="add_app_to_ignore">
            <i class="fas fa-plus-circle"></i>
        </button>
        <br>
        <div id="setting_ignore_app_container">
            <!-- <div class="setting_ignore_app">
                <input class="setting_entry">
                <button class="standard_button" icononly="true">
                    <i class="fas fa-trash-alt"></i>
                </button>
            </div> -->
        </div>
        <br>
        <!-- <button class="standard_button">
            <i class="fas fa-archive"></i>
            Export / Backup
        </button> -->
        <button class="standard_button right">
            <i class="fas fa-backspace"></i>
            Discard
        </button>
        <button class="standard_button right">
            <i class="fas fa-save"></i>
            Save
        </button>
    </div>

    <div id="view_report" class="content">
        <div class="header">Activity Report</div>
        <!-- <input id="datalist_report_select" list="tags_bar_datalist" class="searchbar" type="text" placeholder="Activity or Group Name" multiple> -->
        <input type="text" id="tags_selector" class="searchbar" />
        <input type="text" id="datepicker" />
        <div id="tags_bar"></div>
        <div id="tags_suggestion_container" class="hide">
            <div id="tags_suggestion_buttons_container">
                <button id="button_tags_select_all" class="standard_button mini">
                    <i class="fas fa-circle"></i>
                    Select
                </button>
                <button id="button_tags_unselect_all" class="standard_button mini">
                    <i class="far fa-circle"></i>
                    Unselect
                </button>
            </div>
        </div>
        <div id="chart_single_inbox_activity_heatmap_single"></div>
    </div>

    <div id="view_daily" class="content">
        <div id="day_picker_container">
            <div class="day_placeholder"></div>
            <div id="month_back" class="day_picker_navigator">
                <i class="fas fa-angle-double-left" style="color: inherit"></i>
            </div>
            <div id="day_back" class="day_picker_navigator">
                <i class="fas fa-angle-left" style="color: inherit"></i>
            </div>
            <!-- Has to be exactly here, otherwise wont work for positioning! -->
            <div id="day_picker_dummy_container">
                <div id="day_picker_addition">
                    <button id="button_to_today" class="standard_button mini">
                        <!-- <i class="fas fa-crosshairs"></i> -->
                        <i class="fas fa-calendar-day"></i>
                        Today
                    </button>
                </div>
                <!-- Because the datepicker needs an element to cling onto -->
                <div id="day_picker_dummy_field"></div>
            </div>
            <div id="day_picker">
                <!-- <div class="day">
                    <div class="number">17th</div>
                    <div class="month">MARCH</div>
                </div> -->
            </div>
            <div id="day_forward" class="day_picker_navigator">
                <i class="fas fa-angle-right" style="color: inherit"></i>
            </div>
            <div id="month_forward" class="day_picker_navigator">
                <i class="fas fa-angle-double-right" style="color: inherit"></i>
            </div>
            <div class="day_placeholder"></div>
        </div>
        <div id="element_daily" class="chart">
            <div class="chart_title">This day</div>
            <div id="chart_daily">HI</div>
        </div>
        <div id="element_weekly" class="chart">
            <div class="chart_title">That week</div>
            <div class="view_container">
                <div id="chart_weekly_1"></div>
                <div id="chart_weekly_2"></div>
            </div>
        </div>
    </div>
</body>

</html>